(()=>{"use strict";const v=!1;function e(M,b){if(v&&("boolean"!=typeof M&&(M=M()),!M))throw"string"!=typeof(b=b??"Programmer Error")&&(b=b()),new Error(`Assert: ${b}`)}function i(v,M){return v-M}function s(v,M){return v!==M?v<M?-1:1:0}function n(v,M){return v===M?0:v<M?-1:1}function r(v,M,b){return void 0===M?void 0===b?0:-1:void 0===b?1:v(M,b)}function o(v,M){return r(n,v,M)}function a(v){const M=parseInt(v,16);return Number.isNaN(M)?0:M}function c(v,M,b=!0){const E=v.charCodeAt(M);return E>=(b?48:49)&&E<=57||E>=97&&E<=102}function h(v,M,b){if(0===b)return!1;if(!c(v,M,!1))return!1;for(let E=1;E<b;E++)if(!c(v,M+E))return!1;return!0}var M,b,E,D,X,z,R,O,Y,N,B,V,L,U,Sr,Cr,kr,Fr,Xr,zr,Rr,Or,Yr,Nr,Lr,Kr,qr,Qr,eo,io,no,ro,oo,ho;function Z(v){return v}!function(v){v.getLocalId=function(v){if(g(v))return 0;const M=v.length,b=M>12?M-10:2;return a(v.slice(b))},v.getBriefcaseId=function(v){if(g(v))return 0;const M=v.length;return M<=12?0:a(v.slice(2,M-10))},v.fromJSON=function(M){return"string"==typeof M?v.fromString(M):v.invalid},v.fromString=function(M){if("string"!=typeof M)return v.invalid;if(v.isId64(M))return M;const b=(M=M.toLowerCase().trim()).length;if(b<2||"0"!==M[0]||"x"!==M[1])return v.invalid;let E=0,D=0,X=2;return b>12&&(X=b-10,D=a(M.slice(2,X))),E=a(M.slice(X)),i(E,D)};const M=["0000000000","000000000","00000000","0000000","000000","00000","0000","000","00","0",""];function i(b,E){if("number"!=typeof b||"number"!=typeof E)return v.invalid;if(0===(b=Math.floor(b)))return v.invalid;E=Math.floor(E);const D=b.toString(16);return`0x${0===E?D:E.toString(16)+(M[D.length]+D)}`}v.fromLocalAndBriefcaseIds=i;const b=[48,120,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48];function n(v){return v+(v<10?48:87)}function r(v,M,b){let E=0;for(let X=M;X<b;X++)E=(E|(D=v.charCodeAt(X))-(D>=87?87:48)<<(b-X-1<<2))>>>0;var D;return E}function o(M,E){if(0==(M>>>0)+4294967296*(255&E))return v.invalid;const D=b;let X=2;for(let v=7;v>=0;v--){const M=v<<2,b=(E&15<<M)>>>M;(X>2||0!==b)&&(D[X++]=n(b))}for(let v=7;v>=0;v--){const b=v<<2,E=(M&15<<b)>>>b;(X>2||0!==E)&&(D[X++]=n(E))}return D.length!==X&&(D.length=X),String.fromCharCode(...b)}function c(v){if(g(v))return 0;const M=v.length;return r(v,M>10?M-8:2,M)}function l(v){const M=v.length;return M<=10||g(v)?0:r(v,2,M-8)}function*d(v){if("string"==typeof v)yield v;else for(const M of v)yield M}function u(v){return 18===v.length&&v.startsWith("0xffffff")}function f(M){return v.invalid!==M&&v.isId64(M)}function g(M){return v.invalid===M}v.fromUint32Pair=o,v.fromUint32PairObject=function(v){return o(v.lower,v.upper)},v.isValidUint32Pair=function(v,M){return 0!==v||0!=(255&M)},v.getUint32Pair=function(v,M){return M||(M={lower:0,upper:0}),M.lower=c(v),M.upper=l(v),M},v.getLowerUint32=c,v.getUpperUint32=l,v.toIdSet=function(v,M=!1){if(v instanceof Set)return M?new Set(v):v;const b=new Set;return"string"==typeof v?b.add(v):Array.isArray(v)&&v.forEach((v=>{"string"==typeof v&&b.add(v)})),b},v.iterator=d,v.iterable=function(v){return{[Symbol.iterator]:()=>d(v)}},v.getFirst=function(v){return"string"==typeof v?v:Array.isArray(v)?v[0]:v.values().next().value},v.sizeOf=function(v){return"string"==typeof v?1:Array.isArray(v)?v.length:v.size},v.has=function(v,M){return"string"==typeof v?v===M:Array.isArray(v)?-1!==v.indexOf(M):v.has(M)},v.invalid="0",v.isTransient=u,v.isTransientId64=function(v){return f(v)&&u(v)},v.isId64=function(v){const M=v.length;if(0===M||18<M)return!1;if("0"!==v[0])return!1;if(1===M)return!0;if(2===M||"x"!==v[1])return!1;let b=2;if(M>12){if(b=M-10,!h(v,2,b-2))return!1;for(let E=b;E<M&&48===v.charCodeAt(E);E++)b++;if(b>=M)return!1}return h(v,b,M-b)},v.isValid=function(M){return v.invalid!==M},v.isValidId64=f,v.isInvalid=g,v.Uint32Set=class{constructor(v){this._map=new Map,void 0!==v&&this.addIds(v)}clear(){this._map.clear()}addId(M){this.add(v.getLowerUint32(M),v.getUpperUint32(M))}addIds(M){for(const b of v.iterable(M))this.addId(b)}hasId(M){return this.has(v.getLowerUint32(M),v.getUpperUint32(M))}add(v,M){let b=this._map.get(M);void 0===b&&(b=new Set,this._map.set(M,b)),b.add(v)}deleteId(M){this.delete(v.getLowerUint32(M),v.getUpperUint32(M))}deleteIds(M){for(const b of v.iterable(M))this.deleteId(b)}delete(v,M){const b=this._map.get(M);void 0!==b&&b.delete(v)}has(v,M){const b=this._map.get(M);return void 0!==b&&b.has(v)}hasPair(v){return this.has(v.lower,v.upper)}get isEmpty(){return 0===this._map.size}get size(){let v=0;for(const M of this._map)v+=M[1].size;return v}toId64Array(){const M=[];for(const b of this._map)for(const E of b[1])M.push(v.fromUint32Pair(E,b[0]));return M}toId64Set(){const M=new Set;for(const b of this._map)for(const E of b[1])M.add(v.fromUint32Pair(E,b[0]));return M}forEach(v){for(const M of this._map)for(const b of M[1])v(b,M[0])}},v.Uint32Map=class{constructor(){this._map=new Map}clear(){this._map.clear()}getById(M){return this.get(v.getLowerUint32(M),v.getUpperUint32(M))}setById(M,b){this.set(v.getLowerUint32(M),v.getUpperUint32(M),b)}set(v,M,b){let E=this._map.get(M);void 0===E&&(E=new Map,this._map.set(M,E)),E.set(v,b)}get(v,M){const b=this._map.get(M);return void 0!==b?b.get(v):void 0}get isEmpty(){return 0===this._map.size}get size(){let v=0;for(const M of this._map)v+=M[1].size;return v}forEach(v){for(const M of this._map)for(const b of M[1])v(b[0],M[0],b[1])}}}(M||(M={})),function(v){const M=new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");function i(v){return M.test(v)}v.empty="00000000-0000-0000-0000-000000000000",v.isGuid=i,v.isV4Guid=function(v){return/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(v)},v.createValue=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(v=>{const M=16*Math.random()|0;return("x"===v?M:3&M|8).toString(16)}))},v.normalize=function(v){const M=v.toLowerCase().trim();if(i(M))return M;const b=M.replace(/-/g,""),E=/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/;return E.test(b)?b.replace(E,((v,M,b,E,D,X)=>`${M}-${b}-${E}-${D}-${X}`)):v}}(b||(b={})),function(v){function i(v,M){return v.length!==M.length?v.length<M.length?-1:1:v!==M?v<M?-1:1:0}function*s(v){const M=v[Symbol.iterator]();let b,E=M.next();for(;!E.done;){const v=E.value;E=M.next(),v!==b&&(b=v,yield v)}}function*n(v,M){const b=v[Symbol.iterator](),E=M[Symbol.iterator]();let D,X=b.next(),z=E.next();for(;!X.done||!z.done;){const v=X.done?void 0:X.value,M=z.done?void 0:z.value;if(e(void 0!==v||void 0!==M),void 0===v&&void 0===M)break;let R;if(void 0===v)e(void 0!==M),R=M,z=E.next();else if(void 0===M)R=v,X=b.next();else{const D=i(v,M);D<=0?(R=v,X=b.next(),0===D&&(z=E.next())):(R=M,z=E.next())}D!==R&&(D=R,yield R)}}function*r(v,M){const b=v[Symbol.iterator](),E=M[Symbol.iterator]();let D,X=b.next(),z=E.next();for(;!X.done&&!z.done;){const v=X.value;if(X=b.next(),v===D)continue;D=v;let M=z.value,R=i(v,M);for(;R>0;){if(z=E.next(),z.done)return;M=z.value,R=i(v,M)}0===R&&(yield v)}}function*o(v,M){const b=v[Symbol.iterator](),E=M[Symbol.iterator]();let D,X=b.next(),z=E.next();for(;!X.done;){const v=X.value;if(X=b.next(),v===D)continue;if(z.done){yield D=v;continue}let M=z.value,R=i(v,M);for(;R>0&&!z.done;)z=E.next(),z.done?yield D=v:(M=z.value,R=i(v,M));R<0&&(yield D=v)}}v.compare=i,v.sortArray=function(v){return v.sort(((v,M)=>i(v,M))),v},v.areEqualSets=function(v,M){const b=s(v),E=s(M);let D=b.next(),X=E.next();for(;!D.done&&!X.done;){if(0!==i(D.value,X.value))return!1;D=b.next(),X=E.next()}return!(!D.done||!X.done)},v.isEmptySet=function(v){return"string"==typeof v?""===v:!0===v[Symbol.iterator]().next().done},v.unique=function(v){return{[Symbol.iterator]:()=>s(v)}},v.uniqueIterator=s,v.union=function(v,M){return{[Symbol.iterator]:()=>n(v,M)}},v.intersection=function(v,M){return{[Symbol.iterator]:()=>r(v,M)}},v.difference=function(v,M){return{[Symbol.iterator]:()=>o(v,M)}},v.unionIterator=n,v.intersectionIterator=r,v.differenceIterator=o}(E||(E={})),function(v){v[v.Allow=0]="Allow",v[v.Retain=1]="Retain",v[v.Replace=2]="Replace"}(D||(D={})),Symbol.iterator,function(v){function i(v){return v>=48&&v<=57||v>=65&&v<=70}function s(v,M){e(M>0);const b=`+${v.toString()}`;return M<=1?b:`${b}*${M.toString(16).toUpperCase()}`}function n(v){const M="string"==typeof v?[v]:Array.from(v);return E.sortArray(M),r(M)}function r(v){return o(v)}function o(v){if("string"==typeof v)return v;let b="";const E=new a,D=new a;let X=0;const z=new a,R=new a;for(const O of v){if(!M.isValidId64(O))continue;z.setFromId(O),R.setFromDifference(z,E);const v=E.compare(z);if(0!==v){if(v>0)throw new Error("CompressedId64Set.compressArray requires a sorted array as input");E.copyFrom(z),0===X?(D.copyFrom(R),X=1):R.equals(D)?++X:(b+=s(D,X),D.copyFrom(R),X=1)}}return 0<X&&(b+=s(D,X)),b}v.compressSet=function(v){return n(v)},v.sortAndCompress=n,v.compressArray=r,v.compressIds=o;class a{static assertUint32(v){e(v>=0),e(v<a._base),e(Math.floor(v)===v)}assertConstraints(){a.assertUint32(this.lower),a.assertUint32(this.upper)}constructor(v=0,M=0){this.lower=v,this.upper=M,this.assertConstraints()}compare(v){const M=this.upper-v.upper;return 0===M?this.lower-v.lower:M}equals(v){return 0===this.compare(v)}isLessThan(v){return this.compare(v)<0}isGreaterThan(v){return this.compare(v)>0}get isZero(){return 0===this.lower&&0===this.upper}setFromDifference(v,M){e(!M.isGreaterThan(v)),this.lower=v.lower-M.lower,this.upper=v.upper-M.upper,this.lower<0&&(this.lower+=a._base,this.upper-=1)}add(v){let M=v.lower,b=v.upper;M+this.lower>=a._base&&(M-=a._base,b+=1),this.lower+=M,this.upper+=b,this.assertConstraints()}setFromId(v){M.getUint32Pair(v,this)}copyFrom(v){this.lower=v.lower,this.upper=v.upper}toString(){if(0===this.upper)return this.lower.toString(16).toUpperCase();const v=this.upper.toString(16),M=this.lower.toString(16).padStart(8,"0");return e(8===M.length),`${v}${M}`.toUpperCase()}toId64String(){return M.fromUint32Pair(this.lower,this.upper)}}function*c(v){if(0===v.length)return;if("+"!==v[0])throw new Error("Invalid CompressedId64Set");let M=1;const b=new a;function r(){let b=0,E=0;for(;M<v.length&&E<8;){++E;const D=v.charCodeAt(M);if(!i(D))break;b<<=4,b|=D>=65?D-65+10:D-48,b>>>=0,++M}return b}function o(b){let E=0,D=0;const X=M,z=r(),R=M-X;if(e(R<=8),8===R&&M+1<v.length&&i(v.charCodeAt(M+1))){const v=M,b=r(),X=M-v;e(X>0&&X<=8);const R=8-X;D=z>>>4*R,E=(b|z-(D<<4*R>>>0)<<4*X>>>0)>>>0}else E=z;b.lower=E,b.upper=D}const E=new a;for(;M<v.length;){let D=1;if(o(E),E.isZero)throw new Error("Invalid CompressedId64Set");if(M<v.length)switch(v[M++]){case"*":if(D=r(),0===D)throw new Error("Invalid CompressedId64Set");if(M!==v.length&&"+"!==v[M++])return;break;case"+":break;default:throw new Error("Invalid CompressedId64Set")}for(let v=0;v<D;v++)b.add(E),yield b.toId64String()}}function h(v){return{[Symbol.iterator]:()=>c(v)}}a._base=4294967296,v.iterator=c,v.iterable=h,v.decompressSet=function(v,M){const b=M??new Set;for(const E of h(v))b.add(E);return b},v.decompressArray=function(v,M){const b=M??[];for(const E of h(v))b.push(E);return b}}(X||(X={})),Symbol.iterator;class W{constructor(v=0,M){this._radians=v,this._degrees=M}clone(){return new W(this._radians,this._degrees)}freeze(){return Object.freeze(this)}static createDegrees(v){return new W(W.degreesToRadians(v),v)}static createRadians(v){return new W(v)}static createSmallAngle(){return new W(K.smallAngleRadians)}static createInterpolate(v,M,b){return new W(K.interpolate(v.radians,M,b.radians))}cloneScaled(v){return new W(this.radians*v)}setRadians(v){this._radians=v,this._degrees=void 0}setDegrees(v){this._radians=W.degreesToRadians(v),this._degrees=v}static create360(){return new W(2*Math.PI,360)}static createAtan2(v,M){return new W(Math.atan2(v,M))}setFrom(v){this._radians=v._radians,this._degrees=v._degrees}setFromJSON(v,M){this._radians=M||0,v&&("number"==typeof v?this.setDegrees(v):"number"==typeof v.degrees?this.setDegrees(v.degrees):"number"==typeof v._degrees?this.setDegrees(v._degrees):"number"==typeof v.radians?this.setRadians(v.radians):"number"==typeof v._radians&&this.setRadians(v._radians))}static fromJSON(v,M){const b=new W;return b.setFromJSON(v,M),b}toJSON(){return this.degrees}toJSONRadians(){return{radians:this.radians}}get radians(){return this._radians}get degrees(){return void 0!==this._degrees?this._degrees:W.radiansToDegrees(this._radians)}static degreesToRadians(v){return v*Math.PI/180}static radiansToDegrees(v){if(v<0)return-W.radiansToDegrees(-v);const M=Math.PI;return v<=.25*M?180/M*v:v<.75*M?90+(v-.5*M)/M*180:v<=1.25*M?180+(v-M)/M*180:v<=1.75*M?270+(v-1.5*M)/M*180:360+(v-2*M)/M*180}cos(){return Math.cos(this._radians)}sin(){return Math.sin(this._radians)}tan(){return Math.tan(this._radians)}static isFullCircleRadians(v){return Math.abs(v)>=K.fullCircleRadiansMinusSmallAngle}static isHalfCircleRadians(v){return Math.abs(Math.abs(v)-Math.PI)<=K.smallAngleRadians}get isFullCircle(){return W.isFullCircleRadians(this._radians)}get isHalfCircle(){return W.isHalfCircleRadians(this._radians)}static adjustDegrees0To360(v){if(v>=0){const M=360;return v<M?v:v-Math.floor(v/M)*M}return v<0?360-W.adjustDegrees0To360(-v):0}static adjustDegreesSigned180(v){if(Math.abs(v)<=180)return v;if(v>=0){const M=360;return v-(1+Math.floor((v-180)/M))*M}return v<0?-W.adjustDegreesSigned180(-v):0}static adjustRadians0To2Pi(v){if(v>=0){const M=2*Math.PI;return v<M?v:v-Math.floor(v/M)*M}return v<0?2*Math.PI-W.adjustRadians0To2Pi(-v):0}static adjustRadiansMinusPiPlusPi(v){if(Math.abs(v)<=Math.PI)return v;if(v>=0){const M=2*Math.PI;return v-(1+Math.floor((v-Math.PI)/M))*M}return v<0?-W.adjustRadiansMinusPiPlusPi(-v):0}static zero(){return new W(0)}get isExactZero(){return 0===this.radians}get isAlmostZero(){return Math.abs(this.radians)<K.smallAngleRadians}get isAlmostNorthOrSouthPole(){return W.isHalfCircleRadians(2*this.radians)}static createDegreesAdjustPositive(v){return W.createDegrees(W.adjustDegrees0To360(v))}static createDegreesAdjustSigned180(v){return W.createDegrees(W.adjustDegreesSigned180(v))}static isAlmostEqualRadiansAllowPeriodShift(v,M,b=K.smallAngleRadians){const E=Math.abs(v-M);if(E<=b)return!0;const D=2*Math.PI;if(Math.abs(E-D)<=b)return!0;const X=E-Math.round(E/D)*D;return Math.abs(X)<=b}isMagnitudeLessThanOrEqual(v){return Math.abs(this.radians)<=Math.abs(v.radians)}isAlmostEqualAllowPeriodShift(v,M=K.smallAngleRadians){return W.isAlmostEqualRadiansAllowPeriodShift(this._radians,v._radians,M)}static isAlmostEqualRadiansNoPeriodShift(v,M,b=K.smallAngleRadians){return Math.abs(v-M)<b}isAlmostEqualNoPeriodShift(v,M=K.smallAngleRadians){return W.isAlmostEqualRadiansNoPeriodShift(this._radians,v._radians,M)}isAlmostEqual(v,M=K.smallAngleRadians){return this.isAlmostEqualNoPeriodShift(v,M)}static isPerpendicularDotSet(v,M,b){return v>K.smallMetricDistanceSquared&&M>K.smallMetricDistanceSquared&&b*b<=K.smallAngleRadiansSquared*v*M}static trigValuesToHalfAngleTrigValues(v,M){const b=K.hypotenuseXY(v,M);if(b<K.smallMetricDistance)return{c:1,s:0,radians:0};{let E,D=0;const X=v/b,z=M/b;return X>=0?(E=Math.sqrt(.5*(1+X)),D=z/(2*E)):(D=z>0?Math.sqrt(.5*(1-X)):-Math.sqrt(.5*(1-X)),E=z/(2*D)),{c:E,s:D,radians:Math.atan2(D,E)}}}static cleanupTrigValue(v,M=K.smallFloatingPoint){const b=Math.abs(v);if(b<=M)return 0;let E=Math.abs(b-.5);return E<=M?v<0?-.5:.5:(E=Math.abs(b-1),E<=M?v<0?-1:1:v)}static dotProductsToHalfAngleTrigValues(v,M,b,E=!0){const D=v-M,X=2*b;return E&&Math.abs(X)<K.smallAngleRadians*(Math.abs(v)+Math.abs(M))?{c:1,s:0,radians:0}:W.trigValuesToHalfAngleTrigValues(D,X)}static radiansBetweenVectorsXYZ(v,M,b,E,D,X){const z=v*E+M*D+b*X;return Math.atan2(K.crossProductMagnitude(v,M,b,E,D,X),z)}static orientedRadiansBetweenVectorsXYZ(v,M,b,E,D,X,z,R,O,Y=!1){const N=v*E+M*D+b*X,B=M*X-b*D,V=b*E-v*X,L=v*D-M*E,U=z*B+R*V+O*L,Sr=K.hypotenuseXYZ(B,V,L);return U<0?Y?Math.PI+Math.atan2(Sr,-N):-Math.atan2(Sr,N):Math.atan2(Sr,N)}addMultipleOf2PiInPlace(v){void 0!==this._degrees?(this._degrees+=360*v,this._radians=W.degreesToRadians(this._degrees)):this._radians+=v*W.pi2Radians}}W.piOver12Radians=.26179938779914946,W.piOver4Radians=.7853981633974483,W.piOver2Radians=1.5707963267948966,W.piRadians=3.141592653589793,W.pi2Radians=6.283185307179586,W.degreesPerRadian=45/W.piOver4Radians,W.radiansPerDegree=W.piOver4Radians/45;class G{set(v=0,M=0){this.x=v,this.y=M}setZero(){this.x=0,this.y=0}constructor(v=0,M=0){this.x=v,this.y=M}setFrom(v){v?(this.x=v.x,this.y=v.y):(this.x=0,this.y=0)}freeze(){return Object.freeze(this)}isAlmostEqual(v,M){return K.isSameCoordinate(this.x,v.x,M)&&K.isSameCoordinate(this.y,v.y,M)}isAlmostEqualXY(v,M,b){return K.isSameCoordinate(this.x,v,b)&&K.isSameCoordinate(this.y,M,b)}toJSON(){return[this.x,this.y]}toJSONXY(){return{x:this.x,y:this.y}}setFromJSON(v){Array.isArray(v)?this.set(v[0]||0,v[1]||0):v?this.set(v.x||0,v.y||0):this.set(0,0)}distance(v){const M=v.x-this.x,b=v.y-this.y;return Math.sqrt(M*M+b*b)}distanceSquared(v){const M=v.x-this.x,b=v.y-this.y;return M*M+b*b}maxDiff(v){return Math.max(Math.abs(this.x-v.x),Math.abs(this.y-v.y))}at(v){return v<.5?this.x:this.y}setAt(v,M){v<.5?this.x=M:this.y=M}indexOfMaxAbs(){let v=0;const M=Math.abs(this.x);return Math.abs(this.y)>M&&(v=1),v}get isAlmostZero(){return K.isSmallMetricDistance(this.x)&&K.isSmallMetricDistance(this.y)}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}isExactEqual(v){return this.x===v.x&&this.y===v.y}isAlmostEqualMetric(v,M=K.smallMetricDistance){return this.maxDiff(v)<=M}vectorTo(v,M){return J.create(v.x-this.x,v.y-this.y,M)}unitVectorTo(v,M){return this.vectorTo(v,M).normalize(M)}static crossProductToPoints(v,M,b){return K.crossProductXYXY(M.x-v.x,M.y-v.y,b.x-v.x,b.y-v.y)}}class H extends G{constructor(v=0,M=0){super(v,M)}clone(v){return H.create(this.x,this.y,v)}static create(v=0,M=0,b){return b?(b.x=v,b.y=M,b):new H(v,M)}static fromJSON(v){const M=new H;return M.setFromJSON(v),M}static createFrom(v,M){return v?H.create(v.x,v.y,M):H.create(0,0,M)}static createZero(v){return H.create(0,0,v)}addForwardLeft(v,M,b,E){const D=b.x,X=b.y;return H.create(this.x+v*D-M*X,this.y+v*X+M*D,E)}forwardLeftInterpolate(v,M,b){const E=b.x-this.x,D=b.y-this.y;return H.create(this.x+v*E-M*D,this.y+v*D+M*E)}interpolate(v,M,b){if(v<=.5)return H.create(this.x+v*(M.x-this.x),this.y+v*(M.y-this.y),b);const E=v-1;return H.create(M.x+E*(M.x-this.x),M.y+E*(M.y-this.y),b)}interpolateXY(v,M,b,E){return H.create(K.interpolate(this.x,v,b.x),K.interpolate(this.y,M,b.y),E)}minus(v,M){return H.create(this.x-v.x,this.y-v.y,M)}plus(v,M){return H.create(this.x+v.x,this.y+v.y,M)}plusXY(v=0,M=0,b){return H.create(this.x+v,this.y+M,b)}plusScaled(v,M,b){return H.create(this.x+v.x*M,this.y+v.y*M,b)}plus2Scaled(v,M,b,E,D){return H.create(this.x+v.x*M+b.x*E,this.y+v.y*M+b.y*E,D)}plus3Scaled(v,M,b,E,D,X,z){return H.create(this.x+v.x*M+b.x*E+D.x*X,this.y+v.y*M+b.y*E+D.y*X,z)}dotVectorsToTargets(v,M){return(v.x-this.x)*(M.x-this.x)+(v.y-this.y)*(M.y-this.y)}crossProductToPoints(v,M){const b=v.x-this.x,E=v.y-this.y,D=M.x-this.x;return b*(M.y-this.y)-E*D}fractionOfProjectionToLine(v,M,b=0){const E=v.distanceSquared(M);return E<K.smallMetricDistanceSquared?b:v.dotVectorsToTargets(M,this)/E}}class J extends G{constructor(v=0,M=0){super(v,M)}clone(v){return J.create(this.x,this.y,v)}static create(v=0,M=0,b){return b?(b.x=v,b.y=M,b):new J(v,M)}static unitX(v=1){return new J(v,0)}static unitY(v=1){return new J(0,v)}static createZero(v){return J.create(0,0,v)}static createFrom(v,M){return v instanceof Float64Array?v.length>=2?J.create(v[0],v[1]):v.length>=1?J.create(v[0],0):J.create(0,0):J.create(v.x,v.y,M)}static fromJSON(v){const M=new J;return M.setFromJSON(v),M}static createPolar(v,M){return J.create(v*M.cos(),v*M.sin())}static createStartEnd(v,M,b){return J.create(M.x-v.x,M.y-v.y,b)}static createOffsetBisector(v,M,b){let E=v.plus(M);if(E=E.normalize(),E){const M=E.dotProduct(v);return E.scale(b,E),E.safeDivideOrNull(M)}}safeDivideOrNull(v,M){if(0!==v)return this.scale(1/v,M)}normalize(v){const M=K.correctSmallFraction(this.magnitude());return v=v||new J,this.safeDivideOrNull(M,v)}fractionOfProjectionToVector(v,M){const b=v.magnitudeSquared();return b<K.smallMetricDistanceSquared?M||0:this.dotProduct(v)/b}negate(v){return(v=v||new J).x=-this.x,v.y=-this.y,v}rotate90CCWXY(v){v=v||new J;const M=this.x,b=this.y;return v.x=-b,v.y=M,v}rotate90CWXY(v){v=v||new J;const M=this.x,b=this.y;return v.x=b,v.y=-M,v}unitPerpendicularXY(v){v=v||new J;const M=this.x,b=this.y;v.x=-b,v.y=M;const E=M*M+b*b;if(0!==E){const M=1/Math.sqrt(E);v.x*=M,v.y*=M}return v}rotateXY(v,M){const b=v.sin(),E=v.cos(),D=this.x,X=this.y;return(M=M||new J).x=D*E-X*b,M.y=D*b+X*E,M}interpolate(v,M,b){if(b=b||new J,v<=.5)b.x=this.x+v*(M.x-this.x),b.y=this.y+v*(M.y-this.y);else{const E=v-1;b.x=M.x+E*(M.x-this.x),b.y=M.y+E*(M.y-this.y)}return b}plus(v,M){return(M=M||new J).x=this.x+v.x,M.y=this.y+v.y,M}minus(v,M){return(M=M||new J).x=this.x-v.x,M.y=this.y-v.y,M}plusScaled(v,M,b){return(b=b||new J).x=this.x+v.x*M,b.y=this.y+v.y*M,b}plus2Scaled(v,M,b,E,D){return(D=D||new J).x=this.x+v.x*M+b.x*E,D.y=this.y+v.y*M+b.y*E,D}plus3Scaled(v,M,b,E,D,X,z){return(z=z||new J).x=this.x+v.x*M+b.x*E+D.x*X,z.y=this.y+v.y*M+b.y*E+D.y*X,z}scale(v,M){return(M=M||new J).x=this.x*v,M.y=this.y*v,M}scaleToLength(v,M){const b=K.correctSmallFraction(this.magnitude());if(0!==b)return this.scale(v/b,M)}dotProduct(v){return this.x*v.x+this.y*v.y}dotProductStartEnd(v,M){return this.x*(M.x-v.x)+this.y*(M.y-v.y)}crossProduct(v){return this.x*v.y-this.y*v.x}radiansTo(v){return Math.atan2(this.crossProduct(v),this.dotProduct(v))}angleTo(v){return W.createRadians(this.radiansTo(v))}isParallelTo(v,M=!1,b=!1,E){const D=E?.radianSquaredTol??K.smallAngleRadiansSquared,X=E?.distanceSquaredTol??K.smallMetricDistanceSquared,z=this.magnitudeSquared(),R=v.magnitudeSquared();if(z<X||R<X)return b;if(this.dotProduct(v)<0&&!M)return!1;const O=this.crossProduct(v);return O*O<=D*z*R}isPerpendicularTo(v,M=!1,b){const E=b?.radianSquaredTol??K.smallAngleRadiansSquared,D=b?.distanceSquaredTol??K.smallMetricDistanceSquared,X=this.magnitudeSquared(),z=v.magnitudeSquared();if(X<D||z<D)return M;const R=this.dotProduct(v);return R*R<=E*X*z}}!function(v){v[v.XYZ=0]="XYZ",v[v.YZX=1]="YZX",v[v.ZXY=2]="ZXY",v[v.XZY=4]="XZY",v[v.YXZ=5]="YXZ",v[v.ZYX=6]="ZYX"}(z||(z={})),function(v){v[v.X=0]="X",v[v.Y=1]="Y",v[v.Z=2]="Z"}(R||(R={})),function(v){v[v.Top=1]="Top",v[v.Bottom=2]="Bottom",v[v.Left=3]="Left",v[v.Right=4]="Right",v[v.Front=5]="Front",v[v.Back=6]="Back",v[v.Iso=7]="Iso",v[v.RightIso=8]="RightIso"}(O||(O={})),function(v){v[v.Unit=0]="Unit",v[v.LongestRangeDirection=1]="LongestRangeDirection",v[v.NonUniformRangeContainment=2]="NonUniformRangeContainment"}(Y||(Y={})),function(v){v[v.Unknown=0]="Unknown",v[v.OnPolygonVertex=1]="OnPolygonVertex",v[v.OnPolygonEdgeInterior=2]="OnPolygonEdgeInterior",v[v.InsidePolygon=3]="InsidePolygon",v[v.InsidePolygonProjectsToVertex=4]="InsidePolygonProjectsToVertex",v[v.InsidePolygonProjectsToEdgeInterior=5]="InsidePolygonProjectsToEdgeInterior",v[v.OutsidePolygon=6]="OutsidePolygon",v[v.OutsidePolygonProjectsToVertex=7]="OutsidePolygonProjectsToVertex",v[v.OutsidePolygonProjectsToEdgeInterior=8]="OutsidePolygonProjectsToEdgeInterior"}(N||(N={}));class K{static isLargeCoordinateResult(v){return v>this.largeCoordinateResult||v<-this.largeCoordinateResult}static isHugeCoordinate(v){return K.isLargeCoordinateResult(v)}static isOdd(v){return 1==(1&v)}static correctSmallMetricDistance(v,M=0){return void 0===v||Math.abs(v)<K.smallMetricDistance?M:v}static correctSmallFraction(v,M=0){return void 0===v||Math.abs(v)<K.smallFraction?M:v}static inverseMetricDistance(v){return Math.abs(v)<=K.smallMetricDistance?void 0:1/v}static inverseMetricDistanceSquared(v){return Math.abs(v)<=K.smallMetricDistanceSquared?void 0:1/v}static isSameCoordinate(v,M,b=K.smallMetricDistance){let E=v-M;return E<0&&(E=-E),E<=b}static isSameCoordinateWithToleranceFactor(v,M,b){return K.isSameCoordinate(v,M,b*K.smallMetricDistance)}static isSameCoordinateXY(v,M,b,E,D=K.smallMetricDistance){let X=b-v;return X<0&&(X=-X),!(X>D)&&(X=E-M,X<0&&(X=-X),X<=D)}static isSameCoordinateSquared(v,M,b=K.smallMetricDistance){return Math.abs(Math.sqrt(v)-Math.sqrt(M))<=b}static isSamePoint3d(v,M,b=K.smallMetricDistance){return v.distance(M)<=b}static isSameXYZ(v,M,b=K.smallMetricDistance){return v.distance(M)<=b}static isSamePoint3dXY(v,M,b=K.smallMetricDistance){return v.distanceXY(M)<=b}static isSameVector3d(v,M,b=K.smallMetricDistance){return v.distance(M)<=b}static isSamePoint2d(v,M,b=K.smallMetricDistance){return v.distance(M)<=b}static isSameVector2d(v,M,b=K.smallMetricDistance){return v.distance(M)<=b}static lexicalXYLessThan(v,M){return v.x<M.x?-1:v.x>M.x?1:v.y<M.y?-1:v.y>M.y?1:0}static lexicalYXLessThan(v,M){return v.y<M.y?-1:v.y>M.y?1:v.x<M.x?-1:v.x>M.x?1:0}static lexicalXYZLessThan(v,M){return v.x<M.x?-1:v.x>M.x?1:v.y<M.y?-1:v.y>M.y?1:v.z<M.z?-1:v.z>M.z?1:0}static isSmallRelative(v){return Math.abs(v)<K.smallFraction}static isSmallAngleRadians(v){return Math.abs(v)<K.smallAngleRadians}static isAlmostEqualOptional(v,M,b){if(void 0!==v&&void 0!==M){if(Math.abs(v-M)>b)return!1}else if(void 0!==v||void 0!==M)return!1;return!0}static isAlmostEqualNumber(v,M,b=K.smallAngleRadians){const E=1+Math.abs(v)+Math.abs(M);return Math.abs(v-M)<=b*E}static isAlmostEqualXAndY(v,M,b=K.smallAngleRadians){const E=b*(1+Math.abs(v.x)+Math.abs(M.x)+Math.abs(v.y)+Math.abs(M.y));return Math.abs(v.x-M.x)<=E&&Math.abs(v.y-M.y)<=E}static isDistanceWithinTol(v,M=K.smallMetricDistance){return Math.abs(v)<=M}static isSmallMetricDistance(v){return Math.abs(v)<=K.smallMetricDistance}static isSmallMetricDistanceSquared(v){return Math.abs(v)<=K.smallMetricDistanceSquared}static cyclic3dAxis(v){if(v>=0)return v<3?v:v<6?v-3:v%3;const M=v+3;return M>=0?M:2-(-v-1)%3}static axisIndexToRightHandedAxisOrder(v){return 0===v?z.XYZ:1===v?z.YZX:2===v?z.ZXY:K.axisIndexToRightHandedAxisOrder(K.cyclic3dAxis(v))}static maxXYZ(v,M,b){let E=v;return M>E&&(E=M),b>E&&(E=b),E}static minXYZ(v,M,b){let E=v;return M<E&&(E=M),b<E&&(E=b),E}static maxXY(v,M){let b=v;return M>b&&(b=M),b}static minXY(v,M){let b=v;return M<b&&(b=M),b}static maxAbsXYZ(v,M,b){return K.maxXYZ(Math.abs(v),Math.abs(M),Math.abs(b))}static maxAbsXY(v,M){return K.maxXY(Math.abs(v),Math.abs(M))}static maxAbsDiff(v,M,b){return Math.max(Math.abs(v-M),Math.abs(v-b))}static split3WaySign(v,M,b,E){return v<0?M:v>0?E:b}static split3Way01(v,M=K.smallMetricDistance){return v>M?1:v<-M?-1:0}static square(v){return v*v}static hypotenuseXY(v,M){return Math.sqrt(v*v+M*M)}static hypotenuseSquaredXY(v,M){return v*v+M*M}static hypotenuseXYZ(v,M,b){return Math.sqrt(v*v+M*M+b*b)}static hypotenuseSquaredXYZ(v,M,b){return v*v+M*M+b*b}static hypotenuseXYZW(v,M,b,E){return Math.sqrt(v*v+M*M+b*b+E*E)}static hypotenuseSquaredXYZW(v,M,b,E){return v*v+M*M+b*b+E*E}static distanceXYXY(v,M,b,E){return K.hypotenuseXY(b-v,E-M)}static distanceXYZXYZ(v,M,b,E,D,X){return K.hypotenuseXYZ(E-v,D-M,X-b)}static tripleProduct(v,M,b,E,D,X,z,R,O){return v*(D*O-X*R)+M*(X*z-E*O)+b*(E*R-D*z)}static determinant4x4(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U,Sr){return v*this.tripleProduct(X,z,R,Y,N,B,L,U,Sr)-D*this.tripleProduct(M,b,E,Y,N,B,L,U,Sr)+O*this.tripleProduct(M,b,E,X,z,R,L,U,Sr)-V*this.tripleProduct(M,b,E,X,z,R,Y,N,B)}static tripleProductXYW(v,M,b,E,D,X){return K.tripleProduct(v.x,b.x,D.x,v.y,b.y,D.y,M,E,X)}static tripleProductPoint4dXYW(v,M,b){return K.tripleProduct(v.x,M.x,b.x,v.y,M.y,b.y,v.w,M.w,b.w)}static crossProductXYXY(v,M,b,E){return v*E-M*b}static crossProductXYZXYZ(v,M,b,E,D,X,z){return $.create(M*X-b*D,b*E-v*X,v*D-M*E,z)}static crossProductMagnitude(v,M,b,E,D,X){return K.hypotenuseXYZ(M*X-b*D,b*E-v*X,v*D-M*E)}static dotProductXYXY(v,M,b,E){return v*b+M*E}static dotProductXYZXYZ(v,M,b,E,D,X){return v*E+M*D+b*X}static meanCurvatureOfRadii(v,M){return.5*(this.safeDivideFraction(1,v,0)+this.safeDivideFraction(1,M,0))}static curvatureMagnitude(v,M,b,E,D,X){let z=M*X-b*D,R=z*z;z=b*E-v*X,R+=z*z,z=v*D-M*E,R+=z*z;const O=Math.sqrt(R),Y=Math.sqrt(v*v+M*M+b*b),N=Y*Y*Y;return N>K.smallAngleRadians*O?O/N:0}static clampToStartEnd(v,M,b){return M>b?K.clampToStartEnd(v,b,M):v<M?M:b<v?b:v}static clamp(v,M,b){return Math.max(M,Math.min(b,v))}static resolveNumber(v,M=0){return void 0!==v?v:M}static resolveValue(v,M){return void 0!==v?v:M}static resolveToUndefined(v,M){return v===M?void 0:v}static interpolate(v,M,b){return M<=.5?v+M*(b-v):b-(1-M)*(b-v)}static axisOrderToAxis(v,M){const b=v<=z.ZXY?v+M:v-z.XZY-M;return K.cyclic3dAxis(b)}static modulo(v,M){if(M<=0)return 0===M?v:-K.modulo(-v,-M);if(v>=0){if(v<M)return v;if(v<2*M)return v-M}else if((v+=M)>0)return v;return v-Math.floor(v/M)*M}static defined01(v){return void 0===v?0:1}static conditionalDivideFraction(v,M){if(Math.abs(M)*K.largeFractionResult>Math.abs(v))return v/M}static safeDivideFraction(v,M,b){const E=K.conditionalDivideFraction(v,M);return void 0!==E?E:b}static conditionalDivideCoordinate(v,M,b=K.largeCoordinateResult){if(Math.abs(M*b)>Math.abs(v))return v/M}static solveTrigForm(v,M,b){const E=M*M+b*b;let D;if(E>0){const X=1/E,z=1-v*v*X;if(z<-K.smallMetricDistanceSquared)return D;const R=-v*X,O=R*M,Y=R*b;if(z<=K.smallMetricDistanceSquared)D=[J.create(O,Y)];else{const v=Math.sqrt(z*X);D=[J.create(O-v*b,Y+v*M),J.create(O+v*b,Y-v*M)]}}return D}static inverseInterpolate(v,M,b,E,D=0,X){const z=K.conditionalDivideFraction(D-M,E-M);return void 0!==z?K.interpolate(v,z,b):X}static inverseInterpolate01(v,M,b=0){return K.conditionalDivideFraction(b-v,M-v)}static isNumberArray(v,M=0){if(Array.isArray(v)&&v.length>=M){let M;for(M of v)if(!Number.isFinite(M))return!1;return!0}return!1}static isArrayOfNumberArray(v,M,b=0){if(Array.isArray(v)&&v.length>=M){let M;for(M of v)if(!K.isNumberArray(M,b))return!1;return!0}return!1}static stepCount(v,M,b=1,E=101){if(v<=0)return b;if(v>=(M=Math.abs(M)))return b;const D=Math.floor((M+.999999*v)/v);return D<b?b:D>E?E:D}static isIn01(v,M=!0){return!M||v>=0&&v<=1}static isIn01WithTolerance(v,M){return v+M>=0&&v-M<=1}static restrictToInterval(v,M,b){return M<=b?v<M?M:v>b?b:v:v<b?b:v>M?M:v}static equalStringNoCase(v,M){return v.toUpperCase()===M.toUpperCase()}static exactEqualNumberArrays(v,M){if(Array.isArray(v)&&0===v.length&&(v=void 0),Array.isArray(M)&&0===M.length&&(M=void 0),void 0===v&&void 0===M)return!0;if(Array.isArray(v)&&Array.isArray(M)){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(v[b]!==M[b])return!1;return!0}return!1}static almostEqualArrays(v,M,b){if(Array.isArray(v)&&0===v.length&&(v=void 0),Array.isArray(M)&&0===M.length&&(M=void 0),void 0===v&&void 0===M)return!0;if(Array.isArray(v)&&Array.isArray(M)){if(v.length!==M.length)return!1;for(let E=0;E<v.length;E++)if(!b(v[E],M[E]))return!1;return!0}return!1}static almostEqualNumberArrays(v,M,b){if(Array.isArray(v)&&0===v.length&&(v=void 0),Array.isArray(M)&&0===M.length&&(M=void 0),void 0===v&&void 0===M)return!0;if(Array.isArray(v)&&Array.isArray(M)){if(v.length!==M.length)return!1;for(let E=0;E<v.length;E++)if(!b(v[E],M[E]))return!1;return!0}return!1}static areEqualAllowUndefined(v,M,b=!0){return void 0===v&&void 0===M?b:void 0!==v&&void 0!==M&&v===M}static cloneMembers(v){if(void 0===v)return;const M=[];for(const b of v)M.push(b.clone());return M}}K.smallMetricDistance=1e-6,K.smallMetricDistanceSquared=1e-12,K.smallAngleRadians=1e-12,K.smallAngleRadiansSquared=1e-24,K.smallAngleDegrees=57e-12,K.smallAngleSeconds=2e-7,K.smallFraction=1e-10,K.smallFloatingPoint=1e-15,K.fullCircleRadiansMinusSmallAngle=2*Math.PI-K.smallAngleRadians,K.largeFractionResult=1e10,K.largeCoordinateResult=1e13,K.hugeCoordinate=1e12,function(v){v.almostEqual=function(v,M,b){return K.isSameCoordinate(v.x,M.x,b)&&K.isSameCoordinate(v.y,M.y,b)&&K.isSameCoordinate(v.z,M.z,b)}}(B||(B={}));class j{set(v=0,M=0,b=0){this.x=v,this.y=M,this.z=b}setZero(){this.x=0,this.y=0,this.z=0}constructor(v=0,M=0,b=0){this.x=v,this.y=M,this.z=b}static isXAndY(v){return void 0!==v.x&&void 0!==v.y}static hasZ(v){return void 0!==v.z}static isXYAndZ(v){return this.isXAndY(v)&&this.hasZ(v)}static isAnyImmediatePointType(v){return Q.isXAndY(v)||K.isNumberArray(v,2)}static accessX(v,M){return void 0!==v.x?v.x:Array.isArray(v)&&v.length>0&&Number.isFinite(v[0])?v[0]:M}static accessY(v,M){return void 0!==v.y?v.y:Array.isArray(v)&&v.length>1&&Number.isFinite(v[1])?v[1]:M}static accessZ(v,M){return void 0!==v.z?v.z:Array.isArray(v)&&v.length>2&&Number.isFinite(v[2])?v[2]:M}setFrom(v){void 0===v?this.setZero():j.isXAndY(v)?(this.x=v.x,this.y=v.y,this.z=j.hasZ(v)?v.z:0):(this.x=v[0],this.y=v[1],this.z=v[2])}setFromPoint3d(v){v?(this.x=v.x,this.y=v.y,this.z=v.z):this.setZero()}setFromVector3d(v){v?(this.x=v.x,this.y=v.y,this.z=v.z):this.setZero()}isAlmostEqual(v,M){return B.almostEqual(this,v,M)}isAlmostEqualXYZ(v,M,b,E){return K.isSameCoordinate(this.x,v,E)&&K.isSameCoordinate(this.y,M,E)&&K.isSameCoordinate(this.z,b,E)}isAlmostEqualPointPlusScaledVector(v,M,b,E){return K.isSameCoordinate(this.x,v.x+M.x*b,E)&&K.isSameCoordinate(this.y,v.y+M.y*b,E)&&K.isSameCoordinate(this.z,v.z+M.z*b,E)}isAlmostEqualXY(v,M){return K.isSameCoordinate(this.x,v.x,M)&&K.isSameCoordinate(this.y,v.y,M)}toJSON(){return this.toArray()}toArray(){return[this.x,this.y,this.z]}toJSONXYZ(){return{x:this.x,y:this.y,z:this.z}}toFloat64Array(){return Float64Array.of(this.x,this.y,this.z)}setFromJSON(v){Array.isArray(v)?this.set(v[0]||0,v[1]||0,v[2]||0):v?this.set(v.x||0,v.y||0,v.z||0):this.set(0,0,0)}distance(v){const M=v.x-this.x,b=v.y-this.y,E=v.z-this.z;return Math.sqrt(M*M+b*b+E*E)}distanceSquared(v){const M=v.x-this.x,b=v.y-this.y,E=v.z-this.z;return M*M+b*b+E*E}distanceXY(v){const M=v.x-this.x,b=v.y-this.y;return Math.sqrt(M*M+b*b)}distanceSquaredXY(v){const M=v.x-this.x,b=v.y-this.y;return M*M+b*b}maxDiff(v){return Math.max(Math.abs(this.x-v.x),Math.abs(this.y-v.y),Math.abs(this.z-v.z))}at(v){return v<.5?this.x:v>1.5?this.z:this.y}setAt(v,M){v<.5?this.x=M:v>1.5?this.z=M:this.y=M}indexOfMaxAbs(){let v=0,M=Math.abs(this.x),b=Math.abs(this.y);return b>M&&(v=1,M=b),b=Math.abs(this.z),b>M&&(v=2),v}get isAlmostZero(){return K.isSmallMetricDistance(this.x)&&K.isSmallMetricDistance(this.y)&&K.isSmallMetricDistance(this.z)}get isZero(){return 0===this.x&&0===this.y&&0===this.z}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitudeSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}magnitudeXY(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquaredXY(){return this.x*this.x+this.y*this.y}isExactEqual(v){return this.x===v.x&&this.y===v.y&&this.z===v.z}isAlmostEqualMetric(v){return this.maxDiff(v)<=K.smallMetricDistance}addInPlace(v){this.x+=v.x,this.y+=v.y,this.z+=v.z}subtractInPlace(v){this.x-=v.x,this.y-=v.y,this.z-=v.z}addScaledInPlace(v,M){this.x+=M*v.x,this.y+=M*v.y,this.z+=M*v.z}scaleInPlace(v){this.x*=v,this.y*=v,this.z*=v}addXYZInPlace(v=0,M=0,b=0){this.x+=v,this.y+=M,this.z+=b}cloneAsPoint3d(){return Q.create(this.x,this.y,this.z)}vectorTo(v,M){return $.create(v.x-this.x,v.y-this.y,v.z-this.z,M)}scaledVectorTo(v,M,b){return $.create(M*(v.x-this.x),M*(v.y-this.y),M*(v.z-this.z),b)}unitVectorTo(v,M){return this.vectorTo(v,M).normalize(M)}freeze(){return Object.freeze(this)}static x(v,M=0){return void 0===v?M:Array.isArray(v)?v[0]:void 0!==v.x?v.x:M}static y(v,M=0){return void 0===v?M:Array.isArray(v)?v[1]:void 0!==v.y?v.y:M}static z(v,M=0){return void 0===v?M:Array.isArray(v)?v[2]:void 0!==v.z?v.z:M}}class Q extends j{constructor(v=0,M=0,b=0){super(v,M,b)}static fromJSON(v){const M=new Q;return M.setFromJSON(v),M}clone(v){return Q.create(this.x,this.y,this.z,v)}static create(v=0,M=0,b=0,E){return E?(E.x=v,E.y=M,E.z=b,E):new Q(v,M,b)}static createFrom(v,M){if(v instanceof Float64Array){let b=0,E=0,D=0;return v.length>0&&(b=v[0]),v.length>1&&(E=v[1]),v.length>2&&(D=v[2]),Q.create(b,E,D,M)}return Q.create(v.x,v.y,j.hasZ(v)?v.z:0,M)}static createFromPacked(v,M,b){const E=3*M;if(E>=0&&E+2<v.length)return Q.create(v[E],v[E+1],v[E+2],b)}static createFromPackedXYZW(v,M,b){const E=4*M;if(E>=0&&E+3<v.length){const M=v[E+3];if(!K.isSmallMetricDistance(M)){const D=1/M;return Q.create(D*v[E],D*v[E+1],D*v[E+2],b)}}}static createArrayFromPackedXYZ(v){const M=[];for(let b=0;b+2<v.length;b+=3)M.push(new Q(v[b],v[b+1],v[b+2]));return M}static createZero(v){return Q.create(0,0,0,v)}crossProductToPoints(v,M,b){return $.createCrossProduct(v.x-this.x,v.y-this.y,v.z-this.z,M.x-this.x,M.y-this.y,M.z-this.z,b)}crossProductToPointsMagnitude(v,M){return K.crossProductMagnitude(v.x-this.x,v.y-this.y,v.z-this.z,M.x-this.x,M.y-this.y,M.z-this.z)}tripleProductToPoints(v,M,b){return K.tripleProduct(v.x-this.x,v.y-this.y,v.z-this.z,M.x-this.x,M.y-this.y,M.z-this.z,b.x-this.x,b.y-this.y,b.z-this.z)}crossProductToPointsXY(v,M){return K.crossProductXYXY(v.x-this.x,v.y-this.y,M.x-this.x,M.y-this.y)}interpolate(v,M,b){if(v<=.5)return Q.create(this.x+v*(M.x-this.x),this.y+v*(M.y-this.y),this.z+v*(M.z-this.z),b);const E=v-1;return Q.create(M.x+E*(M.x-this.x),M.y+E*(M.y-this.y),M.z+E*(M.z-this.z),b)}interpolateXYZ(v,M,b,E,D){return Q.create(K.interpolate(this.x,v,E.x),K.interpolate(this.y,M,E.y),K.interpolate(this.z,b,E.z),D)}interpolatePerpendicularXY(v,M,b,E){E=E||new Q;const D=M.minus(this);return this.interpolate(v,M,E),E.x-=b*D.y,E.y+=b*D.x,E}minus(v,M){return Q.create(this.x-v.x,this.y-v.y,this.z-v.z,M)}plus(v,M){return Q.create(this.x+v.x,this.y+v.y,this.z+v.z,M)}plusXYZ(v=0,M=0,b=0,E){return Q.create(this.x+v,this.y+M,this.z+b,E)}plusScaled(v,M,b){return Q.create(this.x+v.x*M,this.y+v.y*M,this.z+v.z*M,b)}plus2Scaled(v,M,b,E,D){return Q.create(this.x+v.x*M+b.x*E,this.y+v.y*M+b.y*E,this.z+v.z*M+b.z*E,D)}plus3Scaled(v,M,b,E,D,X,z){return Q.create(this.x+v.x*M+b.x*E+D.x*X,this.y+v.y*M+b.y*E+D.y*X,this.z+v.z*M+b.z*E+D.z*X,z)}static createScale(v,M,b){return Q.create(v.x*M,v.y*M,v.z*M,b)}static createAdd2Scaled(v,M,b,E,D){return Q.create(v.x*M+b.x*E,v.y*M+b.y*E,v.z*M+b.z*E,D)}static createAdd3Scaled(v,M,b,E,D,X,z){return Q.create(v.x*M+b.x*E+D.x*X,v.y*M+b.y*E+D.y*X,v.z*M+b.z*E+D.z*X,z)}dotVectorsToTargets(v,M){return(v.x-this.x)*(M.x-this.x)+(v.y-this.y)*(M.y-this.y)+(v.z-this.z)*(M.z-this.z)}fractionOfProjectionToLine(v,M,b=0){const E=v.distanceSquared(M);return E<K.smallMetricDistanceSquared?b:v.dotVectorsToTargets(M,this)/E}}class $ extends j{constructor(v=0,M=0,b=0){super(v,M,b)}static createArrayFromPackedXYZ(v){const M=[];for(let b=0;b+2<v.length;b+=3)M.push(new $(v[b],v[b+1],v[b+2]));return M}clone(v){return $.create(this.x,this.y,this.z,v)}static create(v=0,M=0,b=0,E){return E?(E.x=v,E.y=M,E.z=b,E):new $(v,M,b)}static createCrossProduct(v,M,b,E,D,X,z){return $.create(M*X-b*D,b*E-v*X,v*D-M*E,z)}addCrossProductToTargetsInPlace(v,M,b,E,D,X,z,R,O){const Y=E-v,N=D-M,B=X-b,V=z-v,L=R-M,U=O-b;this.x+=N*U-B*L,this.y+=B*V-Y*U,this.z+=Y*L-N*V}static createCrossProductToPoints(v,M,b,E){return $.createCrossProduct(M.x-v.x,M.y-v.y,M.z-v.z,b.x-v.x,b.y-v.y,b.z-v.z,E)}static createUnitCrossProductToPoints(v,M,b,E){return $.createCrossProduct(M.x-v.x,M.y-v.y,M.z-v.z,b.x-v.x,b.y-v.y,b.z-v.z,E).normalize()}static createPolar(v,M,b){return $.create(v*M.cos(),v*M.sin(),b)}static createSpherical(v,M,b){const E=b.cos();return $.create(E*v*M.cos(),E*v*M.sin(),v*b.sin())}static fromJSON(v){const M=new $;return M.setFromJSON(v),M}static createFrom(v,M){if(v instanceof Float64Array){let b=0,E=0,D=0;return v.length>0&&(b=v[0]),v.length>1&&(E=v[1]),v.length>2&&(D=v[2]),$.create(b,E,D,M)}return Array.isArray(v)?$.create(v[0],v[1],v.length>2?v[2]:0):$.create(v.x,v.y,j.hasZ(v)?v.z:0,M)}static createStartEnd(v,M,b){const E=j.accessZ(v,0),D=j.accessZ(M,0)-E;return b?(b.set(M.x-v.x,M.y-v.y,D),b):new $(M.x-v.x,M.y-v.y,D)}static createStartEndXYZXYZ(v,M,b,E,D,X,z){return this.create(E-v,D-M,X-b,z)}static createRotateVectorAroundVector(v,M,b){const E=M.normalize();if(E){const M=E.crossProduct(v);let D,X;return b?(D=b.cos(),X=b.sin()):(D=0,X=1),$.createAdd3Scaled(v,D,M,X,E,E.dotProduct(v)*(1-D))}}setStartEnd(v,M){this.x=M.x-v.x,this.y=M.y-v.y,this.z=M.z-v.z}static createZero(v){return $.create(0,0,0,v)}static unitX(v=1){return new $(v,0,0)}static unitY(v=1){return new $(0,v,0)}static unitZ(v=1){return new $(0,0,v)}safeDivideOrNull(v,M){if(0!==v)return this.scale(1/v,M)}normalizeWithLength(v){const M=this.magnitude(),b=K.correctSmallFraction(M);return v=v||new $,{v:this.safeDivideOrNull(b,v),mag:M}}normalize(v){return this.normalizeWithLength(v).v}normalizeInPlace(){return void 0!==this.normalizeWithLength(this).v}static createNormalized(v=0,M=0,b=0,E){if(void 0===E?E=$.create(v,M,b):E.set(v,M,b),E.normalizeInPlace())return E}static createNormalizedStartEnd(v,M,b){if((b=$.createStartEnd(v,M,b)).normalizeInPlace())return b}fractionOfProjectionToVector(v,M=0){const b=v.magnitudeSquared();return b<K.smallMetricDistanceSquared?M:this.dotProduct(v)/b}negate(v){return(v=v||new $).x=-this.x,v.y=-this.y,v.z=-this.z,v}rotate90CCWXY(v){v=v||new $;const M=this.x,b=this.y;return v.x=-b,v.y=M,v.z=this.z,v}rotate90CWXY(v){v=v||new $;const M=this.x,b=this.y;return v.x=b,v.y=-M,v.z=this.z,v}unitPerpendicularXY(v){v=v||new $;const M=this.x,b=this.y;v.x=-b,v.y=M,v.z=0;const E=M*M+b*b;if(0!==E){const M=1/Math.sqrt(E);v.x*=M,v.y*=M}return v}rotateXY(v,M){const b=v.sin(),E=v.cos(),D=this.x,X=this.y;return(M=M||new $).x=D*E-X*b,M.y=D*b+X*E,M.z=this.z,M}rotate90Towards(v,M){const b=this.crossProduct(v).normalize();return b?b.crossProduct(this,M):void 0}rotate90Around(v,M){const b=v.normalize();return b?b.crossProduct(this).plusScaled(b,b.dotProduct(this),M):void 0}interpolate(v,M,b){if(b=b||new $,v<=.5)b.x=this.x+v*(M.x-this.x),b.y=this.y+v*(M.y-this.y),b.z=this.z+v*(M.z-this.z);else{const E=v-1;b.x=M.x+E*(M.x-this.x),b.y=M.y+E*(M.y-this.y),b.z=M.z+E*(M.z-this.z)}return b}plus(v,M){return(M=M||new $).x=this.x+v.x,M.y=this.y+v.y,M.z=this.z+v.z,M}minus(v,M){return(M=M||new $).x=this.x-v.x,M.y=this.y-v.y,M.z=this.z-v.z,M}plusScaled(v,M,b){return(b=b||new $).x=this.x+v.x*M,b.y=this.y+v.y*M,b.z=this.z+v.z*M,b}plus2Scaled(v,M,b,E,D){return(D=D||new $).x=this.x+v.x*M+b.x*E,D.y=this.y+v.y*M+b.y*E,D.z=this.z+v.z*M+b.z*E,D}plus3Scaled(v,M,b,E,D,X,z){return(z=z||new $).x=this.x+v.x*M+b.x*E+D.x*X,z.y=this.y+v.y*M+b.y*E+D.y*X,z.z=this.z+v.z*M+b.z*E+D.z*X,z}static createAdd2Scaled(v,M,b,E,D){return $.create(v.x*M+b.x*E,v.y*M+b.y*E,v.z*M+b.z*E,D)}static createAdd2ScaledXYZ(v,M,b,E,D,X,z,R,O){return $.create(v*E+D*R,M*E+X*R,b*E+z*R,O)}static createAdd3Scaled(v,M,b,E,D,X,z){return $.create(v.x*M+b.x*E+D.x*X,v.y*M+b.y*E+D.y*X,v.z*M+b.z*E+D.z*X,z)}scale(v,M){return(M=M||new $).x=this.x*v,M.y=this.y*v,M.z=this.z*v,M}scaleToLength(v,M){const b=K.correctSmallFraction(this.magnitude());if(0!==b)return this.scale(v/b,M)}unitCrossProduct(v,M){return this.crossProduct(v,M).normalize(M)}unitCrossProductWithDefault(v,M,b,E,D){const X=this.crossProduct(v,D).normalize(D);return void 0===X?$.create(M,b,E,D):X}normalizeWithDefault(v,M,b,E){return this.normalize(E)||((E=$.create(v,M,b,E)).normalizeInPlace()?E:$.create(1,0,0,E))}tryNormalizeInPlace(v=K.smallFraction){const M=this.magnitude();return!(M<v||0===M||(this.scaleInPlace(1/M),0))}sizedCrossProduct(v,M,b){if((b=this.crossProduct(v,b)).tryNormalizeInPlace())return b.scaleInPlace(M),b}crossProductMagnitudeSquared(v){const M=this.y*v.z-this.z*v.y,b=this.z*v.x-this.x*v.z,E=this.x*v.y-this.y*v.x;return M*M+b*b+E*E}crossProductMagnitude(v){return Math.sqrt(this.crossProductMagnitudeSquared(v))}dotProduct(v){return this.x*v.x+this.y*v.y+this.z*v.z}static dotProductAsXYAndZ(v,M){return v.x*M.x+v.y*M.y+v.z*M.z}dotProductStartEnd(v,M){return this.x*(M.x-v.x)+this.y*(M.y-v.y)+this.z*(M.z-v.z)}dotProductStart3dEnd4d(v,M){const b=M.w;return this.x*(M.x-v.x*b)+this.y*(M.y-v.y*b)+this.z*(M.z-v.z*b)}crossProductStartEnd(v,M,b){return $.createCrossProduct(this.x,this.y,this.z,M.x-v.x,M.y-v.y,M.z-v.z,b)}crossProductStartEndXY(v,M){return K.crossProductXYXY(this.x,this.y,M.x-v.x,M.y-v.y)}dotProductStartEndXYZ(v,M,b,E){return this.x*(M-v.x)+this.y*(b-v.y)+this.z*(E-v.z)}dotProductStartEndXY(v,M){return this.x*(M.x-v.x)+this.y*(M.y-v.y)}dotProductStartEndXYZW(v,M,b,E,D){if(K.isSmallMetricDistance(D))return 0;const X=1/D;return this.x*(X*M-v.x)+this.y*(X*b-v.y)+this.z*(X*E-v.z)}dotProductXY(v){return this.x*v.x+this.y*v.y}dotProductXYZ(v,M,b=0){return this.x*v+this.y*M+this.z*b}tripleProduct(v,M){return K.tripleProduct(this.x,this.y,this.z,v.x,v.y,v.z,M.x,M.y,M.z)}crossProductXY(v){return this.x*v.y-this.y*v.x}crossProduct(v,M){return $.createCrossProduct(this.x,this.y,this.z,v.x,v.y,v.z,M)}crossProductXYZ(v,M,b,E){return $.createCrossProduct(this.x,this.y,this.z,v,M,b,E)}radiansTo(v){return Math.atan2(this.crossProductMagnitude(v),this.dotProduct(v))}angleTo(v){return W.createRadians(this.radiansTo(v))}angleFromPerpendicular(v){return W.createAtan2(this.dotProduct(v),this.crossProductMagnitude(v))}radiansFromPerpendicular(v){return Math.atan2(this.dotProduct(v),this.crossProductMagnitude(v))}angleToXY(v){return W.createAtan2(this.crossProductXY(v),this.dotProductXY(v))}signedRadiansTo(v,M){const b=this.crossProduct(v),E=Math.atan2(b.magnitude(),this.dotProduct(v));return M.dotProduct(b)<0?-E:E}signedAngleTo(v,M){return W.createRadians(this.signedRadiansTo(v,M))}planarRadiansTo(v,M){const b=M.dotProduct(M);if(0===b)return 0;const E=1/b,D=this.plusScaled(M,-this.dotProduct(M)*E),X=v.plusScaled(M,-v.dotProduct(M)*E);return D.signedRadiansTo(X,M)}planarAngleTo(v,M){return W.createRadians(this.planarRadiansTo(v,M))}smallerUnorientedRadiansTo(v){const M=this.dotProduct(v),b=this.crossProductMagnitude(v);return Math.atan2(Math.abs(b),Math.abs(M))}smallerUnorientedAngleTo(v){return W.createRadians(this.smallerUnorientedRadiansTo(v))}isParallelTo(v,M=!1,b=!1,E){const D=E?.radianSquaredTol??K.smallAngleRadiansSquared,X=E?.distanceSquaredTol??K.smallMetricDistanceSquared,z=this.magnitudeSquared(),R=v.magnitudeSquared();return z<X||R<X?b:!(this.dotProduct(v)<0&&!M)&&this.crossProductMagnitudeSquared(v)<=D*z*R}isPerpendicularTo(v,M=!1,b){const E=b?.radianSquaredTol??K.smallAngleRadiansSquared,D=b?.distanceSquaredTol??K.smallMetricDistanceSquared,X=this.magnitudeSquared(),z=v.magnitudeSquared();if(X<D||z<D)return M;const R=this.dotProduct(v);return R*R<=E*X*z}}class tt{isPointInPlane(v,M=K.smallMetricDistance){return Math.abs(this.altitude(v))<=M}classifyAltitude(v,M=K.smallMetricDistance){return K.split3Way01(this.altitude(v),M)}classifyAltitudeXYZ(v,M,b,E=K.smallMetricDistance){return K.split3Way01(this.altitudeXYZ(v,M,b),E)}getUnitNormal(v){return $.createNormalized(this.normalX(),this.normalY(),this.normalZ(),v)}getAnyPointOnPlane(v){return this.projectPointToPlane(Q.create(0,0,0),v)}}class et{constructor(v){this._curIndex=-1,this._collection=v}next(){return++this._curIndex>=this._collection.length?{done:!0}:{value:this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),done:!1}}[Symbol.iterator](){return this}}class it{vectorIndexXYAndZ(v,M,b){const E=this.vectorXYAndZIndex(M,v,b);return E?.negate(E)}dotProductIndexIndexIndex(v,M,b){if(v<0||v>=this.length||M<0||M>=this.length||b<0||b>=this.length)return;const E=this.getXAtUncheckedPointIndex(v),D=this.getYAtUncheckedPointIndex(v),X=this.getZAtUncheckedPointIndex(v);return(this.getXAtUncheckedPointIndex(M)-E)*(this.getXAtUncheckedPointIndex(b)-E)+(this.getYAtUncheckedPointIndex(M)-D)*(this.getYAtUncheckedPointIndex(b)-D)+(this.getZAtUncheckedPointIndex(M)-X)*(this.getZAtUncheckedPointIndex(b)-X)}dotProductIndexIndexXYAndZ(v,M,b){if(v<0||v>=this.length||M<0||M>=this.length)return;const E=this.getXAtUncheckedPointIndex(v),D=this.getYAtUncheckedPointIndex(v),X=this.getZAtUncheckedPointIndex(v);return(this.getXAtUncheckedPointIndex(M)-E)*(b.x-E)+(this.getYAtUncheckedPointIndex(M)-D)*(b.y-D)+(this.getZAtUncheckedPointIndex(M)-X)*(b.z-X)}crossProductIndexIndexXYAndZ(v,M,b,E){if(v<0||v>=this.length||M<0||M>=this.length)return;const D=this.getXAtUncheckedPointIndex(v),X=this.getYAtUncheckedPointIndex(v),z=this.getZAtUncheckedPointIndex(v);return $.createCrossProduct(this.getXAtUncheckedPointIndex(M)-D,this.getYAtUncheckedPointIndex(M)-X,this.getZAtUncheckedPointIndex(M)-z,b.x-D,b.y-X,b.z-z,E)}distanceSquaredIndexXYAndZ(v,M){if(!(v<0||v>=this.length))return K.hypotenuseSquaredXYZ(M.x-this.getXAtUncheckedPointIndex(v),M.y-this.getYAtUncheckedPointIndex(v),M.z-this.getZAtUncheckedPointIndex(v))}cyclicIndex(v){return v%this.length}getRange(){const v=ut.createNull(),M=this.length,b=Q.create();for(let E=0;E<M;E++)this.getPoint3dAtUncheckedPointIndex(E,b),v.extendPoint(b);return v}findOrderedDuplicates(v=K.smallMetricDistance){const M=v*v,b=[];if(this.length>1)for(let E=0;E<this.length-1;){let v=E+1;for(;v<this.length;++v){const D=this.distanceSquaredIndexIndex(E,v);if(!(void 0!==D&&D<M))break;b.push(v)}E=v}return b}linearCombination(v,M){const b=Math.min(this.length,v.length),E=M instanceof $?$.createZero(M):Q.createZero(M);for(let D=0;D<b;++D)E.x+=v[D]*this.getXAtUncheckedPointIndex(D),E.y+=v[D]*this.getYAtUncheckedPointIndex(D),E.z+=v[D]*this.getZAtUncheckedPointIndex(D);return E}interpolateIndexIndex(v,M,b,E){if(!(v<0||v>=this.length||b<0||b>=this.length))return Q.create(K.interpolate(this.getXAtUncheckedPointIndex(v),M,this.getXAtUncheckedPointIndex(b)),K.interpolate(this.getYAtUncheckedPointIndex(v),M,this.getYAtUncheckedPointIndex(b)),K.interpolate(this.getZAtUncheckedPointIndex(v),M,this.getZAtUncheckedPointIndex(b)),E)}get points(){return new et(this)}getArray(){const v=[];for(const M of this.points)v.push(M);return v}front(v){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(0,v)}back(v){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(this.length-1,v)}}class st extends it{}class nt extends st{constructor(v=8,M){super(),this._data=new Float64Array(3*v),this._xyzInUse=0,this._xyzCapacity=v,this._growthFactor=void 0!==M&&M>=1?M:1.5}copyData(v,M,b){let E=void 0!==b?3*b:0;if(E<0&&(E=0),E>=this._data.length)return{count:0,offset:0};let D=void 0!==M?3*M:v.length;return D>0&&(D>v.length&&(D=v.length),E+D>this._data.length&&(D=this._data.length-E),D%3!=0&&(D-=D%3)),D<=0?{count:0,offset:0}:(D===v.length?this._data.set(v,E):v instanceof Float64Array?this._data.set(v.subarray(0,D),E):this._data.set(v.slice(0,D),E),{count:D/3,offset:E/3})}get length(){return this._xyzInUse}set length(v){this.resize(v,!0)}get float64Length(){return 3*this._xyzInUse}float64Data(){return this._data}ensureCapacity(v,M=!0){if(v>this._xyzCapacity){M&&(v*=this._growthFactor);const b=this._data;this._data=new Float64Array(3*v),this.copyData(b,this._xyzInUse),this._xyzCapacity=v}}resize(v,M){v>=0&&v<this._xyzInUse?this._xyzInUse=v:v>this._xyzInUse&&(this.ensureCapacity(v,!1),M&&this._data.fill(0,3*this._xyzInUse),this._xyzInUse=v)}clone(v){return v?(v.length!==this.length&&v.clear(),v.resize(this.length)):v=new nt(this.length),v.copyData(this._data,this.length),v._xyzInUse=this.length,v}static create(v,M){if(M)M.clear();else{const b="number"==typeof v[0]?v.length/3:v.length;M=new nt(b)}return M.pushFrom(v),M}static createArrayOfGrowableXYZArray(v){const M=new at;return lt.streamXYZ(v,M),M.claimArrayOfGrowableXYZArray()}push(v){this.pushXYZ(v.x,v.y,v.z)}pushAll(v){this.ensureCapacity(this._xyzInUse+v.length,!1);for(const M of v)this.push(M)}pushFrom(v){if(v instanceof Q)this.pushXYZ(v.x,v.y,v.z);else if(v instanceof nt)this.pushFromGrowableXYZArray(v);else if(v instanceof H)this.pushXYZ(v.x,v.y,0);else if(K.isNumberArray(v,4)||v instanceof Float64Array){const M=Math.trunc(v.length/3);this.ensureCapacity(this._xyzInUse+M,!1),this.copyData(v,M,this._xyzInUse),this._xyzInUse+=M}else if(K.isNumberArray(v,3))this.pushXYZ(v[0],v[1],v[2]);else if(K.isNumberArray(v,2))this.pushXYZ(v[0],v[1],0);else if(Array.isArray(v))for(const M of v)this.pushFrom(M);else if(Q.isXYAndZ(v))this.pushXYZ(v.x,v.y,v.z);else if(Q.isXAndY(v))this.pushXYZ(v.x,v.y,0);else if(v instanceof it){const M=v.length;this.ensureCapacity(this._xyzInUse+M,!1);for(let b=0;b<M;b++)this.pushXYZ(v.getXAtUncheckedPointIndex(b),v.getYAtUncheckedPointIndex(b),v.getZAtUncheckedPointIndex(b))}}pushWrap(v){if(this._xyzInUse>=v){this.ensureCapacity(this._xyzInUse+v,!1);for(let M=0;M<v;M++){const v=3*M;this.pushXYZ(this._data[v],this._data[v+1],this._data[v+2])}}}pushXYZ(v,M,b){this.ensureCapacity(this._xyzInUse+1);const E=3*this._xyzInUse;this._data[E]=v,this._data[E+1]=M,this._data[E+2]=b,this._xyzInUse++}shiftForward(v){if(v<=0)return;this.ensureCapacity(this._xyzInUse+v);const M=3*v,b=3*this._xyzInUse;this._data.copyWithin(M,0,b),this._xyzInUse+=v}pushFrontXYZ(v,M,b){this.shiftForward(1),this._data[0]=v,this._data[1]=M,this._data[2]=b}pushFront(v){this.pushFrontXYZ(v.x,v.y,v.z)}moveIndexToIndex(v,M){if(this.isIndexValid(v)&&this.isIndexValid(M)){let b=3*v,E=3*M;this._data[E++]=this._data[b++],this._data[E++]=this._data[b++],this._data[E]=this._data[b]}}pop(){this._xyzInUse>0&&this._xyzInUse--}isIndexValid(v){return!(v>=this._xyzInUse||v<0)}clear(){this._xyzInUse=0}getPoint3dAtUncheckedPointIndex(v,M){const b=3*v;return Q.create(this._data[b],this._data[b+1],this._data[b+2],M)}getPoint2dAtUncheckedPointIndex(v,M){const b=3*v;return H.create(this._data[b],this._data[b+1],M)}getPoint3dAtCheckedPointIndex(v,M){if(this.isIndexValid(v)){const b=3*v;return Q.create(this._data[b],this._data[b+1],this._data[b+2],M)}}getXAtUncheckedPointIndex(v){const M=3*v;return this._data[M]}getYAtUncheckedPointIndex(v){const M=3*v;return this._data[M+1]}getZAtUncheckedPointIndex(v){const M=3*v;return this._data[M+2]}getPoint2dAtCheckedPointIndex(v,M){if(this.isIndexValid(v)){const b=3*v;return H.create(this._data[b],this._data[b+1],M)}}getVector3dAtCheckedVectorIndex(v,M){if(this.isIndexValid(v)){const b=3*v;return $.create(this._data[b],this._data[b+1],this._data[b+2],M)}}transferFromGrowableXYZArray(v,M,b){if(this.isIndexValid(v)&&M.isIndexValid(b)){const E=3*v,D=3*b;return this._data[E]=M._data[D],this._data[E+1]=M._data[D+1],this._data[E+2]=M._data[D+2],!0}return!1}pushFromGrowableXYZArray(v,M){if(void 0===M){const M=v.length;return this.ensureCapacity(this.length+M,!1),this.copyData(v._data,M,this.length),this._xyzInUse+=M,M}if(v.isIndexValid(M)){const b=3*M;return this.pushXYZ(v._data[b],v._data[b+1],v._data[b+2]),1}return 0}setAtCheckedPointIndex(v,M){if(!this.isIndexValid(v))return!1;let b=3*v;return this._data[b++]=M.x,this._data[b++]=M.y,this._data[b]=M.z,!0}setXYZAtCheckedPointIndex(v,M,b,E){if(!this.isIndexValid(v))return!1;let D=3*v;return this._data[D++]=M,this._data[D++]=b,this._data[D]=E,!0}getPoint3dArray(){const v=3*this._xyzInUse,M=[],b=this._data;for(let E=0;E<v;E+=3)M.push(Q.create(b[E],b[E+1],b[E+2]));return M}static multiplyTransformInPlace(v,M){if(Array.isArray(M))for(const b of M)b.multiplyTransformInPlace(v);else M.multiplyTransformInPlace(v)}multiplyTransformInPlace(v){const M=this._data,b=this.float64Length,E=v.matrix.coffs,D=v.origin,X=D.x,z=D.y,R=D.z;let O=0,Y=0,N=0;for(let B=0;B+2<=b;B+=3)O=M[B],Y=M[B+1],N=M[B+2],M[B]=E[0]*O+E[1]*Y+E[2]*N+X,M[B+1]=E[3]*O+E[4]*Y+E[5]*N+z,M[B+2]=E[6]*O+E[7]*Y+E[8]*N+R}reverseInPlace(){const v=this.length;let M,b,E;const D=this._data;for(let X=0,z=v-1;X<z;X++,z--)M=3*X,b=3*z,E=D[M],D[M]=D[b],D[b]=E,M++,b++,E=D[M],D[M]=D[b],D[b]=E,M++,b++,E=D[M],D[M]=D[b],D[b]=E}multiplyMatrix3dInPlace(v){const M=this._data,b=this.float64Length,E=v.coffs;let D=0,X=0,z=0;for(let R=0;R+2<=b;R+=3)D=M[R],X=M[R+1],z=M[R+2],M[R]=E[0]*D+E[1]*X+E[2]*z,M[R+1]=E[3]*D+E[4]*X+E[5]*z,M[R+2]=E[6]*D+E[7]*X+E[8]*z}multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(v){const M=this._data,b=this.float64Length;if(!v.computeCachedInverse(!0))return!1;const E=v.inverseCoffs,D=K.smallFloatingPoint;let X,z,R,O,Y,N=0,B=0,V=0,L=0;for(let U=0;U+2<=b;U+=3)N=M[U],B=M[U+1],V=M[U+2],X=E[0]*N+E[3]*B+E[6]*V,z=E[1]*N+E[4]*B+E[7]*V,R=E[2]*N+E[5]*B+E[8]*V,Y=X*X+z*z+R*R,Y<D?(X=N,z=B,R=V,L++):Math.abs(Y-1)>D&&(O=1/Math.sqrt(Y),X*=O,z*=O,R*=O),M[U]=X,M[U+1]=z,M[U+2]=R;return 0===L}multiplyMatrix4dAndQuietRenormalizeMatrix4d(v){const M=this._data,b=this.float64Length,E=Q.create();for(let D=0;D+2<=b;D+=3)v.multiplyXYZWQuietRenormalize(M[D],M[D+1],M[D+2],1,E),M[D]=E.x,M[D+1]=E.y,M[D+2]=E.z}tryTransformInverseInPlace(v){const M=this._data,b=this.float64Length,E=v.matrix;E.computeCachedInverse(!0);const D=E.inverseCoffs;if(!D)return!1;const X=v.origin,z=X.x,R=X.y,O=X.z;let Y=0,N=0,B=0;for(let V=0;V+2<b;V+=3)Y=M[V]-z,N=M[V+1]-R,B=M[V+2]-O,M[V]=D[0]*Y+D[1]*N+D[2]*B,M[V+1]=D[3]*Y+D[4]*N+D[5]*B,M[V+2]=D[6]*Y+D[7]*N+D[8]*B;return!0}extendRange(v,M){const b=this.float64Length,E=this._data;if(M)for(let D=0;D+2<b;D+=3)v.extendTransformedXYZ(M,E[D],E[D+1],E[D+2]);else for(let D=0;D+2<b;D+=3)v.extendXYZ(E[D],E[D+1],E[D+2])}getRange(v){const M=ut.createNull();return this.extendRange(M,v),M}setRange(v,M){v.setNull(),this.extendRange(v,M)}sumLengths(){let v=0;const M=3*(this._xyzInUse-1),b=this._data;for(let E=0;E<M;E+=3)v+=K.hypotenuseXYZ(b[E+3]-b[E],b[E+4]-b[E+1],b[E+5]-b[E+2]);return v}scaleInPlace(v){if(this._data){const M=this.float64Length;for(let b=0;b<M;b++)this._data[b]=this._data[b]*v}}isCloseToPlane(v,M=K.smallMetricDistance){const b=3*this._xyzInUse,E=this._data;for(let D=0;D<b;D+=3)if(Math.abs(v.altitudeXYZ(E[D],E[D+1],E[D+2]))>M)return!1;return!0}forceClosure(v=K.smallMetricDistance){const M=this.distanceIndexIndex(0,this.length-1);if(void 0===M);else if(M>v)this.pushXYZ(this._data[0],this._data[1],this._data[2]);else if(M>0){const v=this._data.length-3;for(let M=0;M<3;M++)this._data[v+M]=this._data[M]}}interpolate(v,M,b,E){if(this.isIndexValid(v)&&this.isIndexValid(b)){const D=1-M,X=this._data;return v*=3,b*=3,Q.create(D*X[v]+M*X[b],D*X[v+1]+M*X[b+1],D*X[v+2]+M*X[b+2],E)}}pushInterpolatedFromGrowableXYZArray(v,M,b,E){if(v.isIndexValid(M)&&v.isIndexValid(E)){const D=1-b,X=v._data;M*=3,E*=3,this.pushXYZ(D*X[M]+b*X[E],D*X[M+1]+b*X[E+1],D*X[M+2]+b*X[E+2])}}areaXY(){let v=0;const M=3*this._xyzInUse;if(M>6){const b=this._data[M-3],E=this._data[M-2];let D=this._data[0]-b,X=this._data[1]-E,z=0,R=0;for(let O=3;O<M;O+=3,D=z,X=R)z=this._data[O]-b,R=this._data[O+1]-E,v+=K.crossProductXYXY(D,X,z,R)}return.5*v}vectorIndexIndex(v,M,b){if(!this.isIndexValid(v)||!this.isIndexValid(M))return;const E=this._data;return v*=3,M*=3,$.create(E[M]-E[v],E[M+1]-E[v+1],E[M+2]-E[v+2],b)}vectorXYAndZIndex(v,M,b){if(this.isIndexValid(M)){const E=this._data;return M*=3,$.create(E[M]-v.x,E[M+1]-v.y,E[M+2]-v.z,b)}}crossProductIndexIndexIndex(v,M,b,E){if(this.isIndexValid(v)&&this.isIndexValid(M)&&this.isIndexValid(b)){const D=3*v,X=3*M,z=3*b,R=this._data;return K.crossProductXYZXYZ(R[X]-R[D],R[X+1]-R[D+1],R[X+2]-R[D+2],R[z]-R[D],R[z+1]-R[D+1],R[z+2]-R[D+2],E)}}evaluateUncheckedIndexDotProductXYZ(v,M,b,E){const D=3*v,X=this._data;return X[D]*M+X[D+1]*b+X[D+2]*E}evaluateUncheckedIndexPlaneAltitude(v,M){const b=3*v,E=this._data;return M.altitudeXYZ(E[b],E[b+1],E[b+2])}accumulateCrossProductIndexIndexIndex(v,M,b,E){if(this.isIndexValid(v)&&this.isIndexValid(M)&&this.isIndexValid(b)){const D=3*v,X=3*M,z=3*b,R=this._data;E.addCrossProductToTargetsInPlace(R[D],R[D+1],R[D+2],R[X],R[X+1],R[X+2],R[z],R[z+1],R[z+2])}}accumulateScaledXYZ(v,M,b){if(this.isIndexValid(v)){const E=3*v,D=this._data;b.x+=M*D[E],b.y+=M*D[E+1],b.z+=M*D[E+2]}}crossProductXYAndZIndexIndex(v,M,b,E){if(this.isIndexValid(M)&&this.isIndexValid(b)){const D=3*M,X=3*b,z=this._data;return K.crossProductXYZXYZ(z[D]-v.x,z[D+1]-v.y,z[D+2]-v.z,z[X]-v.x,z[X+1]-v.y,z[X+2]-v.z,E)}}distanceIndexToPoint(v,M){if(this.isIndexValid(v)){const b=3*v;return K.hypotenuseXYZ(M.x-this._data[b],M.y-this._data[b+1],M.z-this._data[b+2])}}distanceSquaredIndexIndex(v,M){if(this.isIndexValid(v)&&this.isIndexValid(M)){const b=3*v,E=3*M;return K.hypotenuseSquaredXYZ(this._data[E]-this._data[b],this._data[E+1]-this._data[b+1],this._data[E+2]-this._data[b+2])}}distanceIndexIndex(v,M){if(this.isIndexValid(v)&&this.isIndexValid(M)){const b=3*v,E=3*M;return K.hypotenuseXYZ(this._data[E]-this._data[b],this._data[E+1]-this._data[b+1],this._data[E+2]-this._data[b+2])}}static distanceBetweenPointsIn2Arrays(v,M,b,E){if(v.isIndexValid(M)&&b.isIndexValid(E)){const D=3*M,X=3*E;return K.hypotenuseXYZ(b._data[X]-v._data[D],b._data[X+1]-v._data[D+1],b._data[X+2]-v._data[D+2])}}static isAlmostEqual(v,M){if(v&&M){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(!v.getPoint3dAtUncheckedPointIndex(b).isAlmostEqual(M.getPoint3dAtUncheckedPointIndex(b)))return!1;return!0}return!v&&!M}sortIndicesLexical(){const v=this._xyzInUse,M=new Uint32Array(v);for(let b=0;b<v;b++)M[b]=b;return M.sort(((v,M)=>this.compareLexicalBlock(v,M))),M}compareLexicalBlock(v,M){let b=0,E=0;for(let D=0;D<3;D++){if(b=this._data[3*v+D],E=this._data[3*M+D],b>E)return 1;if(b<E)return-1}return v-M}component(v,M){return this._data[3*v+M]}addSteppedPoints(v,M,b,E){const D=v._data;let X=3*M;const z=3*v.length;let R=0;for(this.ensureCapacity(this._xyzInUse+E,!1);X>=0&&X+2<z&&R<E;)this.pushXYZ(D[X],D[X+1],D[X+2]),X+=3*b,R++}static distanceRangeBetweenCorrespondingPoints(v,M){const b=v._data,E=M._data,D=Math.min(v.length,M.length);let X,z=0;const R=ft.createNull();for(;z<D;)X=3*z,R.extendX(K.hypotenuseXYZ(b[X]-E[X],b[X+1]-E[X+1],b[X+2]-E[X+2])),z++;return R}static removeClosure(v,M=K.smallMetricDistance){for(;v.length>1&&v.distanceIndexIndex(0,v.length-1)<M;)v.pop()}fillLocalXYTriangleFrame(v,M,b,E){if(this.isIndexValid(v)&&this.isIndexValid(M)&&this.isIndexValid(b)){let D=3*v;const X=this._data,z=X[D++],R=X[D++],O=X[D++];D=3*M;const Y=X[D++]-z,N=X[D++]-R,B=X[D++]-O;D=3*b;const V=X[D++]-z,L=X[D++]-R,U=X[D++]-O;return(E=pt.createRowValues(Y,V,0,z,N,L,0,R,B,U,1,O,E)).computeCachedInverse()?E:void 0}}mapComponent(v,M){const b=this._data.length;let E;for(let D=0;D+2<b;D+=3)E=M(this._data[D],this._data[D+1],this._data[D+2]),this._data[D+v]=E}}class rt{startChain(v,M){}handleXYZ(v,M,b){}endChain(v,M){}}class ot extends rt{handleXYZ(v,M,b){void 0!==this._x0&&this.handleXYZXYZ(this._x0,this._y0,this._z0,v,M,b),this._x0=v,this._y0=M,this._z0=b}startChain(v,M){this._x0=this._y0=this._z0=void 0}handleXYZXYZ(v,M,b,E,D,X){}}class at extends rt{startChain(v,M){this._currentData=void 0}handleXYZ(v,M,b){this._currentData||(this._currentData=new nt),this._currentData.pushXYZ(v,M,b)}endChain(v,M){void 0!==this._currentData&&(void 0===this._pointArrays&&(this._pointArrays=[]),this._pointArrays.push(this._currentData),this._currentData=void 0)}claimArrayOfGrowableXYZArray(){const v=this._pointArrays;return this._pointArrays=void 0,v}}class ct extends rt{constructor(){super(...arguments),this._range=ut.createNull()}handleXYZ(v,M,b){this._range||(this._range=ut.createNull()),this._range.extendXYZ(v,M,b)}claimResult(){const v=this._range;return this._range=void 0,v||ut.createNull()}}class ht{constructor(v){this._xyzFunction=v,this._resultStack=[],this._resultStack.push([])}startChain(v,M){this._resultStack.push([])}handleXYZ(v,M,b){this._resultStack[this._resultStack.length-1].push(this._xyzFunction(v,M,b))}endChain(v,M){const b=this._resultStack[this._resultStack.length-1];this._resultStack.pop(),this._resultStack[this._resultStack.length-1].push(b)}claimResult(){const v=this._resultStack[0];return 1===v.length?v[0]:v}}class lt{static streamXYZ(v,M){let b=0;if(Array.isArray(v))if(v.length>0&&Q.isAnyImmediatePointType(v[0])){M.startChain(v,!0);for(const E of v){const v=Q.accessX(E),D=Q.accessY(E),X=Q.accessZ(E,0);void 0!==v&&void 0!==D&&M.handleXYZ(v,D,X),b++}M.endChain(v,!0)}else{M.startChain(v,!1);for(const E of v)b+=this.streamXYZ(E,M);M.endChain(v,!1)}else if(v instanceof it){M.startChain(v,!0);const E=lt._workPoint=Q.create(0,0,0,lt._workPoint);for(let D=0;D<v.length;D++)v.getPoint3dAtCheckedPointIndex(D,E),b++,M.handleXYZ(E.x,E.y,E.z);M.endChain(v,!0)}return b}}class dt{static npcScaleFactor(v,M){return M<=v?0:1/(M-v)}static isExtremeValue(v){return Math.abs(v)>=dt._EXTREME_POSITIVE}static isExtremePoint3d(v){return dt.isExtremeValue(v.x)||dt.isExtremeValue(v.y)||dt.isExtremeValue(v.z)}static isExtremePoint2d(v){return dt.isExtremeValue(v.x)||dt.isExtremeValue(v.y)}static rangeToRangeAbsoluteDistance(v,M,b,E){return M<v||E<b?dt._EXTREME_POSITIVE:E<v?v-E:E<=M||b<=M?0:b-M}static coordinateToRangeAbsoluteDistance(v,M,b){return b<M?dt._EXTREME_POSITIVE:v<M?M-v:v>b?v-b:0}static multiplyIfPositive(v,M,b=0){return v>0?M*v:b}}dt._EXTREME_POSITIVE=1e200,dt._EXTREME_NEGATIVE=-1e200;class ut extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.low.z=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE,this.high.z=dt._EXTREME_NEGATIVE}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}static toFloat64Array(v){return Float64Array.of(v.low.x,v.low.y,v.low.z,v.high.x,v.high.y,v.high.z)}toFloat64Array(){return ut.toFloat64Array(this)}static fromFloat64Array(v){if(6!==v.length)throw new Error("invalid array");return new this(v[0],v[1],v[2],v[3],v[4],v[5])}static fromArrayBuffer(v){return this.fromFloat64Array(new Float64Array(v))}constructor(v=dt._EXTREME_POSITIVE,M=dt._EXTREME_POSITIVE,b=dt._EXTREME_POSITIVE,E=dt._EXTREME_NEGATIVE,D=dt._EXTREME_NEGATIVE,X=dt._EXTREME_NEGATIVE){super(),this.low=Q.create(v,M,b),this.high=Q.create(E,D,X)}isAlmostEqual(v,M){return this.low.isAlmostEqual(v.low,M)&&this.high.isAlmostEqual(v.high,M)||this.isNull&&v.isNull}setFrom(v){this.low.setFrom(v.low),this.high.setFrom(v.high)}static createFrom(v,M){return M?(M.setFrom(v),M):this.createXYZXYZOrCorrectToNull(v.low.x,v.low.y,v.low.z,v.high.x,v.high.y,v.high.z,M)}setFromJSON(v){if(!v)return;if(this.setNull(),Array.isArray(v)){const M=Q.create();for(const b of v)M.setFromJSON(b),this.extendPoint(M);return}const M=Q.fromJSON(v.low),b=Q.fromJSON(v.high);dt.isExtremePoint3d(M)||dt.isExtremePoint3d(b)||(this.extendPoint(M),this.extendPoint(b))}toJSON(){return{low:this.low.toJSON(),high:this.high.toJSON()}}static fromJSON(v){const M=new this;return M.setFromJSON(v),M}setDirect(v,M,b,E,D,X,z){this.low.x=v,this.low.y=M,this.low.z=b,this.high.x=E,this.high.y=D,this.high.z=X,z&&(this.low.x>this.high.x||this.low.y>this.high.y||this.low.z>this.high.z)&&this.setNull()}clone(v){return(v=v||new this.constructor).setDirect(this.low.x,this.low.y,this.low.z,this.high.x,this.high.y,this.high.z,!1),v}cloneTranslated(v,M){return M=M||new this.constructor,this.isNull||M.setDirect(this.low.x+v.x,this.low.y+v.y,this.low.z+v.z,this.high.x+v.x,this.high.y+v.y,this.high.z+v.z,!1),M}static createNull(v){return(v=v||new this).setNull(),v}extend(...v){let M;for(M of v)this.extendPoint(M)}static create(...v){const M=ut.createNull();let b;for(b of v)M.extendPoint(b);return M}static createFromVariantData(v){const M=new ct;return lt.streamXYZ(v,M),M.claimResult()}static createTransformed(v,...M){const b=this.createNull();let E;for(E of M)b.extendTransformedXYZ(v,E.x,E.y,E.z);return b}static createTransformedArray(v,M){const b=this.createNull();return b.extendArray(M,v),b}static createInverseTransformedArray(v,M){const b=this.createNull();return b.extendInverseTransformedArray(M,v),b}setXYZ(v,M,b){this.low.x=this.high.x=v,this.low.y=this.high.y=M,this.low.z=this.high.z=b}static createXYZ(v,M,b,E){return(E=E||new this).setDirect(v,M,b,v,M,b,!1),E}static createXYZXYZ(v,M,b,E,D,X,z){return(z=z||new this).setDirect(Math.min(v,E),Math.min(M,D),Math.min(b,X),Math.max(v,E),Math.max(M,D),Math.max(b,X),!1),z}static createXYZXYZOrCorrectToNull(v,M,b,E,D,X,z){return z=z||new this,v>E||M>D||b>X?this.createNull(z):(z.setDirect(Math.min(v,E),Math.min(M,D),Math.min(b,X),Math.max(v,E),Math.max(M,D),Math.max(b,X),!0),z)}static createRange2d(v,M=0,b){const E=b||new this;return E.setNull(),E.extendXYZ(v.low.x,v.low.y,M),E.extendXYZ(v.high.x,v.high.y,M),E}static createArray(v,M){let b;for(b of((M=M||new this).setNull(),v))M.extendPoint(b);return M}extendArray(v,M){if(Array.isArray(v))if(M)for(const b of v)this.extendTransformedXYZ(M,b.x,b.y,b.z);else for(const b of v)this.extendXYZ(b.x,b.y,b.z);else if(M)for(let b=0;b<v.length;b++)this.extendTransformedXYZ(M,v.getXAtUncheckedPointIndex(b),v.getYAtUncheckedPointIndex(b),v.getZAtUncheckedPointIndex(b));else for(let b=0;b<v.length;b++)this.extendXYZ(v.getXAtUncheckedPointIndex(b),v.getYAtUncheckedPointIndex(b),v.getZAtUncheckedPointIndex(b))}extendInverseTransformedArray(v,M){if(Array.isArray(v))for(const b of v)this.extendInverseTransformedXYZ(M,b.x,b.y,b.z);else for(let b=0;b<v.length;b++)this.extendInverseTransformedXYZ(M,v.getXAtUncheckedPointIndex(b),v.getYAtUncheckedPointIndex(b),v.getZAtUncheckedPointIndex(b))}extendTransformedXYZ(v,M,b,E){const D=v.origin,X=v.matrix.coffs;this.extendXYZ(D.x+X[0]*M+X[1]*b+X[2]*E,D.y+X[3]*M+X[4]*b+X[5]*E,D.z+X[6]*M+X[7]*b+X[8]*E)}extendTransformedXYZW(v,M,b,E,D){const X=v.origin,z=v.matrix.coffs;this.extendXYZW(X.x*D+z[0]*M+z[1]*b+z[2]*E,X.y*D+z[3]*M+z[4]*b+z[5]*E,X.z*D+z[6]*M+z[7]*b+z[8]*E,D)}extendInverseTransformedXYZ(v,M,b,E){const D=v.origin;if(!v.matrix.computeCachedInverse(!0))return!1;const X=v.matrix.inverseCoffs,z=M-D.x,R=b-D.y,O=E-D.z;return this.extendXYZ(X[0]*z+X[1]*R+X[2]*O,X[3]*z+X[4]*R+X[5]*O,X[6]*z+X[7]*R+X[8]*O),!0}extendTransformTransformedXYZ(v,M,b,E,D){const X=M.origin,z=M.matrix.coffs;this.extendTransformedXYZ(v,X.x+z[0]*b+z[1]*E+z[2]*D,X.y+z[3]*b+z[4]*E+z[5]*D,X.z+z[6]*b+z[7]*E+z[8]*D)}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y||this.high.z<this.low.z}static isNull(v){return v.high.x<v.low.x||v.high.y<v.low.y||v.high.z<v.low.z}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y&&this.high.z===this.low.z}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get zLow(){return this.low.z}get xHigh(){return this.high.x}get yHigh(){return this.high.y}get zHigh(){return this.high.z}xLength(){const v=this.high.x-this.low.x;return v>0?v:0}yLength(){const v=this.high.y-this.low.y;return v>0?v:0}zLength(){const v=this.high.z-this.low.z;return v>0?v:0}maxLength(){return Math.max(this.xLength(),this.yLength(),this.zLength())}diagonal(v){return this.low.vectorTo(this.high,v)}diagonalFractionToPoint(v,M){return this.low.interpolate(v,this.high,M)}fractionToPoint(v,M,b=0,E){return this.low.interpolateXYZ(v,M,b,this.high,E)}localXYZToWorld(v,M,b,E){if(!this.isNull)return this.low.interpolateXYZ(v,M,b,this.high,E)}localToWorld(v,M){return this.localXYZToWorld(v.x,v.y,v.z,M)}localToWorldArrayInPlace(v){if(this.isNull)return!1;for(const M of v)this.low.interpolateXYZ(M.x,M.y,M.z,this.high,M);return!1}worldToLocal(v,M){const b=dt.npcScaleFactor(this.low.x,this.high.x),E=dt.npcScaleFactor(this.low.y,this.high.y),D=dt.npcScaleFactor(this.low.z,this.high.z);if(0!==b&&0!==E&&0!==D)return Q.create((v.x-this.low.x)*b,(v.y-this.low.y)*E,(v.z-this.low.z)*D,M)}worldToLocalArrayInPlace(v){const M=dt.npcScaleFactor(this.low.x,this.high.x),b=dt.npcScaleFactor(this.low.y,this.high.y),E=dt.npcScaleFactor(this.low.z,this.high.z);if(0===M||0===b||0===E)return!1;for(const D of v)Q.create((D.x-this.low.x)*M,(D.y-this.low.y)*b,(D.z-this.low.z)*E,D);return!0}corners(v){return void 0!==v&&v.length>=8?(v[0].set(this.low.x,this.low.y,this.low.z),v[1].set(this.high.x,this.low.y,this.low.z),v[2].set(this.low.x,this.high.y,this.low.z),v[3].set(this.high.x,this.high.y,this.low.z),v[4].set(this.low.x,this.low.y,this.high.z),v[5].set(this.high.x,this.low.y,this.high.z),v[6].set(this.low.x,this.high.y,this.high.z),v[7].set(this.high.x,this.high.y,this.high.z),v.length=8,v):[Q.create(this.low.x,this.low.y,this.low.z),Q.create(this.high.x,this.low.y,this.low.z),Q.create(this.low.x,this.high.y,this.low.z),Q.create(this.high.x,this.high.y,this.low.z),Q.create(this.low.x,this.low.y,this.high.z),Q.create(this.high.x,this.low.y,this.high.z),Q.create(this.low.x,this.high.y,this.high.z),Q.create(this.high.x,this.high.y,this.high.z)]}static faceCornerIndices(v){return 0===v?[0,4,6,2]:1===v?[1,3,7,5]:2===v?[0,1,5,4]:3===v?[3,2,6,7]:4===v?[0,2,3,1]:[4,5,7,6]}rectangleXY(v=0,M=!0,b=!0){if(this.isNull)return;const E=[this.fractionToPoint(0,0,v),this.fractionToPoint(1,0,v),this.fractionToPoint(1,1,v),this.fractionToPoint(0,1,v)];return b&&E.push(E[0].clone()),M||E.reverse(),E}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return K.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return K.isSmallMetricDistance(this.yLength())}get isAlmostZeroZ(){return K.isSmallMetricDistance(this.zLength())}containsXYZ(v,M,b){return v>=this.low.x&&M>=this.low.y&&b>=this.low.z&&v<=this.high.x&&M<=this.high.y&&b<=this.high.z}containsXY(v,M){return v>=this.low.x&&M>=this.low.y&&v<=this.high.x&&M<=this.high.y}containsPoint(v){return this.containsXYZ(v.x,v.y,v.z)}containsPointXY(v){return v.x>=this.low.x&&v.y>=this.low.y&&v.x<=this.high.x&&v.y<=this.high.y}containsRange(v){return v.low.x>=this.low.x&&v.low.y>=this.low.y&&v.low.z>=this.low.z&&v.high.x<=this.high.x&&v.high.y<=this.high.y&&v.high.z<=this.high.z}intersectsRange(v){return!(this.low.x>v.high.x||this.low.y>v.high.y||this.low.z>v.high.z||v.low.x>this.high.x||v.low.y>this.high.y||v.low.z>this.high.z)}intersectsRangeXY(v){return!(this.low.x>v.high.x||this.low.y>v.high.y||v.low.x>this.high.x||v.low.y>this.high.y)}distanceToPoint(v){return this.isNull?dt._EXTREME_POSITIVE:Math.min(K.hypotenuseXYZ(dt.coordinateToRangeAbsoluteDistance(v.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(v.y,this.low.y,this.high.y),dt.coordinateToRangeAbsoluteDistance(v.z,this.low.z,this.high.z)),dt._EXTREME_POSITIVE)}distanceToRange(v){return Math.min(K.hypotenuseXYZ(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,v.low.x,v.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,v.low.y,v.high.y),dt.rangeToRangeAbsoluteDistance(this.low.z,this.high.z,v.low.z,v.high.z)),dt._EXTREME_POSITIVE)}extendXYZ(v,M,b){v<this.low.x&&(this.low.x=v),v>this.high.x&&(this.high.x=v),M<this.low.y&&(this.low.y=M),M>this.high.y&&(this.high.y=M),b<this.low.z&&(this.low.z=b),b>this.high.z&&(this.high.z=b)}extendInterpolated(v,M,b){if(M<.5)this.extendXYZ(v.x+M*(b.x-v.x),v.y+M*(b.y-v.y),v.z+M*(b.z-v.z));else{const E=1-M;this.extendXYZ(b.x+E*(v.x-b.x),b.y+E*(v.y-b.y),b.z+E*(v.z-b.z))}}extendXOnly(v){v<this.low.x&&(this.low.x=v),v>this.high.x&&(this.high.x=v)}extendYOnly(v){v<this.low.y&&(this.low.y=v),v>this.high.y&&(this.high.y=v)}extendZOnly(v){v<this.low.z&&(this.low.z=v),v>this.high.z&&(this.high.z=v)}extendSingleAxis(v,M){M===R.X&&this.extendXOnly(v),M===R.Y&&this.extendYOnly(v),M===R.Z&&this.extendZOnly(v)}extendXYZW(v,M,b,E){K.isSmallMetricDistance(E)||this.extendXYZ(v/E,M/E,b/E)}extendPoint(v,M){M?this.extendTransformedXYZ(M,v.x,v.y,v.z):this.extendXYZ(v.x,v.y,v.z)}extendTransformedPoint(v,M){this.extendTransformedXYZ(v,M.x,M.y,M.z)}extendRange(v){ut.isNull(v)||(this.extendXYZ(v.low.x,v.low.y,v.low.z),this.extendXYZ(v.high.x,v.high.y,v.high.z))}extendWhenLarger(v,M){ut.isNull(v)||ut.isNull(this)||(this.high.x+=dt.multiplyIfPositive(this.high.x-v.high.x,M),this.high.y+=dt.multiplyIfPositive(this.high.y-v.high.y,M),this.high.z+=dt.multiplyIfPositive(this.high.z-v.high.z,M),this.low.x-=dt.multiplyIfPositive(v.low.x-this.low.x,M),this.low.y-=dt.multiplyIfPositive(v.low.y-this.low.y,M),this.low.z-=dt.multiplyIfPositive(v.low.z-this.low.z,M))}intersect(v,M){return this.intersectsRange(v)?ut.createXYZXYZOrCorrectToNull(Math.max(this.low.x,v.low.x),Math.max(this.low.y,v.low.y),Math.max(this.low.z,v.low.z),Math.min(this.high.x,v.high.x),Math.min(this.high.y,v.high.y),Math.min(this.high.z,v.high.z),M):ut.createNull(M)}union(v,M){return this.isNull?v.clone(M):v.isNull?this.clone(M):ut.createXYZXYZOrCorrectToNull(Math.min(this.low.x,v.low.x),Math.min(this.low.y,v.low.y),Math.min(this.low.z,v.low.z),Math.max(this.high.x,v.high.x),Math.max(this.high.y,v.high.y),Math.max(this.high.z,v.high.z),M)}scaleAboutCenterInPlace(v){if(!this.isNull){v=Math.abs(v);const M=.5*(this.low.x+this.high.x),b=.5*(this.low.y+this.high.y),E=.5*(this.low.z+this.high.z);this.high.x=K.interpolate(M,v,this.high.x),this.high.y=K.interpolate(b,v,this.high.y),this.high.z=K.interpolate(E,v,this.high.z),this.low.x=K.interpolate(M,v,this.low.x),this.low.y=K.interpolate(b,v,this.low.y),this.low.z=K.interpolate(E,v,this.low.z)}}expandInPlace(v){this.setDirect(this.low.x-v,this.low.y-v,this.low.z-v,this.high.x+v,this.high.y+v,this.high.z+v,!0)}getLocalToWorldTransform(v){return pt.createOriginAndMatrix(Q.create(this.low.x,this.low.y,this.low.z),xt.createRowValues(this.high.x-this.low.x,0,0,0,this.high.y-this.low.y,0,0,0,this.high.z-this.low.z),v)}getNpcToWorldRangeTransform(v){const M=this.getLocalToWorldTransform(v),b=M.matrix;return 0===b.coffs[0]&&(b.coffs[0]=1),0===b.coffs[4]&&(b.coffs[4]=1),0===b.coffs[8]&&(b.coffs[8]=1),M}ensureMinLengths(v=.001){let M=(v-this.xLength())/2;M>0&&(this.low.x-=M,this.high.x+=M),M=(v-this.yLength())/2,M>0&&(this.low.y-=M,this.high.y+=M),M=(v-this.zLength())/2,M>0&&(this.low.z-=M,this.high.z+=M)}}class ft extends dt{setNull(){this.low=dt._EXTREME_POSITIVE,this.high=dt._EXTREME_NEGATIVE}setDirect(v,M,b=!1){this.low=v,this.high=M,b&&v>M&&this.setNull()}constructor(v=dt._EXTREME_POSITIVE,M=dt._EXTREME_NEGATIVE){super(),this.low=v,this.high=M,this.setDirect(v,M)}isAlmostEqual(v){return K.isSameCoordinate(this.low,v.low)&&K.isSameCoordinate(this.high,v.high)||this.isNull&&v.isNull}setFrom(v){this.low=v.low,this.high=v.high}setFromJSON(v){if(this.setNull(),Array.isArray(v)){let M;for(M of v)Number.isFinite(M)&&this.extendX(M)}else void 0!==v.low&&Number.isFinite(v.low)&&void 0!==v.high&&Number.isFinite(v.high)&&(this.extendX(v.low),this.extendX(v.high))}static fromJSON(v){const M=new this;return v&&M.setFromJSON(v),M}toJSON(){return this.isNull?new Array:[this.low,this.high]}clone(v){return(v=v||new this.constructor).setDirect(this.low,this.high),v}static createFrom(v,M){return(M=M||new this).setDirect(v.low,v.high),M}static createNull(v){return(v=v||new this).setNull(),v}cloneTranslated(v,M){return(M=M||this.clone()).isNull||(M.low+=v,M.high+=v),M}setX(v){this.low=this.high=v}static createX(v,M){return(M=M||new this).setDirect(v,v),M}setXXUnordered(v,M){v<=M?(this.low=v,this.high=M):(this.low=M,this.high=v)}get isExact01(){return 0===this.low&&1===this.high}static createXX(v,M,b){return(b=b||new this).setDirect(Math.min(v,M),Math.max(v,M)),b}static createXXOrCorrectToNull(v,M,b){return M<v?ft.createNull(b):((b=b||new this).setDirect(Math.min(v,M),Math.max(v,M)),b)}static createArray(v,M){let b;for(b of(M=M||new this,v))M.extendX(b);return M}extendArray(v){let M;for(M of v)this.extendX(M)}extendArraySubset(v,M,b){const E=M+b;for(let D=M;D<E;D++)this.extendX(v[D])}get isNull(){return this.high<this.low}get isSinglePoint(){return this.high===this.low}length(){const v=this.high-this.low;return v>0?v:0}fractionToPoint(v){return K.interpolate(this.low,v,this.high)}maxAbs(){return this.isNull?0:Math.max(Math.abs(this.low),Math.abs(this.high))}get isAlmostZeroLength(){return K.isSmallMetricDistance(this.length())}containsX(v){return v>=this.low&&v<=this.high}containsRange(v){return v.low>=this.low&&v.high<=this.high}intersectsRange(v){return!(this.low>v.high||v.low>this.high)}intersectRangeXXInPlace(v,M){M<v||M<this.low||v>this.high?this.setNull():(M<this.high&&(this.high=M),v>this.low&&(this.low=v))}distanceToRange(v){return dt.rangeToRangeAbsoluteDistance(this.low,this.high,v.low,v.high)}distanceToX(v){return this.isNull?dt._EXTREME_POSITIVE:dt.coordinateToRangeAbsoluteDistance(v,this.low,this.high)}extendX(v){v<this.low&&(this.low=v),v>this.high&&(this.high=v)}extendRange(v){v.isNull||(this.extendX(v.low),this.extendX(v.high))}extendLow(v){return!!(this.isNull||v<this.low)&&(this.low=v,!0)}extendHigh(v){return!!(this.isNull||v>this.high)&&(this.high=v,!0)}intersect(v,M){return this.intersectsRange(v)?ft.createXXOrCorrectToNull(Math.max(this.low,v.low),Math.min(this.high,v.high),M):ft.createNull(M)}union(v,M){return ft.createXX(Math.min(this.low,v.low),Math.max(this.high,v.high),M)}scaleAboutCenterInPlace(v){if(!this.isNull){v=Math.abs(v);const M=.5*(this.low+this.high);this.high=K.interpolate(M,v,this.high),this.low=K.interpolate(M,v,this.low)}}expandInPlace(v){this.setDirect(this.low-v,this.high+v,!0)}clipLinearMapToInterval(v,M,b,E){if(E<b||this.high<this.low)return!1;const D=K.conditionalDivideFraction(b-v,M),X=K.conditionalDivideFraction(E-v,M);return void 0===D||void 0===X?b<=v&&v<=E||(this.setNull(),!1):(D<X?(D>this.low&&(this.low=D),X<this.high&&(this.high=X)):(D<this.high&&(this.high=D),X>this.low&&(this.low=X)),!(this.high<this.low&&(this.setNull(),1)))}}class gt extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE}static toFloat64Array(v){return Float64Array.of(v.low.x,v.low.y,v.high.x,v.high.y)}toFloat64Array(){return gt.toFloat64Array(this)}static fromFloat64Array(v){if(4!==v.length)throw new Error("invalid array");return new this(v[0],v[1],v[2],v[3])}static fromArrayBuffer(v){return this.fromFloat64Array(new Float64Array(v))}constructor(v=gt._EXTREME_POSITIVE,M=gt._EXTREME_POSITIVE,b=gt._EXTREME_NEGATIVE,E=gt._EXTREME_NEGATIVE){super(),this.low=H.create(v,M),this.high=H.create(b,E)}isAlmostEqual(v){return this.low.isAlmostEqual(v.low)&&this.high.isAlmostEqual(v.high)||this.isNull&&v.isNull}setFrom(v){this.low.set(v.low.x,v.low.y),this.high.set(v.high.x,v.high.y)}static createFrom(v,M){return M?(M.setFrom(v),M):this.createXYXYOrCorrectToNull(v.low.x,v.low.y,v.high.x,v.high.y,M)}setFromJSON(v){if(this.setNull(),Array.isArray(v)){const M=H.create();for(const b of v)M.setFromJSON(b),this.extendPoint(M);return}const M=H.fromJSON(v.low),b=H.fromJSON(v.high);dt.isExtremePoint2d(M)||dt.isExtremePoint2d(b)||(this.extendPoint(M),this.extendPoint(b))}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}toJSON(){return this.isNull?[]:[this.low.toJSON(),this.high.toJSON()]}static fromJSON(v){const M=new this;return v&&M.setFromJSON(v),M}setDirect(v,M,b,E,D){this.low.x=v,this.low.y=M,this.high.x=b,this.high.y=E,D&&(this.low.x>this.high.x||this.low.y>this.high.y)&&this.setNull()}clone(v){return(v=v||new this.constructor).setDirect(this.low.x,this.low.y,this.high.x,this.high.y,!1),v}static createNull(v){return(v=v||new this).setNull(),v}setXY(v,M){this.low.x=this.high.x=v,this.low.y=this.high.y=M}static createXY(v,M,b){return(b=b||new this).setDirect(v,M,v,M,!1),b}static createXYXY(v,M,b,E,D){return(D=D||new this).setDirect(Math.min(v,b),Math.min(M,E),Math.max(v,b),Math.max(M,E),!1),D}static createXYXYXY(v,M,b,E,D,X,z){return(z=z||new this).setDirect(Math.min(v,b,D),Math.min(M,E,X),Math.max(v,b,D),Math.max(M,E,X),!1),z}static createXYXYOrCorrectToNull(v,M,b,E,D){return v>b||M>E?this.createNull(D):((D=D||new this).setDirect(Math.min(v,b),Math.min(M,E),Math.max(v,b),Math.max(M,E),!0),D)}static createArray(v,M){let b;for(b of(M=M||new this,v))M.extendPoint(b);return M}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y}static isNull(v){return v.high.x<v.low.x||v.high.y<v.low.y}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get xHigh(){return this.high.x}get yHigh(){return this.high.y}xLength(){const v=this.high.x-this.low.x;return v>0?v:0}yLength(){const v=this.high.y-this.low.y;return v>0?v:0}diagonal(v){return this.low.vectorTo(this.high,v)}diagonalFractionToPoint(v,M){return this.low.interpolate(v,this.high,M)}fractionToPoint(v,M,b){return this.low.interpolateXY(v,M,this.high,b)}corners3d(v=!1,M=0){return v?[Q.create(this.low.x,this.low.y,M),Q.create(this.high.x,this.low.y,M),Q.create(this.high.x,this.high.y,M),Q.create(this.low.x,this.high.y,M),Q.create(this.low.x,this.low.y,M)]:[Q.create(this.low.x,this.low.y,M),Q.create(this.high.x,this.low.y,M),Q.create(this.low.x,this.high.y,M),Q.create(this.high.x,this.high.y,M)]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return K.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return K.isSmallMetricDistance(this.yLength())}containsXY(v,M){return v>=this.low.x&&M>=this.low.y&&v<=this.high.x&&M<=this.high.y}containsPoint(v){return this.containsXY(v.x,v.y)}containsRange(v){return v.low.x>=this.low.x&&v.low.y>=this.low.y&&v.high.x<=this.high.x&&v.high.y<=this.high.y}intersectsRange(v){return!(this.low.x>v.high.x||this.low.y>v.high.y||v.low.x>this.high.x||v.low.y>this.high.y)}distanceToPoint(v){return this.isNull?gt._EXTREME_POSITIVE:Math.min(K.hypotenuseXY(dt.coordinateToRangeAbsoluteDistance(v.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(v.y,this.low.y,this.high.y)),gt._EXTREME_POSITIVE)}distanceToRange(v){return Math.min(K.hypotenuseXY(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,v.low.x,v.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,v.low.y,v.high.y)),gt._EXTREME_POSITIVE)}extendXY(v,M){v<this.low.x&&(this.low.x=v),v>this.high.x&&(this.high.x=v),M<this.low.y&&(this.low.y=M),M>this.high.y&&(this.high.y=M)}extendTransformedXY(v,M,b){const E=v.multiplyComponentXYZ(0,M,b,0),D=v.multiplyComponentXYZ(1,M,b,0);this.extendXY(E,D)}extendPoint(v){this.extendXY(v.x,v.y)}extendRange(v){gt.isNull(v)||(this.extendXY(v.low.x,v.low.y),this.extendXY(v.high.x,v.high.y))}intersect(v,M){return this.intersectsRange(v)?gt.createXYXY(Math.max(this.low.x,v.low.x),Math.max(this.low.y,v.low.y),Math.min(this.high.x,v.high.x),Math.min(this.high.y,v.high.y),M):gt.createNull(M)}union(v,M){return this.isNull?gt.createFrom(v,M):gt.isNull(v)?this.clone(M):gt.createXYXY(Math.min(this.low.x,v.low.x),Math.min(this.low.y,v.low.y),Math.max(this.high.x,v.high.x),Math.max(this.high.y,v.high.y),M)}scaleAboutCenterInPlace(v){if(!this.isNull){v=Math.abs(v);const M=.5*(this.low.x+this.high.x),b=.5*(this.low.y+this.high.y);this.high.x=K.interpolate(M,v,this.high.x),this.high.y=K.interpolate(b,v,this.high.y),this.low.x=K.interpolate(M,v,this.low.x),this.low.y=K.interpolate(b,v,this.low.y)}}expandInPlace(v){this.setDirect(this.low.x-v,this.low.y-v,this.high.x+v,this.high.y+v,!0)}worldToLocal(v,M){const b=dt.npcScaleFactor(this.low.x,this.high.x),E=dt.npcScaleFactor(this.low.y,this.high.y);if(0!==b&&0!==E)return H.create((v.x-this.low.x)*b,(v.y-this.low.y)*E,M)}}class pt{constructor(v,M){this._origin=v,this._matrix=M}static get identity(){return void 0===this._identity&&(this._identity=pt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this._origin.freeze(),this._matrix.freeze(),Object.freeze(this)}setFrom(v){this._origin.setFrom(v._origin),this._matrix.setFrom(v._matrix)}setIdentity(){this._origin.setZero(),this._matrix.setIdentity()}setFromJSON(v){if(v){if(v instanceof Object&&v.origin&&v.matrix)return this._origin.setFromJSON(v.origin),void this._matrix.setFromJSON(v.matrix);if(K.isArrayOfNumberArray(v,3,4))return this._matrix.setRowValues(v[0][0],v[0][1],v[0][2],v[1][0],v[1][1],v[1][2],v[2][0],v[2][1],v[2][2]),void this._origin.set(v[0][3],v[1][3],v[2][3]);if(K.isNumberArray(v,12))return this._matrix.setRowValues(v[0],v[1],v[2],v[4],v[5],v[6],v[8],v[9],v[10]),void this._origin.set(v[3],v[7],v[11])}this.setIdentity()}isAlmostEqual(v){return this.origin.isAlmostEqual(v.origin)&&this.matrix.isAlmostEqual(v.matrix)}isAlmostEqualAllowZRotation(v){return this._origin.isAlmostEqual(v._origin)&&this._matrix.isAlmostEqualAllowZRotation(v._matrix)}toRows(){return[[this._matrix.coffs[0],this._matrix.coffs[1],this._matrix.coffs[2],this._origin.x],[this._matrix.coffs[3],this._matrix.coffs[4],this._matrix.coffs[5],this._origin.y],[this._matrix.coffs[6],this._matrix.coffs[7],this._matrix.coffs[8],this._origin.z]]}toJSON(){return this.toRows()}static fromJSON(v){const M=pt.createIdentity();return M.setFromJSON(v),M}clone(v){return v?(v._matrix.setFrom(this._matrix),v._origin.setFrom(this._origin),v):new pt(Q.createFrom(this._origin),this._matrix.clone())}cloneRigid(v=z.XYZ){const M=xt.createRigidFromMatrix3d(this.matrix,v);if(M)return new pt(this.origin.cloneAsPoint3d(),M)}static createRefs(v,M,b){return v||(v=Q.createZero()),b?(b._origin=v,b._matrix=M,b):new pt(v,M)}static createRowValues(v,M,b,E,D,X,z,R,O,Y,N,B,V){return V?(V._origin.set(E,R,B),V._matrix.setRowValues(v,M,b,D,X,z,O,Y,N),V):new pt(Q.create(E,R,B),xt.createRowValues(v,M,b,D,X,z,O,Y,N))}static createZero(v){return pt.createRowValues(0,0,0,0,0,0,0,0,0,0,0,0,v)}static createTranslationXYZ(v=0,M=0,b=0,E){return pt.createRefs($.create(v,M,b),xt.createIdentity(),E)}static createTranslation(v,M){return pt.createRefs(v,xt.createIdentity(),M)}get matrix(){return this._matrix}get origin(){return this._origin}getOrigin(){return Q.createFrom(this._origin)}getTranslation(){return $.createFrom(this._origin)}getMatrix(){return this._matrix.clone()}get isIdentity(){return this._matrix.isIdentity&&this._origin.isAlmostZero}static createIdentity(v){return v?(v._origin.setZero(),v._matrix.setIdentity(),v):pt.createRefs(Q.createZero(),xt.createIdentity())}static createOriginAndMatrix(v,M,b){return b?(b._origin.setFromPoint3d(v),b._matrix.setFrom(M),b):pt.createRefs(v?v.cloneAsPoint3d():Q.createZero(),void 0===M?xt.createIdentity():M.clone(),b)}setOriginAndMatrixColumns(v,M,b,E){void 0!==v&&this._origin.setFrom(v),this._matrix.setColumns(M,b,E)}static createOriginAndMatrixColumns(v,M,b,E,D){return D?D.setOriginAndMatrixColumns(v,M,b,E):D=pt.createRefs($.createFrom(v),xt.createColumns(M,b,E)),D}static createRigidFromOriginAndColumns(v,M,b,E,D){const X=xt.createRigidFromColumns(M,b,E,D?D._matrix:void 0);if(X)return D?(D._origin.setFrom(v),D):((D=pt.createRefs(void 0,X))._origin.setFromPoint3d(v),D)}static createFixedPointAndMatrix(v,M,b){if(v){const E=xt.xyzMinusMatrixTimesXYZ(v,M,v);return pt.createRefs(E,M.clone(),b)}return pt.createRefs(void 0,M.clone())}static createMatrixPickupPutdown(v,M,b,E){const D=xt.xyzMinusMatrixTimesXYZ(b,v,M);return pt.createRefs(D,v.clone(),E)}static createScaleAboutPoint(v,M,b){const E=xt.createScale(M,M,M),D=xt.xyzMinusMatrixTimesXYZ(v,E,v);return pt.createRefs(D,E,b)}static createFlattenAlongVectorToPlane(v,M,b){const E=xt.createFlattenAlongVectorToPlane(v,b);if(void 0!==E)return pt.createFixedPointAndMatrix(M,E)}multiplyPoint2d(v,M){return xt.xyPlusMatrixTimesXY(this._origin,this._matrix,v,M)}multiplyPoint3d(v,M){return xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,v,M)}multiplyXYAndZInPlace(v){return xt.xyzPlusMatrixTimesXYZInPlace(this._origin,this._matrix,v)}multiplyXYZ(v,M,b=0,E){return xt.xyzPlusMatrixTimesCoordinates(this._origin,this._matrix,v,M,b,E)}multiplyComponentXYZ(v,M,b,E=0){const D=this._matrix.coffs,X=3*v;return this.origin.at(v)+D[X]*M+D[X+1]*b+D[X+2]*E}multiplyComponentXYZW(v,M,b,E,D){const X=this._matrix.coffs,z=3*v;return this.origin.at(v)*D+X[z]*M+X[z+1]*b+X[z+2]*E}multiplyXYZW(v,M,b,E,D){return xt.xyzPlusMatrixTimesWeightedCoordinates(this._origin,this._matrix,v,M,b,E,D)}multiplyXYZWToFloat64Array(v,M,b,E,D){return xt.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin,this._matrix,v,M,b,E,D)}multiplyXYZToFloat64Array(v,M,b,E){return xt.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin,this._matrix,v,M,b,E)}multiplyTransposeXYZW(v,M,b,E,D){const X=this._matrix.coffs,z=this._origin;return Dt.create(v*X[0]+M*X[3]+b*X[6],v*X[1]+M*X[4]+b*X[7],v*X[2]+M*X[5]+b*X[8],v*z.x+M*z.y+b*z.z+E,D)}multiplyPoint3dArrayInPlace(v){let M;for(M of v)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,M,M)}multiplyPoint3dArrayArrayInPlace(v){for(const M of v)this.multiplyPoint3dArrayInPlace(M)}multiplyInversePoint3d(v,M){return this._matrix.multiplyInverseXYZAsPoint3d(v.x-this._origin.x,v.y-this._origin.y,v.z-this._origin.z,M)}multiplyInversePoint4d(v,M){const b=v.w;return this._matrix.multiplyInverseXYZW(v.x-b*this.origin.x,v.y-b*this.origin.y,v.z-b*this.origin.z,b,M)}multiplyInverseXYZ(v,M,b,E){return this._matrix.multiplyInverseXYZAsPoint3d(v-this._origin.x,M-this._origin.y,b-this._origin.z,E)}computeCachedInverse(v=!0){return this._matrix.computeCachedInverse(v)}static matchArrayLengths(v,M,b){const E=v.length,D=M.length;if(E>D)for(let X=D;X<E;X++)M.push(b());else D>E&&(M.length=E);return E}multiplyInversePoint3dArray(v,M){if(!this._matrix.computeCachedInverse(!0))return;const b=this.origin.x,E=this.origin.y,D=this.origin.z;if(M){const X=pt.matchArrayLengths(v,M,(()=>Q.createZero()));for(let z=0;z<X;z++)this._matrix.multiplyInverseXYZAsPoint3d(v[z].x-b,v[z].y-E,v[z].z-D,M[z]);return M}M=[];for(const X of v)M.push(this._matrix.multiplyInverseXYZAsPoint3d(X.x-b,X.y-E,X.z-D));return M}multiplyInversePoint3dArrayInPlace(v){if(!this._matrix.computeCachedInverse(!0))return!1;for(const M of v)this._matrix.multiplyInverseXYZAsPoint3d(M.x-this.origin.x,M.y-this.origin.y,M.z-this.origin.z,M);return!0}multiplyPoint2dArray(v,M){if(M){const b=pt.matchArrayLengths(v,M,(()=>H.createZero()));for(let E=0;E<b;E++)xt.xyPlusMatrixTimesXY(this._origin,this._matrix,v[E],M[E]);return M}M=[];for(const b of v)M.push(xt.xyPlusMatrixTimesXY(this._origin,this._matrix,b));return M}multiplyPoint3dArray(v,M){if(M){const b=pt.matchArrayLengths(v,M,(()=>Q.createZero()));for(let E=0;E<b;E++)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,v[E],M[E]);return M}M=[];for(const b of v)M.push(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,b));return M}multiplyVector(v,M){return this._matrix.multiplyVector(v,M)}multiplyVectorInPlace(v){this._matrix.multiplyVectorInPlace(v)}multiplyVectorXYZ(v,M,b,E){return this._matrix.multiplyXYZ(v,M,b,E)}setMultiplyTransformTransform(v,M){xt.xyzPlusMatrixTimesXYZ(v._origin,v._matrix,M._origin,this._origin),v._matrix.multiplyMatrixMatrix(M._matrix,this._matrix)}multiplyTransformTransform(v,M){return M?(M.setMultiplyTransformTransform(this,v),M):pt.createRefs(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,v._origin),this._matrix.multiplyMatrixMatrix(v._matrix))}multiplyTransformMatrix3d(v,M){return M?(this._matrix.multiplyMatrixMatrix(v,M._matrix),M._origin.setFrom(this._origin),M):pt.createRefs(this._origin.cloneAsPoint3d(),this._matrix.multiplyMatrixMatrix(v))}multiplyRange(v,M){if(v.isNull)return v.clone(M);const b=v.low.x,E=v.low.y,D=v.low.z,X=v.high.x,z=v.high.y,R=v.high.z;return(M=ut.createNull(M)).extendTransformedXYZ(this,b,E,D),M.extendTransformedXYZ(this,X,E,D),M.extendTransformedXYZ(this,b,z,D),M.extendTransformedXYZ(this,X,z,D),M.extendTransformedXYZ(this,b,E,R),M.extendTransformedXYZ(this,X,E,R),M.extendTransformedXYZ(this,b,z,R),M.extendTransformedXYZ(this,X,z,R),M}inverse(v){const M=this._matrix.inverse(v?v._matrix:void 0);if(M)return v?(M.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z,v._origin),v):pt.createRefs(M.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z),M)}static initFromRange(v,M,b,E){const D=M.minus(v);0===D.x&&(D.x=1),0===D.y&&(D.y=1),0===D.z&&(D.z=1);const X=new xt;if(b&&(xt.createScale(D.x,D.y,D.z,X),pt.createOriginAndMatrix(v,X,b)),E){const M=new Q(-v.x/D.x,-v.y/D.y,-v.z/D.z);xt.createScale(1/D.x,1/D.y,1/D.z,X),pt.createOriginAndMatrix(M,X,E)}}}class mt{static loadMatrix(v,M,b,E,D,X,z,R,O,Y){v[0]=M,v[1]=b,v[2]=E,v[3]=D,v[4]=X,v[5]=z,v[6]=R,v[7]=O,v[8]=Y}static multiplyMatrixMatrix(v,M,b){return(!b||b.length<9)&&(b=new Float64Array(9)),mt.loadMatrix(b,v[0]*M[0]+v[1]*M[3]+v[2]*M[6],v[0]*M[1]+v[1]*M[4]+v[2]*M[7],v[0]*M[2]+v[1]*M[5]+v[2]*M[8],v[3]*M[0]+v[4]*M[3]+v[5]*M[6],v[3]*M[1]+v[4]*M[4]+v[5]*M[7],v[3]*M[2]+v[4]*M[5]+v[5]*M[8],v[6]*M[0]+v[7]*M[3]+v[8]*M[6],v[6]*M[1]+v[7]*M[4]+v[8]*M[7],v[6]*M[2]+v[7]*M[5]+v[8]*M[8]),b}static multiplyMatrixMatrixTranspose(v,M,b){return(!b||b.length<9)&&(b=new Float64Array(9)),mt.loadMatrix(b,v[0]*M[0]+v[1]*M[1]+v[2]*M[2],v[0]*M[3]+v[1]*M[4]+v[2]*M[5],v[0]*M[6]+v[1]*M[7]+v[2]*M[8],v[3]*M[0]+v[4]*M[1]+v[5]*M[2],v[3]*M[3]+v[4]*M[4]+v[5]*M[5],v[3]*M[6]+v[4]*M[7]+v[5]*M[8],v[6]*M[0]+v[7]*M[1]+v[8]*M[2],v[6]*M[3]+v[7]*M[4]+v[8]*M[5],v[6]*M[6]+v[7]*M[7]+v[8]*M[8]),b}static multiplyMatrixTransposeMatrix(v,M,b){return(!b||b.length<9)&&(b=new Float64Array(9)),mt.loadMatrix(b,v[0]*M[0]+v[3]*M[3]+v[6]*M[6],v[0]*M[1]+v[3]*M[4]+v[6]*M[7],v[0]*M[2]+v[3]*M[5]+v[6]*M[8],v[1]*M[0]+v[4]*M[3]+v[7]*M[6],v[1]*M[1]+v[4]*M[4]+v[7]*M[7],v[1]*M[2]+v[4]*M[5]+v[7]*M[8],v[2]*M[0]+v[5]*M[3]+v[8]*M[6],v[2]*M[1]+v[5]*M[4]+v[8]*M[7],v[2]*M[2]+v[5]*M[5]+v[8]*M[8]),b}static transposeInPlace(v){let M=v[1];v[1]=v[3],v[3]=M,M=v[2],v[2]=v[6],v[6]=M,M=v[5],v[5]=v[7],v[7]=M}static copyTransposed(v,M){return M===v?mt.transposeInPlace(M):((!M||M.length<9)&&(M=new Float64Array(9)),M[0]=v[0],M[1]=v[3],M[2]=v[6],M[3]=v[1],M[4]=v[4],M[5]=v[7],M[6]=v[2],M[7]=v[5],M[8]=v[8]),M}static copy(v,M){return M!==v&&(M[0]=v[0],M[1]=v[1],M[2]=v[2],M[3]=v[3],M[4]=v[4],M[5]=v[5],M[6]=v[6],M[7]=v[7],M[8]=v[8]),M}}!function(v){v[v.unknown=0]="unknown",v[v.inverseStored=1]="inverseStored",v[v.singular=2]="singular"}(V||(V={}));class xt{static get identity(){return void 0===this._identity&&(this._identity=xt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this.computeCachedInverse(!0),Object.freeze(this)}constructor(v){this.coffs=v&&v.length>=9?v:new Float64Array(9),this.inverseCoffs=void 0,this.inverseState=V.unknown}toJSON(){return[[this.coffs[0],this.coffs[1],this.coffs[2]],[this.coffs[3],this.coffs[4],this.coffs[5]],[this.coffs[6],this.coffs[7],this.coffs[8]]]}setFromJSON(v){this.inverseCoffs=void 0,v?Array.isArray(v)?K.isArrayOfNumberArray(v,3,3)?this.setRowValues(v[0][0],v[0][1],v[0][2],v[1][0],v[1][1],v[1][2],v[2][0],v[2][1],v[2][2]):9!==v.length?4!==v.length?this.setRowValues(0,0,0,0,0,0,0,0,0):this.setRowValues(v[0],v[1],0,v[2],v[3],0,0,0,1):this.setRowValues(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8]):v instanceof xt&&this.setFrom(v):this.setRowValues(0,0,0,0,0,0,0,0,0)}static fromJSON(v){const M=xt.createIdentity();return M.setFromJSON(v),M}isAlmostEqual(v,M){return K.isDistanceWithinTol(this.maxDiff(v),M)}isAlmostEqualColumn(v,M,b){const E=K.maxAbsXYZ(this.coffs[v]-M.coffs[v],this.coffs[v+3]-M.coffs[v+3],this.coffs[v+6]-M.coffs[v+6]);return K.isDistanceWithinTol(E,b)}isAlmostEqualColumnXYZ(v,M,b,E,D){const X=K.maxAbsXYZ(this.coffs[v]-M,this.coffs[v+3]-b,this.coffs[v+6]-E);return K.isDistanceWithinTol(X,D)}isAlmostEqualAllowZRotation(v,M){if(this.isAlmostEqual(v,M))return!0;if(this.isAlmostEqualColumn(R.Z,v,M)){const b=W.radiansBetweenVectorsXYZ(this.coffs[0],this.coffs[3],this.coffs[6],v.coffs[0],v.coffs[3],v.coffs[6]),E=W.createRadians(b),D=this.columnX(),X=this.columnY(),z=this.columnZ();let R=$.createRotateVectorAroundVector(D,z,E);if(v.isAlmostEqualColumnXYZ(0,R.x,R.y,R.z,M))return R=$.createRotateVectorAroundVector(X,z,E),v.isAlmostEqualColumnXYZ(1,R.x,R.y,R.z,M)}return!1}isExactEqual(v){return 0===this.maxDiff(v)}get isXY(){return 0===this.coffs[2]&&0===this.coffs[5]&&0===this.coffs[6]&&0===this.coffs[7]&&1===this.coffs[8]}static _create(v){return v||new xt}static createRowValues(v,M,b,E,D,X,z,R,O,Y){return(Y=Y||new xt).inverseState=V.unknown,Y.coffs[0]=v,Y.coffs[1]=M,Y.coffs[2]=b,Y.coffs[3]=E,Y.coffs[4]=D,Y.coffs[5]=X,Y.coffs[6]=z,Y.coffs[7]=R,Y.coffs[8]=O,Y}static createCapture(v,M){const b=new xt(v);return M&&M.length>=9?(b.inverseCoffs=M,b.inverseState=V.inverseStored):b.inverseState=V.unknown,b}static createColumnsInAxisOrder(v,M,b,E,D){return D||(D=new xt),v===z.YZX?D.setColumns(E,M,b):v===z.ZXY?D.setColumns(b,E,M):v===z.XZY?D.setColumns(M,E,b):v===z.YXZ?D.setColumns(b,M,E):v===z.ZYX?D.setColumns(E,b,M):D.setColumns(M,b,E),D}createInverseCoffsWithZeros(){this.inverseCoffs||(this.inverseState=V.unknown,this.inverseCoffs=new Float64Array(9))}setupInverseTranspose(){const v=this.coffs;this.inverseState=V.inverseStored,this.inverseCoffs=Float64Array.from([v[0],v[3],v[6],v[1],v[4],v[7],v[2],v[5],v[8]])}setRowValues(v,M,b,E,D,X,z,R,O){this.coffs[0]=v,this.coffs[1]=M,this.coffs[2]=b,this.coffs[3]=E,this.coffs[4]=D,this.coffs[5]=X,this.coffs[6]=z,this.coffs[7]=R,this.coffs[8]=O,this.inverseState=V.unknown}setIdentity(){this.setRowValues(1,0,0,0,1,0,0,0,1),this.setupInverseTranspose()}setZero(){this.setRowValues(0,0,0,0,0,0,0,0,0),this.inverseState=V.singular}setFrom(v){if(void 0!==v){if(v!==this){for(let M=0;M<9;M++)this.coffs[M]=v.coffs[M];if(v.inverseState===V.inverseStored&&void 0!==v.inverseCoffs){this.createInverseCoffsWithZeros();for(let M=0;M<9;M++)this.inverseCoffs[M]=v.inverseCoffs[M];this.inverseState=V.inverseStored}else v.inverseState!==V.inverseStored?this.inverseState=v.inverseState:this.inverseState=V.unknown}}else this.setIdentity()}clone(v){return(v=v||new xt).setFrom(this),v}static createZero(){const v=new xt;return v.inverseState=V.singular,v}static createIdentity(v){return(v=v||new xt).setIdentity(),v}static createScale(v,M,b,E){return E?E.setZero():E=new xt,E.coffs[0]=v,E.coffs[4]=M,E.coffs[8]=b,0===v||0===M||0===b?E.inverseState=V.singular:(E.inverseState=V.inverseStored,E.inverseCoffs=Float64Array.from([1/v,0,0,0,1/M,0,0,0,1/b])),E}static createUniformScale(v){return xt.createScale(v,v,v)}static createPerpendicularVectorFavorXYPlane(v,M){const b=v.magnitude()/64;return Math.abs(v.x)<b&&Math.abs(v.y)<b?$.createCrossProduct(v.x,v.y,v.z,0,-1,0,M):$.createCrossProduct(0,0,1,v.x,v.y,v.z,M)}static createPerpendicularVectorFavorPlaneContainingZ(v,M){return M=xt.createPerpendicularVectorFavorXYPlane(v,M),v.crossProduct(M,M)}static createShuffledColumns(v,M,b,E,D){const X=xt._create(D);return X.setColumn(K.axisOrderToAxis(E,0),v),X.setColumn(K.axisOrderToAxis(E,1),M),X.setColumn(K.axisOrderToAxis(E,2),b),X}static createRigidFromColumns(v,M,b,E){const D=v.normalize();if(D){const X=D.unitCrossProduct(M);if(X){const M=X.unitCrossProduct(v);if(M){const v=xt.createShuffledColumns(D,M,X,b,E);return v.setupInverseTranspose(),v}}}}static createRigidHeadsUp(v,M=z.ZXY,b){const E=xt.createPerpendicularVectorFavorXYPlane(v),D=xt.createRigidFromColumns(v,E,M,b);return D?(D.setupInverseTranspose(),D):xt.createIdentity(b)}static createRotationAroundVector(v,M,b){const E=M.cos(),D=M.sin(),X=1-E,z=v.normalize();if(z){const v=xt.createRowValues(z.x*z.x*X+E,z.x*z.y*X-D*z.z,z.x*z.z*X+D*z.y,z.y*z.x*X+D*z.z,z.y*z.y*X+E,z.y*z.z*X-D*z.x,z.z*z.x*X-D*z.y,z.z*z.y*X+D*z.x,z.z*z.z*X+E,b);return v.setupInverseTranspose(),v}}static createRotationAroundAxisIndex(v,M,b){const E=M.cos(),D=M.sin();let X;return X=v===R.X?xt.createRowValues(1,0,0,0,E,-D,0,D,E,b):v===R.Y?xt.createRowValues(E,0,D,0,1,0,-D,0,E,b):xt.createRowValues(E,-D,0,D,E,0,0,0,1,b),X.setupInverseTranspose(),X}applyGivensRowOp(v,M,b,E){let D=3*v,X=3*M;const z=D+3;for(;D<z;D++,X++){const v=this.coffs[D],M=this.coffs[X];this.coffs[D]=v*b+M*E,this.coffs[X]=-v*E+M*b}}applyGivensColumnOp(v,M,b,E){const D=v+9;for(;v<D;v+=3,M+=3){const D=this.coffs[v],X=this.coffs[M];this.coffs[v]=D*b+X*E,this.coffs[M]=-D*E+X*b}}static createColumns(v,M,b,E){return xt.createRowValues(v.x,M.x,b.x,v.y,M.y,b.y,v.z,M.z,b.z,E)}static createColumnsXYW(v,M,b,E,D,X,z){return xt.createRowValues(v.x,b.x,D.x,v.y,b.y,D.y,M,E,X,z)}static createViewedAxes(v,M,b=0,E=0){const D=v.crossProduct(M);if(D.normalizeInPlace()){const X=xt.createColumns(v,M,D);if(0!==b){let v=Math.sqrt(.5),M=b<0?-v:v;if(1!==Math.abs(b)){const E=W.degreesToRadians(45*b);v=Math.cos(E),M=Math.sin(E)}X.applyGivensColumnOp(2,0,v,M)}if(0!==E){const v=E*Math.atan(Math.sqrt(.5)),M=Math.cos(v),b=Math.sin(v);X.applyGivensColumnOp(1,2,M,-b)}return X}}static createStandardWorldToView(v,M=!1,b){switch(v){case O.Bottom:b=xt.createRowValues(1,0,0,0,-1,0,0,0,-1);break;case O.Left:b=xt.createRowValues(0,-1,0,0,0,1,-1,0,0);break;case O.Right:b=xt.createRowValues(0,1,0,0,0,1,1,0,0);break;case O.Front:b=xt.createRowValues(1,0,0,0,0,1,0,-1,0);break;case O.Back:b=xt.createRowValues(-1,0,0,0,0,1,0,1,0);break;case O.Iso:b=xt.createRowValues(.707106781186548,-.7071067811865476,0,.408248290463863,.408248290463863,.816496580927726,-.577350269189626,-.5773502691896257,.5773502691896257);break;case O.RightIso:b=xt.createRowValues(.707106781186548,.7071067811865476,0,-.408248290463863,.408248290463863,.816496580927726,.577350269189626,-.5773502691896257,.5773502691896257);break;case O.Top:default:b=xt.createIdentity(b)}return M&&b.transposeInPlace(),b}applySymmetricJacobi(v,M,b,E){const D=E.at(v,v),X=E.at(M,M),z=E.at(v,M);if(Math.abs(z)<K.smallFloatingPoint*(D+X))return 0;const R=W.trigValuesToHalfAngleTrigValues(D-X,2*z),O=R.c,Y=R.s;return Math.abs(Y)<2e-15?0:(E.applyGivensRowOp(v,M,O,Y),E.applyGivensColumnOp(v,M,O,Y),b.applyGivensColumnOp(v,M,O,Y),Math.abs(z))}symmetricEigenvalues(v,M){const b=this.clone();v.setIdentity(),b.coffs[3]=b.coffs[1],b.coffs[6]=b.coffs[2],b.coffs[7]=b.coffs[5];const E=1e-12*this.sumSquares();for(let D=0;D<7;D++)if(this.applySymmetricJacobi(0,1,v,b)+this.applySymmetricJacobi(0,2,v,b)+this.applySymmetricJacobi(1,2,v,b)<E)return M.set(b.at(0,0),b.at(1,1),b.at(2,2)),!0;return!1}applyFastSymmetricJacobi(v,M,b,E){const D=4*v,X=4*M,z=3*v+M,R=3*M+v,O=3*v+b,Y=3*b+v,N=3*M+b,B=3*b+M,V=this.coffs[D],L=this.coffs[X],U=this.coffs[z];if(Math.abs(U)<K.smallFloatingPoint*(V+L))return 0;const Sr=W.trigValuesToHalfAngleTrigValues(V-L,2*U),Cr=Sr.c,kr=Sr.s,Fr=Cr*Cr,Xr=kr*kr,zr=2*Cr*kr;this.coffs[D]=Fr*V+zr*U+Xr*L,this.coffs[X]=Xr*V-zr*U+Fr*L,this.coffs[z]=0,this.coffs[R]=0;const Rr=this.coffs[O],Or=this.coffs[N];return this.coffs[O]=Cr*Rr+kr*Or,this.coffs[N]=-kr*Rr+Cr*Or,this.coffs[Y]=this.coffs[O],this.coffs[B]=this.coffs[N],E.applyGivensColumnOp(v,M,Cr,kr),Math.abs(U)}fastSymmetricEigenvalues(v,M){const b=this.clone();v.setIdentity();const E=1e-12*this.sumSquares();for(let D=0;D<7;D++)if(b.applyFastSymmetricJacobi(0,1,2,v)+b.applyFastSymmetricJacobi(0,2,1,v)+b.applyFastSymmetricJacobi(1,2,0,v)<E)return M.set(b.at(0,0),b.at(1,1),b.at(2,2)),!0;return!1}getAxisAndAngleOfRotation(){const v=this.coffs[0]+this.coffs[4]+this.coffs[8],M=this.coffs[3]-this.coffs[1],b=this.coffs[7]-this.coffs[5],E=this.coffs[2]-this.coffs[6],D=(v-1)/2,X=K.hypotenuseXYZ(M,b,E)/2,z=D*D+X*X-1;if(Math.abs(z)>K.smallAngleRadians)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1};if(Math.abs(X)<K.smallAngleRadians){if(D>0)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!0};const v=this.coffs[0],M=this.coffs[4],b=this.coffs[8];if(K.isAlmostEqualNumber(-1,M)&&K.isAlmostEqualNumber(-1,b))return{axis:$.create(1,0,0),angle:W.createDegrees(180),ok:!0};if(K.isAlmostEqualNumber(-1,v)&&K.isAlmostEqualNumber(-1,b))return{axis:$.create(0,1,0),angle:W.createDegrees(180),ok:!0};if(K.isAlmostEqualNumber(-1,v)&&K.isAlmostEqualNumber(-1,M))return{axis:$.create(0,0,1),angle:W.createDegrees(180),ok:!0};const E=xt.createIdentity(),X=$.create(0,0,0);if(this.fastSymmetricEigenvalues(E,X)){for(let v=0;v<2;v++){const M=X.at(v);if(K.isAlmostEqualNumber(1,M))return{axis:E.getColumn(v),angle:W.createDegrees(180),ok:!0}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}const R=1/(2*X);return{axis:$.create(b*R,E*R,M*R),angle:W.createAtan2(X,D),ok:!0}}applyJacobiColumnRotation(v,M,b){const E=this.coffs[v]*this.coffs[v]+this.coffs[v+3]*this.coffs[v+3]+this.coffs[v+6]*this.coffs[v+6],D=this.coffs[M]*this.coffs[M]+this.coffs[M+3]*this.coffs[M+3]+this.coffs[M+6]*this.coffs[M+6],X=this.coffs[v]*this.coffs[M]+this.coffs[v+3]*this.coffs[M+3]+this.coffs[v+6]*this.coffs[M+6],z=W.trigValuesToHalfAngleTrigValues(E-D,2*X),R=z.c,O=z.s;return Math.abs(O)<2e-15?0:(this.applyGivensColumnOp(v,M,R,O),b.applyGivensRowOp(v,M,R,O),Math.abs(X))}factorPerpendicularColumns(v,M){v.setFrom(this),M.setIdentity();const b=1e-12*this.sumSquares();for(let E=0;E<7;E++)if(v.applyJacobiColumnRotation(0,1,M)+v.applyJacobiColumnRotation(0,2,M)+v.applyJacobiColumnRotation(1,2,M)<b)return!0;return!1}factorOrthogonalScaleOrthogonal(v,M,b){const E=xt.createZero();if(!this.factorPerpendicularColumns(E,b))return!1;const D=[];D.push(E.getColumn(0)),D.push(E.getColumn(1)),D.push(E.getColumn(2)),M.set(D[0].magnitude(),D[1].magnitude(),D[2].magnitude()),E.determinant()<0&&(M.z=-M.z);const X=K.smallFloatingPoint,R=Math.abs(M.x)<X,O=Math.abs(M.y)<X,Y=Math.abs(M.z)<X;return R||O||Y?R||O?R?v.setIdentity():v=xt.createRigidHeadsUp(D[0],z.XYZ,v):(D[0].scaleInPlace(1/M.x),D[1].scaleInPlace(1/M.y),D[2]=D[0].unitCrossProduct(D[1],D[2]),v.setColumns(D[0],D[1],D[2])):v=E.scaleColumns(1/M.x,1/M.y,1/M.z,v),!0}static createPartialRotationVectorToVector(v,M,b,E){let D=v.unitCrossProduct(b);return D?xt.createRotationAroundVector(D,W.createRadians(M*v.planarAngleTo(b,D).radians)):K.isSmallMetricDistance(v.magnitude())||K.isSmallMetricDistance(b.magnitude())?void 0:v.dotProduct(b)>0?xt.createIdentity(E):(D=xt.createPerpendicularVectorFavorPlaneContainingZ(v,D),xt.createRotationAroundVector(D,W.createRadians(M*Math.PI)))}static createRotationVectorToVector(v,M,b){return this.createPartialRotationVectorToVector(v,1,M,b)}static create90DegreeRotationAroundAxis(v){if(0===(v=K.cyclic3dAxis(v))){const v=xt.createRowValues(1,0,0,0,0,-1,0,1,0);return v.setupInverseTranspose(),v}if(1===v){const v=xt.createRowValues(0,0,1,0,1,0,-1,0,0);return v.setupInverseTranspose(),v}{const v=xt.createRowValues(0,-1,0,1,0,0,0,0,1);return v.setupInverseTranspose(),v}}columnX(v){return $.create(this.coffs[0],this.coffs[3],this.coffs[6],v)}columnY(v){return $.create(this.coffs[1],this.coffs[4],this.coffs[7],v)}columnZ(v){return $.create(this.coffs[2],this.coffs[5],this.coffs[8],v)}columnXMagnitudeSquared(){return K.hypotenuseSquaredXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitudeSquared(){return K.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitudeSquared(){return K.hypotenuseSquaredXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXMagnitude(){return K.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitude(){return K.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitude(){return K.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXYCrossProductMagnitude(){return K.crossProductMagnitude(this.coffs[0],this.coffs[3],this.coffs[6],this.coffs[1],this.coffs[4],this.coffs[7])}rowXMagnitude(){return K.hypotenuseXYZ(this.coffs[0],this.coffs[1],this.coffs[2])}rowYMagnitude(){return K.hypotenuseXYZ(this.coffs[3],this.coffs[4],this.coffs[5])}rowZMagnitude(){return K.hypotenuseXYZ(this.coffs[6],this.coffs[7],this.coffs[8])}columnXDotColumnY(){return this.coffs[0]*this.coffs[1]+this.coffs[3]*this.coffs[4]+this.coffs[6]*this.coffs[7]}columnXDotColumnZ(){return this.coffs[0]*this.coffs[2]+this.coffs[3]*this.coffs[5]+this.coffs[6]*this.coffs[8]}columnYDotColumnZ(){return this.coffs[1]*this.coffs[2]+this.coffs[4]*this.coffs[5]+this.coffs[7]*this.coffs[8]}columnDotXYZ(v,M,b,E){return this.coffs[v]*M+this.coffs[v+3]*b+this.coffs[v+6]*E}rowX(v){return $.create(this.coffs[0],this.coffs[1],this.coffs[2],v)}rowY(v){return $.create(this.coffs[3],this.coffs[4],this.coffs[5],v)}rowZ(v){return $.create(this.coffs[6],this.coffs[7],this.coffs[8],v)}dotColumnX(v){return v.x*this.coffs[0]+v.y*this.coffs[3]+v.z*this.coffs[6]}dotColumnY(v){return v.x*this.coffs[1]+v.y*this.coffs[4]+v.z*this.coffs[7]}dotColumnZ(v){return v.x*this.coffs[2]+v.y*this.coffs[5]+v.z*this.coffs[8]}dotRowX(v){return v.x*this.coffs[0]+v.y*this.coffs[1]+v.z*this.coffs[2]}dotRowY(v){return v.x*this.coffs[3]+v.y*this.coffs[4]+v.z*this.coffs[5]}dotRowZ(v){return v.x*this.coffs[6]+v.y*this.coffs[7]+v.z*this.coffs[8]}dotRowXXYZ(v,M,b){return v*this.coffs[0]+M*this.coffs[1]+b*this.coffs[2]}dotRowYXYZ(v,M,b){return v*this.coffs[3]+M*this.coffs[4]+b*this.coffs[5]}dotRowZXYZ(v,M,b){return v*this.coffs[6]+M*this.coffs[7]+b*this.coffs[8]}columnZCrossVector(v,M){return K.crossProductXYZXYZ(this.coffs[2],this.coffs[5],this.coffs[8],v.x,v.y,v.z,M)}setColumnsPoint4dXYZ(v,M,b){this.inverseState=V.unknown,this.setRowValues(v.x,M.x,b.x,v.y,M.y,b.y,v.z,M.z,b.z)}setColumn(v,M){const b=K.cyclic3dAxis(v);this.inverseState=V.unknown,M?(this.coffs[b]=M.x,this.coffs[b+3]=M.y,this.coffs[b+6]=M.z):(this.coffs[b]=0,this.coffs[b+3]=0,this.coffs[b+6]=0)}setColumns(v,M,b){this.setColumn(0,v),this.setColumn(1,M),this.setColumn(2,b)}setRow(v,M){const b=3*K.cyclic3dAxis(v);this.coffs[b]=M.x,this.coffs[b+1]=M.y,this.coffs[b+2]=M.z,this.inverseState=V.unknown}getColumn(v,M){const b=K.cyclic3dAxis(v);return $.create(this.coffs[b],this.coffs[b+3],this.coffs[b+6],M)}getRow(v,M){const b=3*K.cyclic3dAxis(v);return $.create(this.coffs[b],this.coffs[b+1],this.coffs[b+2],M)}static createRows(v,M,b,E){return xt.createRowValues(v.x,v.y,v.z,M.x,M.y,M.z,b.x,b.y,b.z,E)}static createDirectionalScale(v,M,b){const E=v.normalize();if(E){const v=E.x,D=E.y,X=E.z,z=M-1;return xt.createRowValues(1+z*v*v,z*v*D,z*v*X,z*D*v,1+z*D*D,z*D*X,z*X*v,z*X*D,1+z*X*X,b)}return xt.createUniformScale(M)}static createFlattenAlongVectorToPlane(v,M){const b=xt.createIdentity(),E=v.dotProduct(M),D=K.conditionalDivideCoordinate(1,-E);if(void 0!==D)return b.addScaledOuterProductInPlace(v,M,D),b}multiplyPoint(v,M){const b=v.x,E=v.y,D=v.z;return Q.create(this.coffs[0]*b+this.coffs[1]*E+this.coffs[2]*D,this.coffs[3]*b+this.coffs[4]*E+this.coffs[5]*D,this.coffs[6]*b+this.coffs[7]*E+this.coffs[8]*D,M)}multiplyVector(v,M){const b=v.x,E=v.y,D=v.z;return $.create(this.coffs[0]*b+this.coffs[1]*E+this.coffs[2]*D,this.coffs[3]*b+this.coffs[4]*E+this.coffs[5]*D,this.coffs[6]*b+this.coffs[7]*E+this.coffs[8]*D,M)}multiplyVectorArrayInPlace(v){for(const M of v)M.set(this.coffs[0]*M.x+this.coffs[1]*M.y+this.coffs[2]*M.z,this.coffs[3]*M.x+this.coffs[4]*M.y+this.coffs[5]*M.z,this.coffs[6]*M.x+this.coffs[7]*M.y+this.coffs[8]*M.z)}static xyzMinusMatrixTimesXYZ(v,M,b,E){const D=b.x,X=b.y,z=b.z;return Q.create(v.x-(M.coffs[0]*D+M.coffs[1]*X+M.coffs[2]*z),v.y-(M.coffs[3]*D+M.coffs[4]*X+M.coffs[5]*z),v.z-(M.coffs[6]*D+M.coffs[7]*X+M.coffs[8]*z),E)}static xyPlusMatrixTimesXY(v,M,b,E){const D=b.x,X=b.y;return H.create(v.x+M.coffs[0]*D+M.coffs[1]*X,v.y+M.coffs[3]*D+M.coffs[4]*X,E)}static xyzPlusMatrixTimesXYZ(v,M,b,E){const D=b.x,X=b.y,z=b.z;return Q.create(v.x+M.coffs[0]*D+M.coffs[1]*X+M.coffs[2]*z,v.y+M.coffs[3]*D+M.coffs[4]*X+M.coffs[5]*z,v.z+M.coffs[6]*D+M.coffs[7]*X+M.coffs[8]*z,E)}static xyzPlusMatrixTimesXYZInPlace(v,M,b){const E=b.x,D=b.y,X=b.z;b.x=v.x+M.coffs[0]*E+M.coffs[1]*D+M.coffs[2]*X,b.y=v.y+M.coffs[3]*E+M.coffs[4]*D+M.coffs[5]*X,b.z=v.z+M.coffs[6]*E+M.coffs[7]*D+M.coffs[8]*X}static xyzPlusMatrixTimesCoordinates(v,M,b,E,D,X){return Q.create(v.x+M.coffs[0]*b+M.coffs[1]*E+M.coffs[2]*D,v.y+M.coffs[3]*b+M.coffs[4]*E+M.coffs[5]*D,v.z+M.coffs[6]*b+M.coffs[7]*E+M.coffs[8]*D,X)}static xyzPlusMatrixTimesWeightedCoordinates(v,M,b,E,D,X,z){return Dt.create(M.coffs[0]*b+M.coffs[1]*E+M.coffs[2]*D+v.x*X,M.coffs[3]*b+M.coffs[4]*E+M.coffs[5]*D+v.y*X,M.coffs[6]*b+M.coffs[7]*E+M.coffs[8]*D+v.z*X,X,z)}static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(v,M,b,E,D,X,z){return(!z||z.length<4)&&(z=new Float64Array(4)),z[0]=M.coffs[0]*b+M.coffs[1]*E+M.coffs[2]*D+v.x*X,z[1]=M.coffs[3]*b+M.coffs[4]*E+M.coffs[5]*D+v.y*X,z[2]=M.coffs[6]*b+M.coffs[7]*E+M.coffs[8]*D+v.z*X,z[3]=X,z}static xyzPlusMatrixTimesCoordinatesToFloat64Array(v,M,b,E,D,X){return(!X||X.length<3)&&(X=new Float64Array(3)),X[0]=M.coffs[0]*b+M.coffs[1]*E+M.coffs[2]*D+v.x,X[1]=M.coffs[3]*b+M.coffs[4]*E+M.coffs[5]*D+v.y,X[2]=M.coffs[6]*b+M.coffs[7]*E+M.coffs[8]*D+v.z,X}multiplyTransposeVector(v,M){M=M||new $;const b=v.x,E=v.y,D=v.z;return M.x=this.coffs[0]*b+this.coffs[3]*E+this.coffs[6]*D,M.y=this.coffs[1]*b+this.coffs[4]*E+this.coffs[7]*D,M.z=this.coffs[2]*b+this.coffs[5]*E+this.coffs[8]*D,M}multiplyXYZ(v,M,b,E){return(E=E||new $).x=this.coffs[0]*v+this.coffs[1]*M+this.coffs[2]*b,E.y=this.coffs[3]*v+this.coffs[4]*M+this.coffs[5]*b,E.z=this.coffs[6]*v+this.coffs[7]*M+this.coffs[8]*b,E}multiplyXYZtoXYZ(v,M){const b=v.x,E=v.y,D=v.z;return M.x=this.coffs[0]*b+this.coffs[1]*E+this.coffs[2]*D,M.y=this.coffs[3]*b+this.coffs[4]*E+this.coffs[5]*D,M.z=this.coffs[6]*b+this.coffs[7]*E+this.coffs[8]*D,M}multiplyXY(v,M,b){return(b=b||new $).x=this.coffs[0]*v+this.coffs[1]*M,b.y=this.coffs[3]*v+this.coffs[4]*M,b.z=this.coffs[6]*v+this.coffs[7]*M,b}originPlusMatrixTimesXY(v,M,b,E){return Q.create(v.x+this.coffs[0]*M+this.coffs[1]*b,v.y+this.coffs[3]*M+this.coffs[4]*b,v.z+this.coffs[6]*M+this.coffs[7]*b,E)}multiplyVectorInPlace(v){const M=v.x,b=v.y,E=v.z;v.x=this.coffs[0]*M+this.coffs[1]*b+this.coffs[2]*E,v.y=this.coffs[3]*M+this.coffs[4]*b+this.coffs[5]*E,v.z=this.coffs[6]*M+this.coffs[7]*b+this.coffs[8]*E}multiplyTransposeVectorInPlace(v){const M=v.x,b=v.y,E=v.z;v.x=this.coffs[0]*M+this.coffs[3]*b+this.coffs[6]*E,v.y=this.coffs[1]*M+this.coffs[4]*b+this.coffs[7]*E,v.z=this.coffs[2]*M+this.coffs[5]*b+this.coffs[8]*E}multiplyTransposeXYZ(v,M,b,E){return(E=E||new $).x=this.coffs[0]*v+this.coffs[3]*M+this.coffs[6]*b,E.y=this.coffs[1]*v+this.coffs[4]*M+this.coffs[7]*b,E.z=this.coffs[2]*v+this.coffs[5]*M+this.coffs[8]*b,E}multiplyInverse(v,M){if(this.computeCachedInverse(!0),this.inverseCoffs){const b=v.x,E=v.y,D=v.z;return $.create(this.inverseCoffs[0]*b+this.inverseCoffs[1]*E+this.inverseCoffs[2]*D,this.inverseCoffs[3]*b+this.inverseCoffs[4]*E+this.inverseCoffs[5]*D,this.inverseCoffs[6]*b+this.inverseCoffs[7]*E+this.inverseCoffs[8]*D,M)}}multiplyInverseTranspose(v,M){if(this.computeCachedInverse(!0),this.inverseCoffs){const b=v.x,E=v.y,D=v.z;return $.create(this.inverseCoffs[0]*b+this.inverseCoffs[3]*E+this.inverseCoffs[6]*D,this.inverseCoffs[1]*b+this.inverseCoffs[4]*E+this.inverseCoffs[7]*D,this.inverseCoffs[2]*b+this.inverseCoffs[5]*E+this.inverseCoffs[8]*D,M)}}multiplyInverseXYZAsVector3d(v,M,b,E){if(this.computeCachedInverse(!0),this.inverseCoffs)return $.create(this.inverseCoffs[0]*v+this.inverseCoffs[1]*M+this.inverseCoffs[2]*b,this.inverseCoffs[3]*v+this.inverseCoffs[4]*M+this.inverseCoffs[5]*b,this.inverseCoffs[6]*v+this.inverseCoffs[7]*M+this.inverseCoffs[8]*b,E)}multiplyInverseXYZW(v,M,b,E,D){if(this.computeCachedInverse(!0),this.inverseCoffs)return Dt.create(this.inverseCoffs[0]*v+this.inverseCoffs[1]*M+this.inverseCoffs[2]*b,this.inverseCoffs[3]*v+this.inverseCoffs[4]*M+this.inverseCoffs[5]*b,this.inverseCoffs[6]*v+this.inverseCoffs[7]*M+this.inverseCoffs[8]*b,E,D)}multiplyInverseXYZAsPoint3d(v,M,b,E){if(this.computeCachedInverse(!0),this.inverseCoffs)return Q.create(this.inverseCoffs[0]*v+this.inverseCoffs[1]*M+this.inverseCoffs[2]*b,this.inverseCoffs[3]*v+this.inverseCoffs[4]*M+this.inverseCoffs[5]*b,this.inverseCoffs[6]*v+this.inverseCoffs[7]*M+this.inverseCoffs[8]*b,E)}finishInverseCoffs(v,M,b){M&&b?(this.createInverseCoffsWithZeros(),this.inverseState=V.inverseStored,v(M,b,this.inverseCoffs)):this.inverseState=V.unknown}multiplyMatrixMatrix(v,M){return M=M||new xt,mt.multiplyMatrixMatrix(this.coffs,v.coffs,M.coffs),this.inverseState===V.inverseStored&&v.inverseState===V.inverseStored?M.finishInverseCoffs(((v,M,b)=>mt.multiplyMatrixMatrix(v,M,b)),v.inverseCoffs,this.inverseCoffs):this.inverseState===V.singular||v.inverseState===V.singular?M.inverseState=V.singular:M.inverseState=V.unknown,M}multiplyMatrixMatrixInverse(v,M){if(v.computeCachedInverse(!0))return M=M||new xt,mt.multiplyMatrixMatrix(this.coffs,v.inverseCoffs,xt._productBuffer),this.inverseState===V.inverseStored?M.finishInverseCoffs(((v,M,b)=>mt.multiplyMatrixMatrix(v,M,b)),v.coffs,this.inverseCoffs):M.inverseState=V.unknown,mt.copy(xt._productBuffer,M.coffs),M}multiplyMatrixInverseMatrix(v,M){if(this.computeCachedInverse(!0))return M=M||new xt,mt.multiplyMatrixMatrix(this.inverseCoffs,v.coffs,xt._productBuffer),v.inverseState===V.inverseStored?M.finishInverseCoffs(((v,M,b)=>mt.multiplyMatrixMatrix(v,M,b)),v.inverseCoffs,this.coffs):M.inverseState=V.unknown,mt.copy(xt._productBuffer,M.coffs),M}multiplyMatrixMatrixTranspose(v,M){return M=M||new xt,mt.multiplyMatrixMatrixTranspose(this.coffs,v.coffs,M.coffs),this.inverseState===V.inverseStored&&v.inverseState===V.inverseStored?M.finishInverseCoffs(((v,M,b)=>mt.multiplyMatrixTransposeMatrix(v,M,b)),v.inverseCoffs,this.inverseCoffs):this.inverseState===V.singular||v.inverseState===V.singular?M.inverseState=V.singular:M.inverseState=V.unknown,M}multiplyMatrixTransposeMatrix(v,M){return M=M||new xt,mt.multiplyMatrixTransposeMatrix(this.coffs,v.coffs,M.coffs),this.inverseState===V.inverseStored&&v.inverseState===V.inverseStored?M.finishInverseCoffs(((v,M,b)=>mt.multiplyMatrixMatrixTranspose(v,M,b)),v.inverseCoffs,this.inverseCoffs):this.inverseState===V.singular||v.inverseState===V.singular?M.inverseState=V.singular:M.inverseState=V.unknown,M}multiplyMatrixTransform(v,M){return M?(this.multiplyXYZtoXYZ(v.origin,M.origin),this.multiplyMatrixMatrix(v.matrix,M.matrix),M):pt.createRefs(this.multiplyXYZ(v.origin.x,v.origin.y,v.origin.z),this.multiplyMatrixMatrix(v.matrix))}transpose(v){return v||(v=new xt),mt.copyTransposed(this.coffs,v.coffs),void 0!==this.inverseCoffs?(v.inverseState=V.inverseStored,v.inverseCoffs=mt.copyTransposed(this.inverseCoffs,v.inverseCoffs)):(v.inverseState=this.inverseState,v.inverseCoffs=void 0),v}transposeInPlace(){mt.transposeInPlace(this.coffs),this.inverseCoffs&&mt.transposeInPlace(this.inverseCoffs)}inverse(v){if(this.computeCachedInverse(!0))return v===this?(mt.copy(this.coffs,xt._productBuffer),mt.copy(this.inverseCoffs,this.coffs),mt.copy(xt._productBuffer,this.inverseCoffs),v):(void 0===v&&(v=xt.createIdentity()),v.createInverseCoffsWithZeros(),mt.copy(this.coffs,v.inverseCoffs),mt.copy(this.inverseCoffs,v.coffs),v.inverseState=this.inverseState,v)}static rowColumnDot(v,M,b,E){return v[M]*b[E]+v[M+1]*b[E+3]+v[M+2]*b[E+6]}static indexedRowCrossProduct(v,M,b,E,D){E[D]=v[M+1]*v[b+2]-v[M+2]*v[b+1],E[D+3]=v[M+2]*v[b]-v[M]*v[b+2],E[D+6]=v[M]*v[b+1]-v[M+1]*v[b]}indexedColumnCrossProductInPlace(v,M,b){const E=this.coffs;E[b]=E[v+3]*E[M+6]-E[v+6]*E[M+3],E[b+3]=E[v+6]*E[M]-E[v]*E[M+6],E[b+6]=E[v]*E[M+3]-E[v+3]*E[M]}axisOrderCrossProductsInPlace(v){switch(v){case z.XYZ:this.indexedColumnCrossProductInPlace(0,1,2),this.indexedColumnCrossProductInPlace(2,0,1);break;case z.YZX:this.indexedColumnCrossProductInPlace(1,2,0),this.indexedColumnCrossProductInPlace(0,1,2);break;case z.ZXY:this.indexedColumnCrossProductInPlace(2,0,1),this.indexedColumnCrossProductInPlace(1,2,0);break;case z.XZY:this.indexedColumnCrossProductInPlace(0,2,1),this.indexedColumnCrossProductInPlace(1,0,2);break;case z.YXZ:this.indexedColumnCrossProductInPlace(1,0,2),this.indexedColumnCrossProductInPlace(2,1,0);break;case z.ZYX:this.indexedColumnCrossProductInPlace(2,1,0),this.indexedColumnCrossProductInPlace(0,2,1)}}normalizeColumnsInPlace(v){const M=this.columnXMagnitude(),b=this.columnYMagnitude(),E=this.columnZMagnitude();return v&&v.set(M,b,E),!(K.isSmallMetricDistance(M)||K.isSmallMetricDistance(b)||K.isSmallMetricDistance(E)||(this.scaleColumns(1/M,1/b,1/E,this),0))}normalizeRowsInPlace(v){const M=this.rowXMagnitude(),b=this.rowYMagnitude(),E=this.rowZMagnitude();return v&&v.set(M,b,E),!(K.isSmallMetricDistance(M)||K.isSmallMetricDistance(b)||K.isSmallMetricDistance(E)||(this.scaleRows(1/M,1/b,1/E,this),0))}isSingular(){return!this.computeCachedInverse(!0)}markSingular(){this.inverseState=V.singular}computeCachedInverse(v){if(v&&xt.useCachedInverse&&this.inverseState!==V.unknown)return xt.numUseCache++,this.inverseState===V.inverseStored;this.inverseState=V.unknown,this.createInverseCoffsWithZeros();const M=this.coffs,b=this.inverseCoffs;xt.indexedRowCrossProduct(M,3,6,b,0),xt.indexedRowCrossProduct(M,6,0,b,1),xt.indexedRowCrossProduct(M,0,3,b,2),xt.numComputeCache++;const E=xt.rowColumnDot(M,0,b,0);if(0===E)return this.inverseState=V.singular,this.inverseCoffs=void 0,!1;const D=1/E;for(let X=0;X<9;X++)b[X]*=D;return this.inverseState=V.inverseStored,!0}static flatIndexOf(v,M){return 3*K.cyclic3dAxis(v)+K.cyclic3dAxis(M)}indexedColumnWithWeight(v,M,b){return v=K.cyclic3dAxis(v),Dt.create(this.coffs[v],this.coffs[v+3],this.coffs[v+6],M,b)}at(v,M){return this.coffs[xt.flatIndexOf(v,M)]}setAt(v,M,b){this.coffs[xt.flatIndexOf(v,M)]=b,this.inverseState=V.unknown}scale(v,M){return xt.createRowValues(this.coffs[0]*v,this.coffs[1]*v,this.coffs[2]*v,this.coffs[3]*v,this.coffs[4]*v,this.coffs[5]*v,this.coffs[6]*v,this.coffs[7]*v,this.coffs[8]*v,M)}scaleColumns(v,M,b,E){return xt.createRowValues(this.coffs[0]*v,this.coffs[1]*M,this.coffs[2]*b,this.coffs[3]*v,this.coffs[4]*M,this.coffs[5]*b,this.coffs[6]*v,this.coffs[7]*M,this.coffs[8]*b,E)}scaleColumnsInPlace(v,M,b){if(this.coffs[0]*=v,this.coffs[1]*=M,this.coffs[2]*=b,this.coffs[3]*=v,this.coffs[4]*=M,this.coffs[5]*=b,this.coffs[6]*=v,this.coffs[7]*=M,this.coffs[8]*=b,this.inverseState===V.inverseStored&&void 0!==this.inverseCoffs){const E=K.conditionalDivideFraction(1,v),D=K.conditionalDivideFraction(1,M),X=K.conditionalDivideFraction(1,b);void 0!==E&&void 0!==D&&void 0!==X?(this.inverseCoffs[0]*=E,this.inverseCoffs[1]*=E,this.inverseCoffs[2]*=E,this.inverseCoffs[3]*=D,this.inverseCoffs[4]*=D,this.inverseCoffs[5]*=D,this.inverseCoffs[6]*=X,this.inverseCoffs[7]*=X,this.inverseCoffs[8]*=X):this.inverseState=V.singular}}scaleRows(v,M,b,E){return xt.createRowValues(this.coffs[0]*v,this.coffs[1]*v,this.coffs[2]*v,this.coffs[3]*M,this.coffs[4]*M,this.coffs[5]*M,this.coffs[6]*b,this.coffs[7]*b,this.coffs[8]*b,E)}scaleRowsInPlace(v,M,b){if(this.coffs[0]*=v,this.coffs[1]*=v,this.coffs[2]*=v,this.coffs[3]*=M,this.coffs[4]*=M,this.coffs[5]*=M,this.coffs[6]*=b,this.coffs[7]*=b,this.coffs[8]*=b,this.inverseState===V.inverseStored&&void 0!==this.inverseCoffs){const E=K.conditionalDivideFraction(1,v),D=K.conditionalDivideFraction(1,M),X=K.conditionalDivideFraction(1,b);void 0!==E&&void 0!==D&&void 0!==X?(this.inverseCoffs[0]*=E,this.inverseCoffs[1]*=D,this.inverseCoffs[2]*=X,this.inverseCoffs[3]*=E,this.inverseCoffs[4]*=D,this.inverseCoffs[5]*=X,this.inverseCoffs[6]*=E,this.inverseCoffs[7]*=D,this.inverseCoffs[8]*=X):this.inverseState=V.singular}}addScaledInPlace(v,M){for(let b=0;b<9;b++)this.coffs[b]+=M*v.coffs[b];this.inverseState=V.unknown}addScaledOuterProductInPlace(v,M,b){this.coffs[0]+=b*v.x*M.x,this.coffs[1]+=b*v.x*M.y,this.coffs[2]+=b*v.x*M.z,this.coffs[3]+=b*v.y*M.x,this.coffs[4]+=b*v.y*M.y,this.coffs[5]+=b*v.y*M.z,this.coffs[6]+=b*v.z*M.x,this.coffs[7]+=b*v.z*M.y,this.coffs[8]+=b*v.z*M.z,this.inverseState=V.unknown}static createRigidViewAxesZTowardsEye(v,M,b,E){E=xt.createIdentity(E);const D=K.hypotenuseXY(v,M);if(K.isSmallMetricDistance(D))b<0&&E.scaleColumnsInPlace(1,-1,-1);else{const X=v/D,z=M/D;if(E.setRowValues(-z,0,X,X,0,z,0,1,0),0!==b){const X=K.hypotenuseXYZ(v,M,b),z=b/X,R=D/X;E.applyGivensColumnOp(1,2,R,-z)}}return E}determinant(){return this.coffs[0]*this.coffs[4]*this.coffs[8]-this.coffs[0]*this.coffs[5]*this.coffs[7]-this.coffs[1]*this.coffs[3]*this.coffs[8]+this.coffs[1]*this.coffs[5]*this.coffs[6]+this.coffs[2]*this.coffs[3]*this.coffs[7]-this.coffs[2]*this.coffs[4]*this.coffs[6]}conditionNumber(){const v=Math.abs(this.determinant()),M=K.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])+K.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])+K.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8]);return K.safeDivideFraction(v,M,0)}sumSquares(){let v=0;for(let M=0;M<9;M++)v+=this.coffs[M]*this.coffs[M];return v}sumDiagonalSquares(){let v=0;for(let M=0;M<9;M+=4)v+=this.coffs[M]*this.coffs[M];return v}sumDiagonal(){return this.coffs[0]+this.coffs[4]+this.coffs[8]}maxAbs(){let v=0;for(let M=0;M<9;M++)v=Math.max(v,Math.abs(this.coffs[M]));return v}maxDiff(v){let M=0;for(let b=0;b<9;b++)M=Math.max(M,Math.abs(this.coffs[b]-v.coffs[b]));return M}get isIdentity(){return this.maxDiff(xt.identity)<K.smallAngleRadians}get isDiagonal(){const v=this.sumSquares(),M=this.sumDiagonalSquares(),b=Math.abs(v-M);return Math.sqrt(b)<=K.smallAngleRadians*(1+Math.sqrt(v))}sumSkewSquares(){return K.hypotenuseSquaredXYZ(this.coffs[1]-this.coffs[3],this.coffs[2]-this.coffs[6],this.coffs[5]-this.coffs[7])}isSymmetric(){const v=this.sumSkewSquares();return Math.sqrt(v)<=K.smallAngleRadians*(1+Math.sqrt(this.sumSquares()))}get hasCachedInverse(){return this.inverseState===V.inverseStored&&void 0!==this.inverseCoffs}get isUpperTriangular(){const v=this.sumSquares(),M=K.hypotenuseSquaredXYZ(this.coffs[3],this.coffs[6],this.coffs[7]);return Math.sqrt(M)<=K.smallAngleRadians*(1+Math.sqrt(v))}get isLowerTriangular(){const v=this.sumSquares(),M=K.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[2],this.coffs[5]);return Math.sqrt(M)<=K.smallAngleRadians*(1+Math.sqrt(v))}sameDiagonalScale(){const v=this.sumSquares(),M=this.sumDiagonalSquares(),b=Math.abs(v-M);if(Math.sqrt(b)<=K.smallAngleRadians*(1+Math.sqrt(v))&&K.isSameCoordinate(this.coffs[0],this.coffs[4])&&K.isSameCoordinate(this.coffs[0],this.coffs[8]))return this.coffs[0]}testPerpendicularUnitRowsAndColumns(){return this.multiplyMatrixMatrixTranspose(this).isIdentity}isRigid(v=!1){return this.testPerpendicularUnitRowsAndColumns()&&(v||this.determinant()>0)}factorRigidWithSignedScale(v){const M=this.multiplyMatrixMatrixTranspose(this).sameDiagonalScale();if(void 0===M||M<=0)return;const b=this.determinant()>0?Math.sqrt(M):-Math.sqrt(M),E=1/b;return{rigidAxes:this.scaleColumns(E,E,E,v),scale:b}}get isSignedPermutation(){let v=0;for(let M=0;M<3;M++)for(let b=0;b<3;b++){const E=this.at(M,b);if(0===E);else{if(1!==E&&-1!==E)return!1;if(v++,0!==this.at(M+1,b)||0!==this.at(M+2,b)||0!==this.at(M,b+1)||0!==this.at(M,b+2))return!1}}return 3===v}makeRigid(v=z.XYZ){const M=this.maxAbs();if(K.isSmallMetricDistance(M))return!1;const b=1/M;return this.scaleColumnsInPlace(b,b,b),this.axisOrderCrossProductsInPlace(v),this.normalizeColumnsInPlace()}static createRigidFromMatrix3d(v,M=z.XYZ,b){if((b=v.clone(b)).makeRigid(M))return b}static createFromQuaternion(v){const M=v.x*v.x,b=v.y*v.y,E=v.z*v.z,D=v.w*v.w,X=M+b+E+D;if(0===X)return xt.createIdentity();{const z=1/X;return xt.createRowValues(z*(D+M-b-E),2*z*(v.w*v.z+v.x*v.y),2*z*(v.x*v.z-v.w*v.y),2*z*(v.x*v.y-v.w*v.z),z*(D-M+b-E),2*z*(v.w*v.x+v.y*v.z),2*z*(v.x*v.z+v.w*v.y),2*z*(v.y*v.z-v.w*v.x),z*(D-M-b+E))}}static computeQuatTerm(v,M,b,E){let D;return E>.5?(D=.5*Math.sqrt(E),M*v<0&&(D=-D)):D=v*b,D}toQuaternion(){const v=Dt.createZero(),M=[[this.coffs[0],this.coffs[3],this.coffs[6]],[this.coffs[1],this.coffs[4],this.coffs[7]],[this.coffs[2],this.coffs[5],this.coffs[8]]],b=M[0][0],E=M[1][1],D=M[2][2],X=[];let z;X[0]=1+b-E-D,X[1]=1-b+E-D,X[2]=1-b-E+D,X[3]=1+b+E+D;let R=0;for(let O=1;O<=3;O++)X[O]>X[R]&&(R=O);return 0===R?(v.x=.5*Math.sqrt(X[0]),z=1/(4*v.x),v.y=xt.computeQuatTerm(M[0][1]+M[1][0],v.x,z,X[1]),v.z=xt.computeQuatTerm(M[0][2]+M[2][0],v.x,z,X[2]),v.w=xt.computeQuatTerm(M[2][1]-M[1][2],v.x,z,X[3])):1===R?(v.y=.5*Math.sqrt(X[1]),z=1/(4*v.y),v.x=xt.computeQuatTerm(M[0][1]+M[1][0],v.y,z,X[0]),v.z=xt.computeQuatTerm(M[1][2]+M[2][1],v.y,z,X[2]),v.w=xt.computeQuatTerm(M[0][2]-M[2][0],v.y,z,X[3])):2===R?(v.z=.5*Math.sqrt(X[2]),z=1/(4*v.z),v.x=xt.computeQuatTerm(M[0][2]+M[2][0],v.z,z,X[0]),v.y=xt.computeQuatTerm(M[1][2]+M[2][1],v.z,z,X[1]),v.w=xt.computeQuatTerm(M[1][0]-M[0][1],v.z,z,X[3])):(v.w=.5*Math.sqrt(X[3]),z=1/(4*v.w),v.x=xt.computeQuatTerm(M[2][1]-M[1][2],v.w,z,X[0]),v.y=xt.computeQuatTerm(M[0][2]-M[2][0],v.w,z,X[1]),v.z=xt.computeQuatTerm(M[1][0]-M[0][1],v.w,z,X[2])),v}}xt.useCachedInverse=!0,xt.numUseCache=0,xt.numComputeCache=0,xt._productBuffer=new Float64Array(9);class yt extends tt{constructor(v,M){super(),this._origin=v,this._normal=M}static _create(v,M,b,E,D,X){return new yt(Q.create(v,M,b),$.create(E,D,X))}static createXYPlane(v){return v?yt._create(v.x,v.y,v.z,0,0,1):yt._create(0,0,0,0,0,1)}static createYZPlane(v){return v?yt._create(v.x,v.y,v.z,1,0,0):yt._create(0,0,0,1,0,0)}static createZXPlane(v){return v?yt._create(v.x,v.y,v.z,0,1,0):yt._create(0,0,0,0,1,0)}static create(v,M,b){if(b){if(void 0===M.normalize(b._normal))return;return v.clone(b._origin),b}const E=M.normalize();if(void 0!==E)return new yt(v.clone(),E)}static createFrom(v,M){if(v instanceof yt)return v.clone(M);if(M){if(void 0===v.getUnitNormal(M._normal))return;return v.getAnyPointOnPlane(M._origin),M}const b=v.getUnitNormal();if(void 0===b)return;const E=v.getAnyPointOnPlane();return new yt(E,b)}static createXYZUVW(v,M,b,E,D,X,z){const R=K.hypotenuseXYZ(E,D,X);if(!(R<K.smallMetricDistance))return z?(z._origin.set(v,M,b),z._normal.set(E/R,D/R,X/R),z):new yt(Q.create(v,M,b),$.create(E/R,D/R,X/R))}static createOriginAndTargetXY(v,M,b){const E=M.x-v.x,D=M.y-v.y;return this.createXYZUVW(v.x,v.y,0,D,-E,0,b)}static createXYAngle(v,M,b,E){return E?(E._origin.set(v,M,0),E._normal.set(b.cos(),b.sin(),0),E):new yt(Q.create(v,M,0),$.create(b.cos(),b.sin()))}static createPointPointVectorInPlane(v,M,b){const E=b.crossProductStartEnd(v,M);if(E.tryNormalizeInPlace())return new yt(v,E)}static createOriginAndTargets(v,M,b){const E=v.crossProductToPoints(M,b);if(E.tryNormalizeInPlace())return new yt(v,E)}static createOriginAndVectors(v,M,b){const E=M.crossProduct(b);if(E.tryNormalizeInPlace())return new yt(v,E)}isAlmostEqual(v){return this._origin.isAlmostEqual(v._origin)&&this._normal.isAlmostEqual(v._normal)}setFromJSON(v){v?(this._origin.setFromJSON(v.origin),this._normal.setFromJSON(v.normal)):(this._origin.set(0,0,0),this._normal.set(0,0,1))}toJSON(){return{origin:this._origin.toJSON(),normal:this._normal.toJSON()}}static fromJSON(v){const M=yt.createXYPlane();return M.setFromJSON(v),M}getOriginRef(){return this._origin}getNormalRef(){return this._normal}getLocalToWorld(){const v=xt.createRigidHeadsUp(this._normal,z.ZXY);return pt.createRefs(this._origin.clone(),v)}getProjectionToPlane(){const v=xt.createIdentity();return v.addScaledOuterProductInPlace(this._normal,this._normal,-1),v.markSingular(),pt.createFixedPointAndMatrix(this._origin,v)}set(v,M){this._origin.setFrom(v),this._normal.setFrom(M)}clone(v){return v?(v.set(this._origin,this._normal),v):new yt(this._origin.clone(),this._normal.clone())}cloneTransformed(v,M=!1){const b=this.clone();if(M){if(v.multiplyInversePoint3d(b._origin,b._origin),void 0!==v.matrix.multiplyTransposeVector(b._normal,b._normal)&&b._normal.normalizeInPlace())return b}else if(v.multiplyPoint3d(b._origin,b._origin),void 0!==v.matrix.multiplyInverseTranspose(b._normal,b._normal)&&b._normal.normalizeInPlace())return b}setFrom(v){this.set(v._origin,v._normal)}altitude(v){return this._normal.dotProductStartEnd(this._origin,v)}altitudeXY(v,M){return(v-this._origin.x)*this._normal.x+(M-this._origin.y)*this._normal.y}normalX(){return this._normal.x}normalY(){return this._normal.y}normalZ(){return this._normal.z}getUnitNormal(v){return this._normal.clone(v)}getAnyPointOnPlane(v){return this._origin.clone(v)}weightedAltitude(v){return this._normal.dotProductStart3dEnd4d(this._origin,v)}altitudeToPoint(v,M){return this._origin.plusScaled(this._normal,v,M)}velocityXYZ(v,M,b){return this._normal.dotProductXYZ(v,M,b)}velocity(v){return this._normal.dotProduct(v)}altitudeXYZ(v,M,b){return this._normal.dotProductStartEndXYZ(this._origin,v,M,b)}altitudeXYZW(v,M,b,E){return this._normal.dotProductStartEndXYZW(this._origin,v,M,b,E)}projectPointToPlane(v,M){return v.plusScaled(this._normal,-this._normal.dotProductStartEnd(this._origin,v),M)}isPointInPlane(v,M=K.smallMetricDistance){const b=this._normal.dotProductStartEnd(this._origin,v);return Math.abs(b)<=M}}function _t(v,M){if(v)return v.clone(M)}!function(v){v[v.isolated=0]="isolated",v[v.isolatedAtVertex=1]="isolatedAtVertex",v[v.intervalStart=10]="intervalStart",v[v.intervalInterior=11]="intervalInterior",v[v.intervalEnd=12]="intervalEnd"}(L||(L={})),function(v){v[v.error=0]="error",v[v.success=1]="success",v[v.stoppedAtBoundary=2]="stoppedAtBoundary"}(U||(U={}));class vt{constructor(){this.pointQ=Q.createZero(),this.fraction=0,this.point=Q.createZero(),this.a=0}setIntervalRole(v){this.intervalRole=v}captureFraction1Point1(v,M){this.fraction1=v,this.point1=M}get hasFraction1(){return void 0!==this.fraction1}get isIsolated(){return void 0===this.intervalRole||this.intervalRole===L.isolated||this.intervalRole===L.isolatedAtVertex}get fractionDelta(){return void 0!==this.fraction1?this.fraction1-this.fraction:0}collapseToEnd(){void 0!==this.fraction1&&(this.fraction=this.fraction1),this.point1&&(this.point=this.point1),this.collapseToStart()}collapseToStart(){this.fraction1=void 0,this.point1=void 0}clone(v){return v===this||((v=v||new vt).curve=this.curve,v.fraction=this.fraction,v.fraction1=this.fraction1,v.point1=this.point1,v.point.setFromPoint3d(this.point),v.vectorInCurveLocationDetail=_t(this.vectorInCurveLocationDetail,v.vectorInCurveLocationDetail),v.a=this.a,v.curveSearchStatus=this.curveSearchStatus),v}setFP(v,M,b,E=0){this.fraction=v,this.point.setFrom(M),this.vectorInCurveLocationDetail=_t(b,this.vectorInCurveLocationDetail),this.a=E}setFR(v,M,b=0){return this.setFP(v,M.origin,M.direction,b)}setCurve(v){this.curve=v}setDistanceTo(v){this.a=this.point.distance(v)}static create(v,M){return(M=M||new vt).curve=v,M}static createCurveFractionPoint(v,M,b,E){return(E=E||new vt).curve=v,E.fraction=M,E.point.setFromPoint3d(b),E.vectorInCurveLocationDetail=void 0,E.a=0,E.curveSearchStatus=void 0,E}static createRayFractionPoint(v,M,b,E){return(E=E||new vt).fraction=M,E.ray=v,E.point.setFromPoint3d(b),E}static createCurveFractionPointDistanceCurveSearchStatus(v,M,b,E,D,X){return(X=X||new vt).curve=v,X.fraction=M,X.point.setFromPoint3d(b),X.vectorInCurveLocationDetail=void 0,X.a=E,X.curveSearchStatus=D,X}static createConditionalMoveSignedDistance(v,M,b,E,D,X){let z=D,R=U.success;return v||K.isIn01(E)||(E<0?(z=-M.curveLengthBetweenFractions(b,0),E=0,R=U.stoppedAtBoundary):E>1&&(E=1,z=M.curveLengthBetweenFractions(b,1),R=U.stoppedAtBoundary)),(X=X||new vt).curve=M,X.fraction=E,X.point=M.fractionToPoint(E,X.point),X.vectorInCurveLocationDetail=void 0,X.a=z,X.curveSearchStatus=R,X}static createCurveEvaluatedFraction(v,M,b){return(b=b||new vt).curve=v,b.fraction=M,b.point=v.fractionToPoint(M),b.vectorInCurveLocationDetail=void 0,b.curveSearchStatus=void 0,b.a=0,b}static createCurveEvaluatedFractionPointAndDerivative(v,M,b){(b=b||new vt).curve=v,b.fraction=M;const E=v.fractionToPointAndDerivative(M);return b.point=E.origin,b.vectorInCurveLocationDetail=E.direction,b.curveSearchStatus=void 0,b.a=0,b}static createCurveEvaluatedFractionFraction(v,M,b,E){return(E=E||new vt).curve=v,E.fraction=M,E.point=v.fractionToPoint(M),E.fraction1=b,E.point1=v.fractionToPoint(b),E.vectorInCurveLocationDetail=void 0,E.curveSearchStatus=void 0,E.a=0,E}static createCurveFractionPointDistance(v,M,b,E,D){return(D=D||new vt).curve=v,D.fraction=M,D.point.setFromPoint3d(b),D.vectorInCurveLocationDetail=void 0,D.a=E,D.curveSearchStatus=void 0,D}updateIfCloserCurveFractionPointDistance(v,M,b,E){return!(this.a<E||(vt.createCurveFractionPointDistance(v,M,b,E,this),0))}swapFractionsAndPoints(){if(void 0!==this.fraction1){const v=this.fraction;this.fraction=this.fraction1,this.fraction1=v}if(void 0!==this.point1){const v=this.point;this.point=this.point1,this.point1=v}}inverseInterpolateFraction(v,M=0){const b=K.inverseInterpolate01(this.fraction,this.fraction1,v);return void 0===b?M:b}static chooseSmallerA(v,M){return v?M?v.a<=M.a?v:M:v:M}isSameCurveAndFraction(v){return this.curve===v.curve&&K.isAlmostEqualNumber(this.fraction,v.fraction)}}!function(v){v[v.Intersection=0]="Intersection",v[v.PerpendicularChord=1]="PerpendicularChord",v[v.CoincidentGeometry=2]="CoincidentGeometry",v[v.ParallelGeometry=3]="ParallelGeometry"}(Sr||(Sr={}));class Pt{constructor(v,M){this.detailA=v||new vt,this.detailB=M||new vt}static createCapture(v,M,b){return(b=b||new Pt).detailA=v,b.detailB=M,b}static createCaptureOptionalReverse(v,M,b,E){return(E=E||new Pt).detailA=v,E.detailB=M,E}clone(v){return(v=v||new Pt).detailA=this.detailA.clone(),v.detailB=this.detailB.clone(),v.approachType=this.approachType,v}swapDetails(){const v=this.detailA;this.detailA=this.detailB,this.detailB=v}static removeAdjacentDuplicates(v,M=0){return v.flatMap(((v,b,E)=>b>=M&&b>0&&!v.detailA.hasFraction1&&!v.detailB.hasFraction1&&v.detailA.isSameCurveAndFraction(E[b-1].detailA)&&v.detailB.isSameCurveAndFraction(E[b-1].detailB)?[]:[v]))}}class It{get startDegrees(){return W.radiansToDegrees(this._radians0)}get endDegrees(){return W.radiansToDegrees(this._radians1)}get sweepDegrees(){return W.radiansToDegrees(this._radians1-this._radians0)}get startRadians(){return this._radians0}get endRadians(){return this._radians1}get sweepRadians(){return this._radians1-this._radians0}get startAngle(){return W.createRadians(this._radians0)}get endAngle(){return W.createRadians(this._radians1)}static create(v){return v instanceof It?v.clone():v instanceof W?new It(0,v.radians):It.create360()}constructor(v=0,M=0){this._radians0=v,this._radians1=M}setStartEndRadians(v=0,M=2*Math.PI){const b=M-v;W.isFullCircleRadians(b)&&(M=v+(b>0?2:-2)*Math.PI),this._radians0=v,this._radians1=M}setStartEndDegrees(v=0,M=360){this.setStartEndRadians(W.degreesToRadians(v),W.degreesToRadians(M))}static createStartEndRadians(v=0,M=2*Math.PI,b){return(b=b||new It).setStartEndRadians(v,M),b}cloneMinusRadians(v){return new It(this._radians0-v,this._radians1-v)}static createStartEndDegrees(v=0,M=360,b){return It.createStartEndRadians(W.degreesToRadians(v),W.degreesToRadians(M),b)}static createStartEnd(v,M,b){return(b=b||new It).setStartEndRadians(v.radians,M.radians),b}static createStartSweepRadians(v=0,M=Math.PI,b){return(b=b||new It).setStartEndRadians(v,v+M),b}static createStartSweepDegrees(v=0,M=360,b){return It.createStartEndRadians(W.degreesToRadians(v),W.degreesToRadians(v+M),b)}static createStartSweep(v,M,b){return It.createStartSweepRadians(v.radians,M.radians,b)}interpolate(v,M){return new It(K.interpolate(this._radians0,v,M._radians0),K.interpolate(this._radians1,v,M._radians1))}setFrom(v){this._radians0=v._radians0,this._radians1=v._radians1}static create360(v){return new It(v=v||0,v+2*Math.PI)}static createFullLatitude(){return It.createStartEndRadians(-.5*Math.PI,.5*Math.PI)}reverseInPlace(){const v=this._radians0;this._radians0=this._radians1,this._radians1=v}cloneComplement(v=!1,M){const b=this.sweepRadians>=0?2:-2;return v?It.createStartEndRadians(this.startRadians,this.endRadians-b*Math.PI,M):It.createStartEndRadians(this.endRadians,this.startRadians+b*Math.PI,M)}capLatitudeInPlace(){const v=.5*Math.PI;this._radians0=K.clampToStartEnd(this._radians0,-v,v),this._radians1=K.clampToStartEnd(this._radians1,-v,v)}get isCCW(){return this._radians1>=this._radians0}get isFullCircle(){return W.isFullCircleRadians(this.sweepRadians)}get isFullLatitudeSweep(){const v=.5*Math.PI;return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,-v)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1,v)}clone(){return new It(this._radians0,this._radians1)}fractionToRadians(v){return v<.5?this._radians0+v*(this._radians1-this._radians0):this._radians1+(v-1)*(this._radians1-this._radians0)}fractionToAngle(v){return W.createRadians(this.fractionToRadians(v))}fractionPeriod(){return K.safeDivideFraction(2*Math.PI,Math.abs(this._radians1-this._radians0),1)}angleToUnboundedFraction(v){return K.safeDivideFraction(v.radians-this._radians0,this._radians1-this._radians0,1)}static radiansToPositivePeriodicFractionStartEnd(v,M,b,E=0){if(W.isAlmostEqualRadiansAllowPeriodShift(v,M))return 0;if(W.isAlmostEqualRadiansAllowPeriodShift(v,b))return 1;const D=b-M,X=v-M;if(D>0){const v=W.adjustRadians0To2Pi(X);return K.safeDivideFraction(v,D,E)}const z=W.adjustRadians0To2Pi(-X);return K.safeDivideFraction(z,-D,E)}radiansToPositivePeriodicFraction(v,M=0){return It.radiansToPositivePeriodicFractionStartEnd(v,this._radians0,this._radians1,M)}angleToPositivePeriodicFraction(v){return this.radiansToPositivePeriodicFraction(v.radians)}radiansArrayToPositivePeriodicFractions(v){const M=v.length;for(let b=0;b<M;b++)v.reassign(b,this.radiansToPositivePeriodicFraction(v.atUncheckedIndex(b)))}radiansToSignedPeriodicFraction(v){if(W.isAlmostEqualRadiansAllowPeriodShift(v,this._radians0))return 0;if(W.isAlmostEqualRadiansAllowPeriodShift(v,this._radians1))return 1;const M=this._radians1-this._radians0,b=v-this._radians0-.5*M;if(M>0){const v=W.adjustRadiansMinusPiPlusPi(b);return.5+K.safeDivideFraction(v,M,0)}const E=W.adjustRadiansMinusPiPlusPi(-b);return.5+K.safeDivideFraction(E,-M,0)}angleToSignedPeriodicFraction(v){return this.radiansToSignedPeriodicFraction(v.radians)}static isRadiansInStartEnd(v,M,b,E=!0){return(v-M)*(v-b)<=0||(M===b?E?W.isAlmostEqualRadiansAllowPeriodShift(v,M):W.isAlmostEqualRadiansNoPeriodShift(v,M):!!E&&this.radiansToPositivePeriodicFractionStartEnd(v,M,b,1e3)<=1)}isRadiansInSweep(v,M=!0){return It.isRadiansInStartEnd(v,this.startRadians,this.endRadians,M)}isAngleInSweep(v){return this.isRadiansInSweep(v.radians)}setFromJSON(v){v?v instanceof It?this.setFrom(v):K.isNumberArray(v.degrees,2)?this.setStartEndDegrees(v.degrees[0],v.degrees[1]):K.isNumberArray(v.radians,2)?this.setStartEndRadians(v.radians[0],v.radians[1]):K.isNumberArray(v,2)?this.setStartEndDegrees(v[0],v[1]):this.setStartEndRadians():this.setStartEndRadians()}static fromJSON(v){const M=It.create360();return M.setFromJSON(v),M}toJSON(){return[this.startDegrees,this.endDegrees]}isAlmostEqualAllowPeriodShift(v){return W.isAlmostEqualRadiansAllowPeriodShift(this._radians0,v._radians0)&&W.isAlmostEqualRadiansAllowPeriodShift(this._radians1-this._radians0,v._radians1-v._radians0)}isAlmostEqualNoPeriodShift(v){return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,v._radians0)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1-this._radians0,v._radians1-v._radians0)}isAlmostEqual(v){return this.isAlmostEqualNoPeriodShift(v)}}class At{constructor(v=8,M){this._data=new Float64Array(v),this._inUse=0,this._growthFactor=void 0!==M&&M>=1?M:1.5}copyData(v,M,b){let E=b??0;if(E<0&&(E=0),E>=this._data.length)return{count:0,offset:0};let D=M??v.length;return D>0&&(D>v.length&&(D=v.length),E+D>this._data.length&&(D=this._data.length-E)),D<=0?{count:0,offset:0}:(D===v.length?this._data.set(v,E):v instanceof Float64Array?this._data.set(v.subarray(0,D),E):this._data.set(v.slice(0,D),E),{count:D,offset:E})}static create(v){const M=new At(v.length);return M.copyData(v),M._inUse=v.length,M}static compare(v,M){return v-M}clone(v=!1){const M=new At(v?this.capacity():this._inUse);return M.copyData(this._data,this._inUse),M._inUse=this._inUse,M}get length(){return this._inUse}setAtUncheckedIndex(v,M){this._data[v]=M}move(v,M){this._data[M]=this._data[v]}swap(v,M){const b=this._data[v];this._data[v]=this._data[M],this._data[M]=b}push(v){this.ensureCapacity(this._inUse+1),this._data[this._inUse]=v,this._inUse++}pushArray(v){this.ensureCapacity(this._inUse+v.length),this.copyData(v,v.length,this._inUse),this._inUse+=v.length}pushBlockCopy(v,M){v>=0&&v<this._inUse&&M>0&&v+M<=this._inUse&&(this.ensureCapacity(this._inUse+M),this._data.copyWithin(this._inUse,v,v+M),this._inUse+=M)}clear(){this._inUse=0}capacity(){return this._data.length}ensureCapacity(v,M=!0){if(v>this.capacity()){M&&(v*=this._growthFactor);const b=this._data;this._data=new Float64Array(v),this.copyData(b,this._inUse)}}resize(v,M=0){v>=0&&v<this._inUse?this._inUse=v:v>this._inUse&&(this.ensureCapacity(v,!1),this._data.fill(M,this._inUse),this._inUse=v)}pop(){this._inUse>0&&this._inUse--}atUncheckedIndex(v){return this._data[v]}front(){return this._data[0]}back(){return this._data[this._inUse-1]}reassign(v,M){this._data[v]=M}sort(v=((v,M)=>At.compare(v,M))){for(let M=0;M<this._inUse;M++)for(let b=M+1;b<this._inUse;b++){const E=this._data[M],D=this._data[b];v(E,D)>0&&(this._data[M]=D,this._data[b]=E)}}restrictToInterval(v,M){const b=this._data,E=b.length;let D=0,X=0;for(let z=0;z<E;z++)X=b[z],X>=v&&X<=M&&(b[D++]=X);this._inUse=D}compressAdjacentDuplicates(v=0){const M=this._data,b=this._inUse;if(0===b)return;let E,D=1,X=M[0];for(let z=1;z<b;z++)E=M[z],Math.abs(E-X)>v&&(M[D++]=E,X=E);this._inUse=D}}class St{constructor(v=0,M=0,b=0){this.coffs=[v,M,b]}static solveQuadratic(v,M,b){const E=K.conditionalDivideFraction(M,v),D=K.conditionalDivideFraction(b,v);if(void 0!==E&&void 0!==D){const v=E*E-4*D;if(v>0){const M=Math.sqrt(v);return[.5*(-E-M),.5*(-E+M)]}if(v<0)return;const M=-.5*E;return[M,M]}const X=K.conditionalDivideFraction(-b,M);if(void 0!==X)return[X]}addConstant(v){this.coffs[0]+=v}addSquaredLinearTerm(v,M,b=1){this.coffs[0]+=b*(v*v),this.coffs[1]+=b*(2*v*M),this.coffs[2]+=b*(M*M)}realRoots(){const v=St.solveQuadratic(this.coffs[2],this.coffs[1],this.coffs[0]);if(v&&v.length>1&&v[0]>v[1]){const M=v[0];v[0]=v[1],v[1]=M}return v}evaluate(v){return this.coffs[0]+v*(this.coffs[1]+v*this.coffs[2])}evaluateDerivative(v){return this.coffs[1]+2*v*this.coffs[2]}tryGetVertexFactorization(){const v=K.conditionalDivideFraction(-this.coffs[1],2*this.coffs[2]);if(void 0!==v){const M=this.evaluate(v);return{c:this.coffs[2],x0:v,y0:M}}}static fromRootsAndC2(v,M,b=1){return new St(b*v*M,-b*(v+M),b)}}class wt{static isZero(v){return Math.abs(v)<this._EQN_EPS}static isSmallRatio(v,M,b=1e-9,E=8e-16){return Math.abs(v)<=b||Math.abs(v)<E*Math.abs(M)}static cbrt(v){return v>0?Math.pow(v,1/3):v<0?-Math.pow(-v,1/3):0}static safeDivide(v,M,b,E=0,D){return Math.abs(b)>this._safeDivideFactor*Math.abs(M)?(v[D]=M/b,!0):(v[D]=E,!1)}static checkRootProximity(v,M){return 0===M?v.atUncheckedIndex(M)<v.atUncheckedIndex(M+1):M>0&&M+1<v.length?v.atUncheckedIndex(M)>v.atUncheckedIndex(M-1)&&v.atUncheckedIndex(M)<v.atUncheckedIndex(M+1):v.atUncheckedIndex(M)>v.atUncheckedIndex(M-1)}static newtonMethodAdjustment(v,M,b){let E=v[b],D=0;for(let X=b-1;X>=0;X--)D=E+M*D,E=v[X]+M*E;if(Math.abs(D)>=1e-14*(1+Math.abs(M)))return E/D}static improveRoots(v,M,b,E){for(let D=0;D<b.length;D++){let X=this.newtonMethodAdjustment(v,b.atUncheckedIndex(D),M);if(void 0===X||0===X)continue;const z=b.atUncheckedIndex(D);let R=0,O=0;for(;void 0!==X&&0!==X&&R<12;){if(Math.abs(X)<1e-10*(1+Math.abs(b.atUncheckedIndex(D)))){if(++O>1)break}else O=0;const Y=b.atUncheckedIndex(D)-X;if(b.reassign(D,Y),E&&!this.checkRootProximity(b,D)){b.reassign(D,z);break}X=this.newtonMethodAdjustment(v,b.atUncheckedIndex(D),M),R++}}}static appendSolution(v,M){void 0!==v&&M.push(v)}static append2Solutions(v,M,b){b.push(v),b.push(M)}static appendLinearRoot(v,M,b){wt.appendSolution(K.conditionalDivideFraction(-v,M),b)}static mostDistantFromMean(v){if(!v||0===v.length)return 0;let M=0;for(let D=0;D<v.length;D++)M+=v.atUncheckedIndex(D);M/=v.length;let b=0,E=v.atUncheckedIndex(0);for(let D=0;D<v.length;D++){const X=Math.abs(v.atUncheckedIndex(D)-M);X>b&&(b=X,E=v.atUncheckedIndex(D))}return E}static appendQuadraticRoots(v,M){const b=K.conditionalDivideFraction(1,v[2]);if(!b)return void this.appendLinearRoot(v[0],v[1],M);const E=.5*v[1]*b,D=E*E-v[0]*b;if(this.isZero(D))this.appendSolution(-E,M);else if(!(D<0)&&D>0){const v=Math.sqrt(D);this.append2Solutions(v-E,-v-E,M)}}static addConstant(v,M){for(let b=0;b<M.length;b++)M.reassign(b,M.atUncheckedIndex(b)+v)}static signedCubeRoot(v){return v>=0?Math.pow(v,1/3):-Math.pow(-v,1/3)}static appendFullCubicSolutions(v,M,b,E,D){const X=(M*M-3*v*b)/(v*v*9),z=-M/(3*v),R=E+z*(b+z*(M+z*v)),O=4*v*v*X*X*X,Y=R*R-O;if(Y>0){const M=Math.sqrt(Y),b=.5/v;D.push(z+this.signedCubeRoot(b*(-R+M))+this.signedCubeRoot(b*(-R-M)))}else if(Y<0){let M=Math.sqrt(O);v<0&&(M=-M);const b=Math.acos(-R/M)/3,E=2*Math.sqrt(X),Y=2*Math.PI/3;D.push(z+E*Math.cos(b)),D.push(z+E*Math.cos(b+Y)),D.push(z+E*Math.cos(b-Y))}else{const M=this.signedCubeRoot(.5*R/v),b=z+M;D.push(z-2*M),D.push(b),D.push(b)}}static appendCubicRoots(v,M){void 0!==K.conditionalDivideCoordinate(1,v[3])?(this.appendFullCubicSolutions(v[3],v[2],v[1],v[0],M),this.improveRoots(v,3,M,!1)):this.appendQuadraticRoots(v,M),M.sort()}static appendQuarticRoots(v,M){const b=new Float64Array(4);let E,D;const X=new Float64Array(1);if(!this.safeDivide(X,1,v[4],0,0))return void this.appendCubicRoots(v,M);const z=v[3]*X[0],R=v[2]*X[0],O=v[1]*X[0],Y=-.25*z,N=z*z,B=-3/8*N+R,V=.125*N*z-.5*z*R+O,L=-3/256*N*N+1/16*N*R-1/4*z*O+v[0]*X[0],U=new At;if(this.isZero(L))return b[0]=V,b[1]=B,b[2]=0,b[3]=1,this.appendCubicRoots(b,M),M.push(0),void this.addConstant(Y,M);{b[0]=.5*L*B-1/8*V*V,b[1]=-L,b[2]=-.5*B,b[3]=1,this.appendCubicRoots(b,U);const v=this.mostDistantFromMean(U);if(E=v*v-L,D=2*v-B,this.isSmallRatio(E,L))E=0;else{if(!(E>0))return;E=Math.sqrt(E)}if(this.isSmallRatio(D,B))D=0;else{if(!(D>0)){for(let v=0;v<U.length;v++)M.push(U.atUncheckedIndex(v));return}D=Math.sqrt(D)}b[0]=v-E,b[1]=V<0?-D:D,b[2]=1,this.appendQuadraticRoots(b,M),b[0]=v+E,b[1]=V<0?D:-D,b[2]=1,this.appendQuadraticRoots(b,M)}this.addConstant(Y,M),M.sort(),this.improveRoots(v,4,M,!0)}static appendCosSinRadians(v,M,b,E,D){b&&b.push(v),E&&E.push(M),D&&D.push(Math.atan2(M,v))}static appendImplicitLineUnitCircleIntersections(v,M,b,E,D,X,z=1e-14){let R;const O=M*M+b*b;let Y=0;if(R=z<0?0:2*z,O<=0)Y=0===v?-2:-1;else{const z=-v/O,N=1-v*v/O;if(N<-R){const R=Math.sqrt(O),N=v<0?1/R:-1/R;this.appendCosSinRadians(z*M,z*b,E,D,X),this.appendCosSinRadians(M*N,b*N,E,D,X),Y=0}else if(N<R){const R=Math.sqrt(O),N=v<0?1/R:-1/R;this.appendCosSinRadians(z*M,z*b,E,D,X),this.appendCosSinRadians(M*N,b*N,E,D,X),Y=1}else{const v=Math.sqrt(N/O),R=z*M,B=z*b;this.appendCosSinRadians(R-v*b,B+v*M,E,D,X),this.appendCosSinRadians(R+v*b,B-v*M,E,D,X),Y=2}}return Y}}wt._EQN_EPS=1e-9,wt._safeDivideFactor=1e-14;class Ct{static degreeKnownEvaluate(v,M,b){if(M<0)return 0;let E=v[M];for(let D=M-1;D>=0;D--)E=b*E+v[D];return E}static evaluate(v,M){const b=v.length-1;return this.degreeKnownEvaluate(v,b,M)}static accumulate(v,M,b){let E=v.length-1;const D=M.length-1;for(let X=0;X<=D;X++)v[X]+=b*M[X];for(;E>=0&&0===v[E];)E--;return E}static zero(v){for(let M=0;M<v.length;M++)v[M]=0}}class Tt{static solveAngles(v,M,b,E){let D,X=Math.abs(b);E.length=0;const z=this._smallAngle;for(let N=0;N<=M;N++)D=Math.abs(v[N]),D>X&&(X=D);const R=z*X;let O=M;for(;O>0&&Math.abs(v[O])<=R;)O--;const Y=new At;if(-1===O);else if(0===O||(1===O?Y.push(-v[0]/v[1]):2===O?wt.appendQuadraticRoots(v,Y):3===O?wt.appendCubicRoots(v,Y):4===O&&wt.appendQuarticRoots(v,Y)),Y.length>0){for(let v=0;v<Y.length;v++){const M=Ct.evaluate(this.S,Y.atUncheckedIndex(v)),b=Ct.evaluate(this.C,Y.atUncheckedIndex(v));E.push(Math.atan2(M,b))}O<M&&E.push(-.5*Math.PI)}return E.length>0}static solveUnitCircleImplicitQuadricIntersection(v,M,b,E,D,X,z){const R=new Float64Array(5);let O;Ct.zero(R),K.hypotenuseXYZ(v,M,b)>Tt._coefficientRelTol*K.hypotenuseXYZ(E,D,X)?(Ct.accumulate(R,this.CW,E),Ct.accumulate(R,this.SW,D),Ct.accumulate(R,this.WW,X),Ct.accumulate(R,this.SS,b),Ct.accumulate(R,this.CC,v),Ct.accumulate(R,this.SC,M),O=4):(Ct.accumulate(R,this.C,E),Ct.accumulate(R,this.S,D),Ct.accumulate(R,this.W,X),O=2);let Y=0;return Y=Math.max(Y,Math.abs(v),Math.abs(b),Math.abs(M),Math.abs(E),Math.abs(D),Math.abs(X)),this.solveAngles(R,O,Y,z)}static solveUnitCircleEllipseIntersection(v,M,b,E,D,X,z,R){R.length=0;const O=b*b+E*E,Y=2*(b*D+E*X),N=D*D+X*X,B=2*(b*v+E*M),V=2*(D*v+X*M),L=v*v+M*M-1,U=this.solveUnitCircleImplicitQuadricIntersection(O,Y,N,B,V,L,z);for(const Sr of z){const z=Math.cos(Sr),O=Math.sin(Sr),Y=v+b*z+D*O,N=M+E*z+X*O;R.push(Math.atan2(N,Y))}return U}static solveUnitCircleHomogeneousEllipseIntersection(v,M,b,E,D,X,z,R,O,Y,N){N.length=0;const B=E*E+D*D-X*X,V=2*(E*z+D*R-X*O),L=z*z+R*R-O*O,U=2*(E*v+D*M-X*b),Sr=2*(z*v+R*M-O*b),Cr=v*v+M*M-b*b,kr=this.solveUnitCircleImplicitQuadricIntersection(B,V,L,U,Sr,Cr,Y);for(const Fr of Y){const b=Math.cos(Fr),X=Math.sin(Fr),O=v+E*b+z*X,Y=M+D*b+R*X;N.push(Math.atan2(Y,O))}return kr}}Tt._smallAngle=1e-11,Tt.S=Float64Array.from([0,2,-2]),Tt.C=Float64Array.from([1,-2]),Tt.W=Float64Array.from([1,-2,2]),Tt.CW=Float64Array.from([1,-4,6,-4]),Tt.SW=Float64Array.from([0,2,-6,8,-4]),Tt.SC=Float64Array.from([0,2,-6,4]),Tt.SS=Float64Array.from([0,0,4,-8,4]),Tt.CC=Float64Array.from([1,-4,4]),Tt.WW=Float64Array.from([1,-4,8,-8,4]),Tt.CCminusSS=Float64Array.from([1,-4,0,8,-4]),Tt._coefficientRelTol=1e-12;class Ft{static lineSegment2dXYTransverseIntersectionUnbounded(v,M,b,E,D){const X=M.x-v.x,z=M.y-v.y,R=E.x-b.x,O=E.y-b.y,Y=b.x-v.x,N=b.y-v.y,B=K.crossProductXYXY(X,z,R,O),V=K.crossProductXYXY(Y,N,R,O),L=K.crossProductXYXY(X,z,Y,N),U=K.conditionalDivideFraction(V,B),Sr=K.conditionalDivideFraction(L,B);return void 0!==U&&void 0!==Sr?(D.set(U,-Sr),!0):(D.set(0,0),!1)}static lineSegmentXYUVTransverseIntersectionUnbounded(v,M,b,E,D,X,z,R,O){const Y=D-v,N=X-M,B=K.crossProductXYXY(b,E,z,R),V=K.crossProductXYXY(Y,N,z,R),L=K.crossProductXYXY(b,E,Y,N),U=K.conditionalDivideFraction(V,B),Sr=K.conditionalDivideFraction(L,B);return void 0!==U&&void 0!==Sr?(O.set(U,-Sr),!0):(O.set(0,0),!1)}static lineSegment3dXYTransverseIntersectionUnbounded(v,M,b,E,D){const X=M.x-v.x,z=M.y-v.y,R=E.x-b.x,O=E.y-b.y,Y=b.x-v.x,N=b.y-v.y,B=K.crossProductXYXY(X,z,R,O),V=K.crossProductXYXY(Y,N,R,O),L=K.crossProductXYXY(X,z,Y,N),U=K.conditionalDivideFraction(V,B),Sr=K.conditionalDivideFraction(L,B);return void 0!==U&&void 0!==Sr?(D.set(U,-Sr),!0):(D.set(0,0),!1)}static lineSegment3dHXYTransverseIntersectionUnbounded(v,M,b,E,D){const X=K.tripleProduct(v.x,M.x,b.x,v.y,M.y,b.y,v.w,M.w,b.w),z=K.tripleProduct(v.x,M.x,E.x,v.y,M.y,E.y,v.w,M.w,E.w),R=K.conditionalDivideFraction(-X,z-X);if(void 0!==R){const X=K.tripleProduct(b.x,E.x,v.x,b.y,E.y,v.y,b.w,E.w,v.w),z=K.tripleProduct(b.x,E.x,M.x,b.y,E.y,M.y,b.w,E.w,M.w),O=K.conditionalDivideFraction(-X,z-X);if(void 0!==O)return J.create(O,R,D)}}static lineSegment3dHXYClosestPointUnbounded(v,M,b){const E=M.x*v.w-v.x*M.w,D=M.y*v.w-v.y*M.w,X=K.tripleProduct(v.x,-D,b.x,v.y,E,b.y,v.w,0,b.w),z=K.tripleProduct(M.x,-D,b.x,M.y,E,b.y,M.w,0,b.w);return K.conditionalDivideFraction(-X,z-X)}static lineSegment3dXYClosestPointUnbounded(v,M,b){const E=M.x-v.x,D=M.y-v.y,X=E*E+D*D,z=E*(b.x-v.x)+D*(b.y-v.y);return K.conditionalDivideFraction(z,X)}static lineSegment3dClosestPointUnbounded(v,M,b){const E=M.x-v.x,D=M.y-v.y,X=M.z-v.z,z=E*E+D*D+X*X,R=E*(b.x-v.x)+D*(b.y-v.y)+X*(b.z-v.z);return K.conditionalDivideFraction(R,z)}static lineSegment3dClosestApproachUnbounded(v,M,b,E,D){return this.ray3dXYZUVWClosestApproachUnbounded(v.x,v.y,v.z,M.x-v.x,M.y-v.y,M.z-v.z,b.x,b.y,b.z,E.x-b.x,E.y-b.y,E.z-b.z,D)}static ray3dXYZUVWClosestApproachUnbounded(v,M,b,E,D,X,z,R,O,Y,N,B,V){const L=z-v,U=R-M,Sr=O-b,Cr=K.hypotenuseSquaredXYZ(E,D,X),kr=K.hypotenuseSquaredXYZ(Y,N,B),Fr=K.dotProductXYZXYZ(E,D,X,Y,N,B),Xr=K.dotProductXYZXYZ(L,U,Sr,E,D,X),zr=K.dotProductXYZXYZ(L,U,Sr,Y,N,B);return Ft.linearSystem2d(Cr,-Fr,Fr,-kr,Xr,zr,V)}static linearSystem2d(v,M,b,E,D,X,z){const R=K.crossProductXYXY(v,b,M,E),O=K.crossProductXYXY(D,X,M,E),Y=K.crossProductXYXY(v,b,D,X),N=K.conditionalDivideFraction(O,R),B=K.conditionalDivideFraction(Y,R);return void 0!==N&&void 0!==B?(z.set(N,B),!0):(z.set(0,0),!1)}static linearSystem3d(v,M,b,E,D,X,z,R,O,Y,N,B,V){const L=K.tripleProduct(v,E,z,M,D,R,b,X,O),U=K.tripleProduct(Y,N,B,M,D,R,b,X,O),Sr=K.tripleProduct(v,E,z,Y,N,B,b,X,O),Cr=K.tripleProduct(v,E,z,M,D,R,Y,N,B),kr=K.conditionalDivideFraction(U,L),Fr=K.conditionalDivideFraction(Sr,L),Xr=K.conditionalDivideFraction(Cr,L);if(void 0!==kr&&void 0!==Fr&&void 0!==Xr)return $.create(kr,Fr,Xr,V)}static intersect3Planes(v,M,b,E,D,X,z){return this.linearSystem3d(M.x,M.y,M.z,E.x,E.y,E.z,X.x,X.y,X.z,K.dotProductXYZXYZ(v.x,v.y,v.z,M.x,M.y,M.z),K.dotProductXYZXYZ(b.x,b.y,b.z,E.x,E.y,E.z),K.dotProductXYZXYZ(D.x,D.y,D.z,X.x,X.y,X.z),z)}static eliminateFromPivot(v,M,b,E){const D=v.length;let X=K.conditionalDivideFraction(b[M],v[M]);if(void 0===X)return!1;X*=E;for(let z=M+1;z<D;z++)b[z]+=X*v[z];return!0}static solveBilinearPair(v,M,b,E,D,X,z,R){const O=K.crossProductXYXY(v,D,b,z),Y=K.crossProductXYXY(M,X,b,z)+K.crossProductXYXY(v,D,E,R),N=K.crossProductXYXY(M,X,E,R),B=St.solveQuadratic(N,Y,O);if(void 0===B)return;const V=[];for(const L of B){const O=K.conditionalDivideFraction(-(v+M*L),b+E*L),Y=K.conditionalDivideFraction(-(D+X*L),z+R*L);void 0!==O?V.push(H.create(L,O)):void 0!==Y&&V.push(H.create(L,Y))}return V}}class kt{constructor(v,M,b){this.a=v,this.cosineCoff=M,this.sineCoff=b}set(v,M,b){this.a=v,this.cosineCoff=M,this.sineCoff=b}evaluateRadians(v){return this.a+this.cosineCoff*Math.cos(v)+this.sineCoff*Math.sin(v)}range(v){const M=K.hypotenuseXY(this.cosineCoff,this.sineCoff);return ft.createXX(this.a-M,this.a+M,v)}rangeInStartEndRadians(v,M,b){if(W.isFullCircleRadians(M-v))return this.range(b);b=ft.createXX(this.evaluateRadians(v),this.evaluateRadians(M),b);const E=Math.atan2(this.sineCoff,this.cosineCoff),D=E+Math.PI;return It.isRadiansInStartEnd(E,v,M)&&b.extendX(this.evaluateRadians(E)),It.isRadiansInStartEnd(D,v,M)&&b.extendX(this.evaluateRadians(D)),b}rangeInSweep(v,M){return this.rangeInStartEndRadians(v.startRadians,v.endRadians,M)}referenceMinMaxRadians(){return Math.atan2(this.sineCoff,this.cosineCoff)}}class Mt{constructor(v,M){this.origin=v,this.direction=M,this.a=void 0}static _create(v,M,b,E,D,X){return new Mt(Q.create(v,M,b),$.create(E,D,X))}static createXAxis(){return Mt._create(0,0,0,1,0,0)}static createYAxis(){return Mt._create(0,0,0,0,1,0)}static createZAxis(){return Mt._create(0,0,0,0,0,1)}static createZero(v){return v?(v.origin.setZero(),v.direction.setZero(),v):new Mt(Q.createZero(),$.createZero())}isAlmostEqual(v){return this.origin.isAlmostEqual(v.origin)&&this.direction.isAlmostEqual(v.direction)}dotProductToPoint(v){return this.direction.dotProductStartEnd(this.origin,v)}pointToFraction(v){return K.safeDivideFraction(this.dotProductToPoint(v),this.direction.magnitudeSquared(),0)}projectPointToRay(v){return this.origin.plusScaled(this.direction,this.pointToFraction(v))}isAlmostEqualPointSet(v){if(!this.direction.isParallelTo(v.direction,!0))return!1;let M=this.projectPointToRay(v.origin);return!!v.origin.isAlmostEqualMetric(M)&&(M=v.projectPointToRay(this.origin),!!this.origin.isAlmostEqualMetric(M))}static create(v,M,b){return b?(b.set(v,M),b):new Mt(v.clone(),M.clone())}static createWeightedDerivative(v,M,b){const E=v[3],D=M[3],X=v[0],z=v[1],R=v[2],O=M[0]*E-v[0]*D,Y=M[1]*E-v[1]*D,N=M[2]*E-v[2]*D;if(K.isSmallMetricDistance(E))return;const B=1/E,V=B*B;return Mt.createXYZUVW(X*B,z*B,R*B,O*V,Y*V,N*V,b)}static createXYZUVW(v,M,b,E,D,X,z){return z?(z.getOriginRef().set(v,M,b),z.getDirectionRef().set(E,D,X),z):new Mt(Q.create(v,M,b),$.create(E,D,X))}static createCapture(v,M){return new Mt(v,M)}static createPointVectorNumber(v,M,b,E){return E?(E.origin.setFrom(v),E.direction.setFrom(M),E.a=b,E):((E=new Mt(v.clone(),M.clone())).a=b,E)}static createStartEnd(v,M,b){return b?(b.origin.setFrom(v),b.direction.setStartEnd(v,M),b):new Mt(v.clone(),$.createStartEnd(v,M))}getOriginRef(){return this.origin}getDirectionRef(){return this.direction}set(v,M){this.origin.setFrom(v),this.direction.setFrom(M)}clone(v){return v?(v.set(this.origin.clone(),this.direction.clone()),v):new Mt(this.origin.clone(),this.direction.clone())}cloneTransformed(v,M){return Mt.create(v.multiplyPoint3d(this.origin,M?.origin),v.multiplyVector(this.direction,M?.direction),M)}cloneInverseTransformed(v,M){if(v.computeCachedInverse(!0))return Mt.create(v.multiplyInversePoint3d(this.origin,M?.origin),v.matrix.multiplyInverseXYZAsVector3d(this.direction.x,this.direction.y,this.direction.z,M?.direction),M)}transformInPlace(v){v.multiplyPoint3d(this.origin,this.origin),v.multiplyVector(this.direction,this.direction)}setFrom(v){this.set(v.origin,v.direction)}fractionToPoint(v,M){return this.origin.plusScaled(this.direction,v,M)}toRigidZFrame(v){const M=Mt._workMatrix=xt.createRigidHeadsUp(this.direction,z.ZXY,Mt._workMatrix);return pt.createOriginAndMatrix(this.origin,M,v)}setFromJSON(v){if(!v)return this.origin.set(0,0,0),void this.direction.set(0,0,1);this.origin.setFromJSON(v.origin),this.direction.setFromJSON(v.direction)}toJSON(){return{origin:this.origin.toJSON(),direction:this.direction.toJSON()}}static fromJSON(v){const M=Mt.createXAxis();return M.setFromJSON(v),M}trySetDirectionMagnitudeInPlace(v=1){return this.direction.tryNormalizeInPlace()?(this.direction.scaleInPlace(v),!0):(this.direction.setZero(),this.a=0,!1)}tryNormalizeInPlaceWithAreaWeight(v){const M=K.smallMetricDistanceSquared;return this.a=v,!!(Math.abs(v)>M&&this.direction.tryNormalizeInPlace(M))||(this.direction.setZero(),this.a=0,!1)}distance(v){const M=this.direction.magnitudeSquared(),b=this.dotProductToPoint(v),E=K.inverseMetricDistanceSquared(M);return E?Math.sqrt(this.origin.distanceSquared(v)-b*b*E):Math.sqrt(this.origin.distanceSquared(v))}intersectionWithPlane(v,M){const b=$.createStartEnd(v.getOriginRef(),this.origin),E=this.direction.dotProduct(v.getNormalRef()),D=this.direction.magnitudeSquared(),X=b.dotProduct(v.getNormalRef()),z=K.conditionalDivideFraction(-X,E);if(void 0!==z)return void 0!==K.conditionalDivideFraction(D,E)?(M&&this.origin.plusScaled(this.direction,z,M),z):void 0}intersectionWithRange3d(v,M){if(v.isNull)return ft.createNull(M);const b=ft.createXX(-K.largeCoordinateResult,K.largeCoordinateResult,M);return b.clipLinearMapToInterval(this.origin.x,this.direction.x,v.low.x,v.high.x)&&b.clipLinearMapToInterval(this.origin.y,this.direction.y,v.low.y,v.high.y)&&b.clipLinearMapToInterval(this.origin.z,this.direction.z,v.low.z,v.high.z),b}intersectionWithTriangle(v,M,b,E,D,X){(void 0===E||E<0)&&(E=K.smallMetricDistance),(void 0===D||D<0)&&(D=K.smallFloatingPoint);const z=Mt._workVector0=$.createStartEnd(v,M,Mt._workVector0),R=Mt._workVector1=$.createStartEnd(v,b,Mt._workVector1),O=Mt._workVector2=this.direction.crossProduct(R,Mt._workVector2),Y=z.dotProduct(O);if(Y>=-E&&Y<=E)return;const N=1/Y,B=Mt._workVector3=$.createStartEnd(v,this.origin,Mt._workVector3);let V=N*B.dotProduct(O);if(V<0){if(!(V>-D))return;V=0}else if(V>1){if(!(V<1+D))return;V=1}const L=Mt._workVector4=B.crossProduct(z,Mt._workVector4);let U=N*this.direction.dotProduct(L);if(U<0){if(!(U>-D))return;U=0}else if(V+U>1){if(!(V+U<1+D))return;U=1-V}const Sr=N*R.dotProduct(L);return Sr<=E?void 0:this.origin.plusScaled(this.direction,Sr,X)}perpendicularPartOfVectorToTarget(v,M){const b=$.createStartEnd(this.origin,v),E=this.direction.magnitudeSquared(),D=this.direction.dotProductStartEnd(this.origin,v),X=K.safeDivideFraction(D,E,0);return b.plusScaled(this.direction,-X,M)}static closestApproachRay3dRay3d(v,M){const b=J.create();let E,D,X,z,R;Ft.ray3dXYZUVWClosestApproachUnbounded(v.origin.x,v.origin.y,v.origin.z,v.direction.x,v.direction.y,v.direction.z,M.origin.x,M.origin.y,M.origin.z,M.direction.x,M.direction.y,M.direction.z,b)?(E=b.x,D=b.y,X=v.fractionToPoint(E),z=M.fractionToPoint(D),R=X.isAlmostEqualMetric(z)?Sr.Intersection:Sr.PerpendicularChord):(D=0,E=v.pointToFraction(M.origin),X=v.fractionToPoint(E),z=M.fractionToPoint(D),R=X.isAlmostEqualMetric(z)?Sr.CoincidentGeometry:Sr.ParallelGeometry);const O=Pt.createCapture(vt.createRayFractionPoint(v,E,v.fractionToPoint(E)),vt.createRayFractionPoint(M,D,M.fractionToPoint(D)));return O.approachType=R,O}static interpolatePointAndTangent(v,M,b,E,D){D=D??Mt.createZero();const X=b.x-v.x,z=b.y-v.y,R=b.z-v.z;if(D.direction.set(E*X,E*z,E*R),M<=.5)D.origin.set(v.x+M*X,v.y+M*z,v.z+M*R);else{const v=M-1;D.origin.set(b.x+v*X,b.y+v*z,b.z+v*R)}return D}}class bt extends tt{constructor(v,M,b){super(),this.origin=v,this.vectorU=M,this.vectorV=b}static createOriginAndVectors(v,M,b,E){return E?(E.origin.setFrom(v),E.vectorU.setFrom(M),E.vectorV.setFrom(b),E):new bt(v.clone(),M.clone(),b.clone())}clone(v){return void 0!==v&&v.setOriginAndVectors(this.origin,this.vectorU,this.vectorV),new bt(this.origin.clone(),this.vectorU.clone(),this.vectorV.clone())}static createFrom(v,M){if(v instanceof bt)return v.clone(M);const b=v.getUnitNormal();if(void 0===b)return;const E=v.getAnyPointOnPlane(),D=xt.createPerpendicularVectorFavorXYPlane(b);if(D.tryNormalizeInPlace()){const v=b.unitCrossProduct(D);if(void 0!==v)return new bt(E,D,v)}}static createFromTransformColumnsXYAndLengths(v,M,b,E){return E?(E.origin.setFrom(v.getOrigin()),v.matrix.columnX(E.vectorU),v.matrix.columnY(E.vectorV)):E=new bt(v.getOrigin(),v.matrix.columnX(),v.matrix.columnY()),void 0!==M&&E.vectorU.scaleToLength(M,E.vectorU),void 0!==b&&E.vectorV.scaleToLength(b,E.vectorV),E}static createCapture(v,M,b,E){return E?(E.origin=v,E.vectorU=M,E.vectorV=b,E):new bt(v,M,b)}setOriginAndVectorsXYZ(v,M,b,E,D,X,z,R,O){return this.origin.set(v,M,b),this.vectorU.set(E,D,X),this.vectorV.set(z,R,O),this}setOriginAndVectors(v,M,b){return this.origin.setFrom(v),this.vectorU.setFrom(M),this.vectorV.setFrom(b),this}static createOriginAndVectorsXYZ(v,M,b,E,D,X,z,R,O,Y){return Y?Y.setOriginAndVectorsXYZ(v,M,b,E,D,X,z,R,O):new bt(Q.create(v,M,b),$.create(E,D,X),$.create(z,R,O))}static createOriginAndTargets(v,M,b,E){return bt.createOriginAndVectorsXYZ(v.x,v.y,v.z,M.x-v.x,M.y-v.y,M.z-v.z,b.x-v.x,b.y-v.y,b.z-v.z,E)}static createXYPlane(v){return bt.createOriginAndVectorsXYZ(0,0,0,1,0,0,0,1,0,v)}static createOriginAndVectorsArrays(v,M,b,E){return bt.createOriginAndVectorsXYZ(v[0],v[1],v[2],M[0],M[1],M[2],b[0],b[1],b[2],E)}static createOriginAndVectorsWeightedArrays(v,M,b,E){const D=v[3];if(E=bt.createXYPlane(E),K.isSmallMetricDistance(D))return E;const X=1/D,z=M[3]*X*X,R=b[3]*X*X;return E.origin.set(v[0]*X,v[1]*X,v[2]*X),$.createAdd2ScaledXYZ(M[0],M[1],M[2],X,v[0],v[1],v[2],-z,E.vectorU),$.createAdd2ScaledXYZ(b[0],b[1],b[2],X,v[0],v[1],v[2],-R,E.vectorV),E}fractionToPoint(v,M,b){return this.origin.plus2Scaled(this.vectorU,v,this.vectorV,M,b)}fractionToVector(v,M,b){return $.createAdd2Scaled(this.vectorU,v,this.vectorV,M,b)}setFromJSON(v){v&&v.origin&&v.vectorV?(this.origin.setFromJSON(v.origin),this.vectorU.setFromJSON(v.vectorU),this.vectorV.setFromJSON(v.vectorV)):(this.origin.set(0,0,0),this.vectorU.set(1,0,0),this.vectorV.set(0,1,0))}toJSON(){return{origin:this.origin.toJSON(),vectorU:this.vectorU.toJSON(),vectorV:this.vectorV.toJSON()}}static fromJSON(v){const M=bt.createXYPlane();return M.setFromJSON(v),M}isAlmostEqual(v){return this.origin.isAlmostEqual(v.origin)&&this.vectorU.isAlmostEqual(v.vectorU)&&this.vectorV.isAlmostEqual(v.vectorV)}normalizeInPlace(){const v=this.vectorU.normalizeInPlace(),M=this.vectorV.normalizeInPlace();return v&&M}getUnitNormal(v){return this.vectorU.unitCrossProduct(this.vectorV,v)}unitNormal(v){return this.vectorU.unitCrossProduct(this.vectorV,v)}getAnyPointOnPlane(v){return this.origin.clone(v)}unitNormalRay(v){bt._workVector||(bt._workVector=$.create());const M=this.vectorU.unitCrossProduct(this.vectorV,bt._workVector);if(void 0!==M)return Mt.create(this.origin,M,v)}toRigidFrame(v){return pt.createRigidFromOriginAndColumns(this.origin,this.vectorU,this.vectorV,z.XYZ,v)}transformInPlace(v){v.multiplyPoint3d(this.origin,this.origin),v.multiplyVector(this.vectorU,this.vectorU),v.multiplyVector(this.vectorV,this.vectorV)}normalX(){const v=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==v?v.x:0}normalY(){const v=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==v?v.y:0}normalZ(){const v=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==v?v.z:0}altitude(v){const M=this.vectorU.unitCrossProduct(this.vectorV);return void 0===M?0:K.dotProductXYZXYZ(v.x-this.origin.x,v.y-this.origin.y,v.z-this.origin.z,M.x,M.y,M.z)}altitudeXYZ(v,M,b){const E=this.vectorU.unitCrossProduct(this.vectorV);return void 0===E?0:K.dotProductXYZXYZ(v-this.origin.x,M-this.origin.y,b-this.origin.z,E.x,E.y,E.z)}velocity(v){const M=this.vectorU.unitCrossProduct(this.vectorV);return void 0===M?0:K.dotProductXYZXYZ(v.x,v.y,v.z,M.x,M.y,M.z)}velocityXYZ(v,M,b){const E=this.vectorU.unitCrossProduct(this.vectorV);return void 0===E?0:K.dotProductXYZXYZ(v,M,b,E.x,E.y,E.z)}weightedAltitude(v){const M=v.w;return K.tripleProduct(v.x-this.origin.x*M,v.y-this.origin.y*M,v.z-this.origin.z*M,this.vectorU.x,this.vectorU.y,this.vectorU.z,this.vectorV.x,this.vectorV.y,this.vectorV.z)}projectPointToPlane(v,M){const b=this.vectorU.unitCrossProduct(this.vectorV);if(void 0!==b){const E=b.dotProductStartEnd(this.origin,v);return v.plusScaled(b,-E,M)}const E=this.vectorU.magnitudeSquared(),D=this.vectorV.magnitudeSquared();if(E>=D){const b=this.vectorU.dotProductStartEnd(this.origin,v),D=K.conditionalDivideCoordinate(b,E,0);if(void 0!==D)return v.plusScaled(this.vectorU,D,M)}else{const b=this.vectorV.dotProductStartEnd(this.origin,v),E=K.conditionalDivideCoordinate(b,D,0);if(void 0!==E)return v.plusScaled(this.vectorV,E,M)}return this.origin.clone(M)}}function Et(v,M,b,E,D,X){return X*(v-2*D*M-E*b)}class Dt extends tt{set(v=0,M=0,b=0,E=0){return this.xyzw[0]=v,this.xyzw[1]=M,this.xyzw[2]=b,this.xyzw[3]=E,this}setComponent(v,M){v>=0&&v<4&&(this.xyzw[v]=M)}get x(){return this.xyzw[0]}set x(v){this.xyzw[0]=v}get y(){return this.xyzw[1]}set y(v){this.xyzw[1]=v}get z(){return this.xyzw[2]}set z(v){this.xyzw[2]=v}get w(){return this.xyzw[3]}set w(v){this.xyzw[3]=v}constructor(v=0,M=0,b=0,E=0){super(),this.xyzw=new Float64Array(4),this.xyzw[0]=v,this.xyzw[1]=M,this.xyzw[2]=b,this.xyzw[3]=E}static create(v=0,M=0,b=0,E=0,D){return D?D.set(v,M,b,E):new Dt(v,M,b,E)}static createPlaneFrom(v){return new Dt(v.normalX(),v.normalY(),v.normalZ(),v.altitudeXYZ(0,0,0))}setFrom(v){return this.xyzw[0]=v.xyzw[0],this.xyzw[1]=v.xyzw[1],this.xyzw[2]=v.xyzw[2],this.xyzw[3]=v.xyzw[3],this}clone(v){return v?v.setFrom(this):new Dt(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}setFromJSON(v){K.isNumberArray(v,4)?this.set(v[0],v[1],v[2],v[3]):this.set(0,0,0,0)}static fromJSON(v){const M=new Dt;return M.setFromJSON(v),M}isAlmostEqual(v){return K.isSameCoordinate(this.x,v.x)&&K.isSameCoordinate(this.y,v.y)&&K.isSameCoordinate(this.z,v.z)&&K.isSameCoordinate(this.w,v.w)}isAlmostEqualXYZW(v,M,b,E){return K.isSameCoordinate(this.x,v)&&K.isSameCoordinate(this.y,M)&&K.isSameCoordinate(this.z,b)&&K.isSameCoordinate(this.w,E)}toJSON(){return[this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3]]}distanceXYZW(v){return K.hypotenuseXYZW(v.xyzw[0]-this.xyzw[0],v.xyzw[1]-this.xyzw[1],v.xyzw[2]-this.xyzw[2],v.xyzw[3]-this.xyzw[3])}distanceSquaredXYZW(v){return K.hypotenuseSquaredXYZW(v.xyzw[0]-this.xyzw[0],v.xyzw[1]-this.xyzw[1],v.xyzw[2]-this.xyzw[2],v.xyzw[3]-this.xyzw[3])}realDistanceXY(v){const M=this.w,b=v.w;if(!K.isSmallMetricDistance(M)&&!K.isSmallMetricDistance(b))return K.hypotenuseXY(v.xyzw[0]/b-this.xyzw[0]/M,v.xyzw[1]/b-this.xyzw[1]/M)}maxDiff(v){return Math.max(Math.abs(v.xyzw[0]-this.xyzw[0]),Math.abs(v.xyzw[1]-this.xyzw[1]),Math.abs(v.xyzw[2]-this.xyzw[2]),Math.abs(v.xyzw[3]-this.xyzw[3]))}maxAbs(){return Math.max(Math.abs(this.xyzw[0]),Math.abs(this.xyzw[1]),Math.abs(this.xyzw[2]),Math.abs(this.xyzw[3]))}magnitudeXYZW(){return K.hypotenuseXYZW(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}magnitudeSquaredXYZ(){return K.hypotenuseSquaredXYZ(this.xyzw[0],this.xyzw[1],this.xyzw[2])}minus(v,M){return Dt.create(this.xyzw[0]-v.xyzw[0],this.xyzw[1]-v.xyzw[1],this.xyzw[2]-v.xyzw[2],this.xyzw[3]-v.xyzw[3],M)}crossWeightedMinus(v,M){const b=this.xyzw[3],E=v.xyzw[3];return $.create(E*this.xyzw[0]-b*v.xyzw[0],E*this.xyzw[1]-b*v.xyzw[1],E*this.xyzw[2]-b*v.xyzw[2],M)}crossWeightedMinusPoint3d(v,M){const b=this.xyzw[3];return $.create(this.xyzw[0]-b*v.x,this.xyzw[1]-b*v.y,this.xyzw[2]-b*v.z,M)}plus(v,M){return Dt.create(this.xyzw[0]+v.xyzw[0],this.xyzw[1]+v.xyzw[1],this.xyzw[2]+v.xyzw[2],this.xyzw[3]+v.xyzw[3],M)}get isAlmostZero(){return K.isSmallMetricDistance(this.maxAbs())}static createZero(){return new Dt(0,0,0,0)}static createPlanePointPointZ(v,M,b){return Dt.create(v.y*M.w-v.w*M.y,v.w*M.x-v.x*M.w,0,v.x*M.y-v.y*M.x,b)}static createFromPackedXYZ(v,M=0,b){if(M>=0&&M+2<v.length)return Dt.create(v[M],v[M+1],v[M+2],1,b)}static createFromPacked(v,M=0,b){if(M>=0&&M+3<v.length)return Dt.create(v[M],v[M+1],v[M+2],v[M+3],b)}static createFromPackedXYZW(v,M=0,b){return Dt.create(v[M],v[M+1],v[M+2],v[M+3],b)}static createFromPointAndWeight(v,M){return new Dt(v.x,v.y,v.z,M)}static createFromPoint(v){if(v instanceof H)return new Dt(v.x,v.y,0,1);if(v instanceof Q)return new Dt(v.x,v.y,v.z,1);if(v instanceof Dt)return v.clone();if(Array.isArray(v)){const M=v.length>0?v[0]:0,b=v.length>1?v[1]:0,E=v.length>2?v[2]:0,D=v.length>3?v[3]:1;return new Dt(M,b,E,D)}const M=v.x,b=v.y,E=v.hasOwnProperty("z")?v.z:0,D=v.hasOwnProperty("w")?v.w:1;return new Dt(M,b,E,D)}plusScaled(v,M,b){return Dt.create(this.xyzw[0]+v.xyzw[0]*M,this.xyzw[1]+v.xyzw[1]*M,this.xyzw[2]+v.xyzw[2]*M,this.xyzw[3]+v.xyzw[3]*M,b)}interpolate(v,M,b){const E=1-v;return Dt.create(this.xyzw[0]*E+M.xyzw[0]*v,this.xyzw[1]*E+M.xyzw[1]*v,this.xyzw[2]*E+M.xyzw[2]*v,this.xyzw[3]*E+M.xyzw[3]*v,b)}plus2Scaled(v,M,b,E,D){return Dt.create(this.xyzw[0]+v.xyzw[0]*M+b.xyzw[0]*E,this.xyzw[1]+v.xyzw[1]*M+b.xyzw[1]*E,this.xyzw[2]+v.xyzw[2]*M+b.xyzw[2]*E,this.xyzw[3]+v.xyzw[3]*M+b.xyzw[3]*E,D)}plus3Scaled(v,M,b,E,D,X,z){return Dt.create(this.xyzw[0]+v.xyzw[0]*M+b.xyzw[0]*E+D.xyzw[0]*X,this.xyzw[1]+v.xyzw[1]*M+b.xyzw[1]*E+D.xyzw[1]*X,this.xyzw[2]+v.xyzw[2]*M+b.xyzw[2]*E+D.xyzw[2]*X,this.xyzw[3]+v.xyzw[3]*M+b.xyzw[3]*E+D.xyzw[3]*X,z)}static createAdd2Scaled(v,M,b,E,D){return Dt.create(v.xyzw[0]*M+b.xyzw[0]*E,v.xyzw[1]*M+b.xyzw[1]*E,v.xyzw[2]*M+b.xyzw[2]*E,v.xyzw[3]*M+b.xyzw[3]*E,D)}static createAdd3Scaled(v,M,b,E,D,X,z){return Dt.create(v.xyzw[0]*M+b.xyzw[0]*E+D.xyzw[0]*X,v.xyzw[1]*M+b.xyzw[1]*E+D.xyzw[1]*X,v.xyzw[2]*M+b.xyzw[2]*E+D.xyzw[2]*X,v.xyzw[3]*M+b.xyzw[3]*E+D.xyzw[3]*X,z)}dotVectorsToTargets(v,M){return(v.xyzw[0]-this.xyzw[0])*(M.xyzw[0]-this.xyzw[0])+(v.xyzw[1]-this.xyzw[1])*(M.xyzw[1]-this.xyzw[1])+(v.xyzw[2]-this.xyzw[2])*(M.xyzw[2]-this.xyzw[2])+(v.xyzw[3]-this.xyzw[3])*(M.xyzw[3]-this.xyzw[3])}dotProduct(v){return this.xyzw[0]*v.xyzw[0]+this.xyzw[1]*v.xyzw[1]+this.xyzw[2]*v.xyzw[2]+this.xyzw[3]*v.xyzw[3]}dotProductXYZW(v,M,b,E){return this.xyzw[0]*v+this.xyzw[1]*M+this.xyzw[2]*b+this.xyzw[3]*E}altitude(v){return this.xyzw[0]*v.x+this.xyzw[1]*v.y+this.xyzw[2]*v.z+this.xyzw[3]}altitudeXYZ(v,M,b){return this.xyzw[0]*v+this.xyzw[1]*M+this.xyzw[2]*b+this.xyzw[3]}weightedAltitude(v){return this.xyzw[0]*v.x+this.xyzw[1]*v.y+this.xyzw[2]*v.z+this.xyzw[3]*v.w}velocity(v){return this.xyzw[0]*v.x+this.xyzw[1]*v.y+this.xyzw[2]*v.z}velocityXYZ(v,M,b){return this.xyzw[0]*v+this.xyzw[1]*M+this.xyzw[2]*b}normalX(){return this.x}normalY(){return this.y}normalZ(){return this.z}static unitX(){return new Dt(1,0,0,0)}static unitY(){return new Dt(0,1,0,0)}static unitZ(){return new Dt(0,0,1,0)}static unitW(){return new Dt(0,0,0,1)}safeDivideOrNull(v,M){if(0!==v)return this.scale(1/v,M)}projectPointToPlane(v,M){const b=this.altitude(v),E=this.magnitudeSquaredXYZ(),D=K.conditionalDivideCoordinate(-b,E);return void 0===D?v.clone(M):v.plusXYZ(D*this.x,D*this.y,D*this.z,M)}scale(v,M){return(M=M||new Dt).xyzw[0]=this.xyzw[0]*v,M.xyzw[1]=this.xyzw[1]*v,M.xyzw[2]=this.xyzw[2]*v,M.xyzw[3]=this.xyzw[3]*v,M}negate(v){return(v=v||new Dt).xyzw[0]=-this.xyzw[0],v.xyzw[1]=-this.xyzw[1],v.xyzw[2]=-this.xyzw[2],v.xyzw[3]=-this.xyzw[3],v}normalizeWeight(v){const M=K.correctSmallFraction(this.xyzw[3]);return v=v||new Dt,this.safeDivideOrNull(M,v)}realPoint(v){const M=K.correctSmallFraction(this.xyzw[3]);if(0===M)return;const b=1/M;return Q.create(this.xyzw[0]*b,this.xyzw[1]*b,this.xyzw[2]*b,v)}realPointOrVector(){const v=K.correctSmallFraction(this.xyzw[3]);if(0===v)return $.create(this.x,this.y,this.z);const M=1/v;return Q.create(this.x*M,this.y*M,this.z*M)}static createRealPoint3dDefault000(v,M,b,E,D){const X=K.correctSmallFraction(E),z=0===X?0:1/X;return Q.create(v*z,M*z,b*z,D)}static createRealDerivativeRay3dDefault000(v,M,b,E,D,X,z,R,O){const Y=K.correctSmallFraction(E),N=0===Y?0:1/Y,B=N*N;return Mt.createXYZUVW(v*N,M*N,b*N,(D*E-R*v)*B,(X*E-R*M)*B,(z*E-R*b)*B,O)}static createRealDerivativePlane3dByOriginAndVectorsDefault000(v,M,b,E,D,X,z,R,O,Y,N,B,V){const L=K.correctSmallFraction(E),U=0===L?0:1/L,Sr=U*U,Cr=v*U,kr=M*U,Fr=b*U,Xr=(D*E-R*v)*Sr,zr=(X*E-R*M)*Sr,Rr=(z*E-R*b)*Sr;return bt.createOriginAndVectorsXYZ(Cr,kr,Fr,Xr,zr,Rr,Et(O,R,B,Cr,Xr,U),Et(Y,R,B,kr,zr,U),Et(N,R,B,Fr,Rr,U),V)}realPointDefault000(v){const M=K.correctSmallFraction(this.xyzw[3]);if(0===M)return Q.create(0,0,0,v);v=v||new Q;const b=1/M;return Q.create(this.xyzw[0]*b,this.xyzw[1]*b,this.xyzw[2]*b,v)}normalizeXYZW(v){const M=K.correctSmallFraction(this.magnitudeXYZW());return v=v||new Dt,this.safeDivideOrNull(M,v)}static determinantIndexed3X3(v,M,b,E,D,X){return K.tripleProduct(v.xyzw[E],v.xyzw[D],v.xyzw[X],M.xyzw[E],M.xyzw[D],M.xyzw[X],b.xyzw[E],b.xyzw[D],b.xyzw[X])}static perpendicularPoint4dPlane(v,M,b){return Dt.create(Dt.determinantIndexed3X3(v,M,b,1,2,3),-Dt.determinantIndexed3X3(v,M,b,2,3,0),Dt.determinantIndexed3X3(v,M,b,3,0,1),-Dt.determinantIndexed3X3(v,M,b,0,1,2))}toPlane3dByOriginAndUnitNormal(v){return yt.createFrom(this,v)}normalizeQuaternion(){const v=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);if(v>0){const M=1/v;this.x*=M,this.y*=M,this.z*=M,this.w*=M}return v}static interpolateQuaternions(v,M,b,E){if(E||(E=new Dt),0===M)return v;if(1===M)return b;if(.5===M)return v.plus(b,E),E.normalizeQuaternion(),E;const D=v.clone(),X=b.clone();let z=v.dotProduct(b);if(z<0&&(X.negate(X),z=-z),z>.9995)return D.interpolate(M,X,E),E.normalizeQuaternion(),E;z<-1?z=-1:z>1&&(z=1);const R=new Dt;X.plusScaled(D,-z,R),R.normalizeQuaternion();const O=Math.acos(z)*M;return Dt.createAdd2Scaled(D,Math.cos(O),R,Math.sin(O))}radiansToPoint4dXYZW(v){const M=this.magnitudeXYZW(),b=v.magnitudeXYZW(),E=this.dotProduct(v),D=K.conditionalDivideFraction(E,M*b);if(void 0!==D)return Math.acos(D)}}class Xt{constructor(){this._coffs=new Float64Array(16)}setFrom(v){for(let M=0;M<16;M++)this._coffs[M]=v._coffs[M]}clone(v){if(v===this)return this;void 0===v&&(v=new Xt);for(let M=0;M<16;M++)v._coffs[M]=this._coffs[M];return v}setZero(){for(let v=0;v<16;v++)this._coffs[v]=0}setIdentity(){for(let v=0;v<16;v++)this._coffs[v]=0;this._coffs[0]=this._coffs[5]=this._coffs[10]=this._coffs[15]=1}static is1000(v,M,b,E,D){return Math.abs(v-1)<=D&&Math.abs(M)<=D&&Math.abs(b)<=D&&Math.abs(E)<=D}isIdentity(v=1e-10){return Xt.is1000(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],v)&&Xt.is1000(this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[4],v)&&Xt.is1000(this._coffs[10],this._coffs[11],this._coffs[8],this._coffs[9],v)&&Xt.is1000(this._coffs[15],this._coffs[12],this._coffs[13],this._coffs[14],v)}static createZero(v){return v?(v.setZero(),v):new Xt}static createRowValues(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U,Sr,Cr){return(Cr=Cr||new Xt)._coffs[0]=v,Cr._coffs[1]=M,Cr._coffs[2]=b,Cr._coffs[3]=E,Cr._coffs[4]=D,Cr._coffs[5]=X,Cr._coffs[6]=z,Cr._coffs[7]=R,Cr._coffs[8]=O,Cr._coffs[9]=Y,Cr._coffs[10]=N,Cr._coffs[11]=B,Cr._coffs[12]=V,Cr._coffs[13]=L,Cr._coffs[14]=U,Cr._coffs[15]=Sr,Cr}static createRows(v,M,b,E,D){return this.createRowValues(v.x,v.y,v.z,v.w,M.x,M.y,M.z,M.w,b.x,b.y,b.z,b.w,E.x,E.y,E.z,E.w,D)}setOriginAndVectors(v,M,b,E){this._coffs[0]=M.x,this._coffs[1]=b.x,this._coffs[2]=E.x,this._coffs[3]=v.x,this._coffs[4]=M.y,this._coffs[5]=b.y,this._coffs[6]=E.y,this._coffs[7]=v.y,this._coffs[8]=M.z,this._coffs[9]=b.z,this._coffs[10]=E.z,this._coffs[11]=v.z,this._coffs[12]=0,this._coffs[13]=0,this._coffs[14]=0,this._coffs[15]=1}static createTransform(v,M){const b=v.matrix,E=v.origin;return Xt.createRowValues(b.coffs[0],b.coffs[1],b.coffs[2],E.x,b.coffs[3],b.coffs[4],b.coffs[5],E.y,b.coffs[6],b.coffs[7],b.coffs[8],E.z,0,0,0,1,M)}static createIdentity(v){return(v=Xt.createZero(v))._coffs[0]=1,v._coffs[5]=1,v._coffs[10]=1,v._coffs[15]=1,v}static createTranslationXYZ(v,M,b,E){return(E=Xt.createZero(E))._coffs[0]=1,E._coffs[5]=1,E._coffs[10]=1,E._coffs[15]=1,E._coffs[3]=v,E._coffs[7]=M,E._coffs[11]=b,E}plusScaled(v,M,b){b=this.clone(b);for(let E=0;E<16;E++)b._coffs[E]+=M*v._coffs[E];return b}static createTranslationAndScaleXYZ(v,M,b,E,D,X,z){return Xt.createRowValues(E,0,0,v,0,D,0,M,0,0,X,b,0,0,0,1,z)}static createBoxToBox(v,M,b,E,D){const X=M.x-v.x,z=M.y-v.y,R=M.z-v.z,O=E.x-b.x,Y=E.y-b.y,N=E.z-b.z,B=K.conditionalDivideFraction(O,X),V=K.conditionalDivideFraction(Y,z),L=K.conditionalDivideFraction(N,R);if(void 0!==B&&void 0!==V&&void 0!==L)return Xt.createTranslationAndScaleXYZ(b.x-B*v.x,b.y-V*v.y,b.z-L*v.z,B,V,L,D)}setFromJSON(v){if(K.isArrayOfNumberArray(v,4,4))for(let M=0;M<4;++M)for(let b=0;b<4;++b)this._coffs[4*M+b]=v[M][b];else this.setZero()}maxDiff(v){let M=0;for(let b=0;b<16;b++)M=Math.max(M,Math.abs(this._coffs[b]-v._coffs[b]));return M}maxAbs(){let v=0;for(let M=0;M<16;M++)v=Math.max(v,Math.abs(this._coffs[M]));return v}isAlmostEqual(v){return K.isSmallMetricDistance(this.maxDiff(v))}isExactEqual(v){return 0===this.maxDiff(v)}toJSON(){const v=[];for(let M=0;M<4;++M){const b=4*M;v.push([this._coffs[b],this._coffs[b+1],this._coffs[b+2],this._coffs[b+3]])}return v}static fromJSON(v){const M=new Xt;return M.setFromJSON(v),M}getSteppedPoint(v,M,b){return Dt.create(this._coffs[v],this._coffs[v+M],this._coffs[v+2*M],this._coffs[v+3*M],b)}columnX(){return this.getSteppedPoint(0,4)}columnY(){return this.getSteppedPoint(1,4)}columnZ(){return this.getSteppedPoint(2,4)}columnW(){return this.getSteppedPoint(3,4)}rowX(){return this.getSteppedPoint(0,1)}rowY(){return this.getSteppedPoint(4,1)}rowZ(){return this.getSteppedPoint(8,1)}rowW(){return this.getSteppedPoint(12,1)}get hasPerspective(){return 0!==this._coffs[12]||0!==this._coffs[13]||0!==this._coffs[14]||1!==this._coffs[15]}diagonal(){return this.getSteppedPoint(0,5)}weight(){return this._coffs[15]}matrixPart(){return xt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[8],this._coffs[9],this._coffs[10])}get asTransform(){if(!this.hasPerspective)return pt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11])}multiplyMatrixMatrix(v,M){M=M&&M!==this&&M!==v?M:new Xt;for(let b=0;b<16;b+=4)for(let E=0;E<4;E++)M._coffs[b+E]=this._coffs[b]*v._coffs[E]+this._coffs[b+1]*v._coffs[E+4]+this._coffs[b+2]*v._coffs[E+8]+this._coffs[b+3]*v._coffs[E+12];return M}multiplyMatrixMatrixTranspose(v,M){M=M&&M!==this&&M!==v?M:new Xt;let b=0;for(let E=0;E<16;E+=4)for(let D=0;D<16;D+=4)M._coffs[b++]=this._coffs[E]*v._coffs[D]+this._coffs[E+1]*v._coffs[D+1]+this._coffs[E+2]*v._coffs[D+2]+this._coffs[E+3]*v._coffs[D+3];return M}multiplyMatrixTransposeMatrix(v,M){M=M&&M!==this&&M!==v?M:new Xt;let b=0;for(let E=0;E<4;E+=1)for(let D=0;D<4;D+=1)M._coffs[b++]=this._coffs[E]*v._coffs[D]+this._coffs[E+4]*v._coffs[D+4]+this._coffs[E+8]*v._coffs[D+8]+this._coffs[E+12]*v._coffs[D+12];return M}cloneTransposed(v){return Xt.createRowValues(this._coffs[0],this._coffs[4],this._coffs[8],this._coffs[12],this._coffs[1],this._coffs[5],this._coffs[9],this._coffs[13],this._coffs[2],this._coffs[6],this._coffs[10],this._coffs[14],this._coffs[3],this._coffs[7],this._coffs[11],this._coffs[15],v)}multiplyXYZW(v,M,b,E,D){return(D=D||Dt.createZero()).set(this._coffs[0]*v+this._coffs[1]*M+this._coffs[2]*b+this._coffs[3]*E,this._coffs[4]*v+this._coffs[5]*M+this._coffs[6]*b+this._coffs[7]*E,this._coffs[8]*v+this._coffs[9]*M+this._coffs[10]*b+this._coffs[11]*E,this._coffs[12]*v+this._coffs[13]*M+this._coffs[14]*b+this._coffs[15]*E)}multiplyBlockedFloat64ArrayInPlace(v){const M=v.length;let b,E,D,X;for(let z=0;z+3<M;z+=4)b=v[z],E=v[z+1],D=v[z+2],X=v[z+3],v[z]=this._coffs[0]*b+this._coffs[1]*E+this._coffs[2]*D+this._coffs[3]*X,v[z+1]=this._coffs[4]*b+this._coffs[5]*E+this._coffs[6]*D+this._coffs[7]*X,v[z+2]=this._coffs[8]*b+this._coffs[9]*E+this._coffs[10]*D+this._coffs[11]*X,v[z+3]=this._coffs[12]*b+this._coffs[13]*E+this._coffs[14]*D+this._coffs[15]*X}multiplyPoint3d(v,M,b){return this.multiplyXYZW(v.x,v.y,v.z,M,b)}multiplyPoint3dArray(v,M,b=1){v.forEach(((v,E)=>{M[E]=this.multiplyXYZW(v.x,v.y,v.z,b,M[E])}))}multiplyTransposeXYZW(v,M,b,E,D){return(D=D||Dt.createZero()).set(this._coffs[0]*v+this._coffs[4]*M+this._coffs[8]*b+this._coffs[12]*E,this._coffs[1]*v+this._coffs[5]*M+this._coffs[9]*b+this._coffs[13]*E,this._coffs[2]*v+this._coffs[6]*M+this._coffs[10]*b+this._coffs[14]*E,this._coffs[3]*v+this._coffs[7]*M+this._coffs[11]*b+this._coffs[15]*E)}rowDotColumn(v,M,b){const E=4*v,D=b;return this._coffs[E]*M._coffs[D]+this._coffs[E+1]*M._coffs[D+4]+this._coffs[E+2]*M._coffs[D+8]+this._coffs[E+3]*M._coffs[D+12]}rowDotXYZW(v,M,b,E,D){const X=4*v;return this._coffs[X]*M+this._coffs[X+1]*b+this._coffs[X+2]*E+this._coffs[X+3]*D}rowDotRow(v,M,b){const E=4*v,D=4*b;return this._coffs[E]*M._coffs[D]+this._coffs[E+1]*M._coffs[D+1]+this._coffs[E+2]*M._coffs[D+2]+this._coffs[E+3]*M._coffs[D+3]}columnDotColumn(v,M,b){const E=v,D=b;return this._coffs[E]*M._coffs[D]+this._coffs[E+4]*M._coffs[D+4]+this._coffs[E+8]*M._coffs[D+8]+this._coffs[E+12]*M._coffs[D+12]}columnDotRow(v,M,b){const E=v,D=4*b;return this._coffs[E]*M._coffs[D]+this._coffs[E+4]*M._coffs[D+1]+this._coffs[E+8]*M._coffs[D+2]+this._coffs[E+12]*M._coffs[D+3]}atIJ(v,M){return this._coffs[4*v+M]}setAtIJ(v,M,b){this._coffs[4*v+M]=b}multiplyXYZWQuietRenormalize(v,M,b,E,D){(D=D||Q.createZero()).set(this._coffs[0]*v+this._coffs[1]*M+this._coffs[2]*b+this._coffs[3]*E,this._coffs[4]*v+this._coffs[5]*M+this._coffs[6]*b+this._coffs[7]*E,this._coffs[8]*v+this._coffs[9]*M+this._coffs[10]*b+this._coffs[11]*E);const X=this._coffs[12]*v+this._coffs[13]*M+this._coffs[14]*b+this._coffs[15]*E,z=K.conditionalDivideCoordinate(D.x,X),R=K.conditionalDivideCoordinate(D.y,X),O=K.conditionalDivideCoordinate(D.z,X);return void 0!==z&&void 0!==R&&void 0!==O&&(D.x=z,D.y=R,D.z=O),D}multiplyPoint4dArrayQuietRenormalize(v,M){v.forEach(((v,b)=>{M[b]=this.multiplyXYZWQuietRenormalize(v.x,v.y,v.z,v.w,M[b])}))}multiplyPoint4d(v,M){return this.multiplyXYZW(v.xyzw[0],v.xyzw[1],v.xyzw[2],v.xyzw[3],M)}multiplyTransposePoint4d(v,M){return this.multiplyTransposeXYZW(v.xyzw[0],v.xyzw[1],v.xyzw[2],v.xyzw[3],M)}multiplyPoint3dQuietNormalize(v,M){return this.multiplyXYZWQuietRenormalize(v.x,v.y,v.z,1,M)}multiplyPoint3dArrayQuietNormalize(v){v.forEach((v=>this.multiplyXYZWQuietRenormalize(v.x,v.y,v.z,1,v)))}addMomentsInPlace(v,M,b,E){this._coffs[0]+=v*v,this._coffs[1]+=v*M,this._coffs[2]+=v*b,this._coffs[3]+=v*E,this._coffs[4]+=M*v,this._coffs[5]+=M*M,this._coffs[6]+=M*b,this._coffs[7]+=M*E,this._coffs[8]+=b*v,this._coffs[9]+=b*M,this._coffs[10]+=b*b,this._coffs[11]+=b*E,this._coffs[12]+=E*v,this._coffs[13]+=E*M,this._coffs[14]+=E*b,this._coffs[15]+=E*E}addScaledInPlace(v,M=1){for(let b=0;b<16;b++)this._coffs[b]+=M*v._coffs[b]}rowOperation(v,M,b,E){if(0===E)return;let D=4*v+b,X=4*M+b;for(let z=b;z<4;z++,D++,X++)this._coffs[X]+=E*this._coffs[D]}determinant(){const v=this._coffs;return K.determinant4x4(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[14],v[15])}createInverse(v){let M=this.columnX().maxAbs();if(0===M)return;const b=1/M;if(M=this.columnY().maxAbs(),0===M)return;const E=1/M;if(M=this.columnZ().maxAbs(),0===M)return;const D=1/M;if(M=this.columnW().maxAbs(),0===M)return;const X=1/M,z=this.columnX(),R=this.columnY(),O=this.columnZ(),Y=this.columnW();z.scale(b,z),R.scale(E,R),O.scale(D,O),Y.scale(X,Y);const N=Dt.perpendicularPoint4dPlane(R,O,Y),B=Dt.perpendicularPoint4dPlane(z,Y,O),V=Dt.perpendicularPoint4dPlane(Y,z,R),L=Dt.perpendicularPoint4dPlane(O,R,z);v=Xt.createRows(N,B,V,L,v);const U=N.dotProduct(z),Sr=B.dotProduct(R),Cr=V.dotProduct(O),kr=L.dotProduct(Y),Fr=v.maxAbs();if(U*Sr>0&&U*Cr>0&&U*kr>0&&void 0!==K.conditionalDivideCoordinate(Fr,U)){const M=1/U;return v.scaleRowsInPlace(b*M,E*M,D*M,X*M),v}}rowArrays(v){return v?[[v(this._coffs[0]),v(this._coffs[1]),v(this._coffs[2]),v(this._coffs[3])],[v(this._coffs[4]),v(this._coffs[5]),v(this._coffs[6]),v(this._coffs[7])],[v(this._coffs[8]),v(this._coffs[9]),v(this._coffs[10]),v(this._coffs[11])],[v(this._coffs[12]),v(this._coffs[13]),v(this._coffs[14]),v(this._coffs[15])]]:[[this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3]],[this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7]],[this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11]],[this._coffs[12],this._coffs[13],this._coffs[14],this._coffs[15]]]}scaleRowsInPlace(v,M,b,E){for(let D=0;D<4;D++)this._coffs[D]*=v;for(let D=4;D<8;D++)this._coffs[D]*=M;for(let D=8;D<12;D++)this._coffs[D]*=b;for(let D=12;D<16;D++)this._coffs[D]*=E}addScaledOuterProductInPlace(v,M,b){let E=v.x*b;this._coffs[0]+=E*M.x,this._coffs[1]+=E*M.y,this._coffs[2]+=E*M.z,this._coffs[3]+=E*M.w,E=v.y*b,this._coffs[4]+=E*M.x,this._coffs[5]+=E*M.y,this._coffs[6]+=E*M.z,this._coffs[7]+=E*M.w,E=v.z*b,this._coffs[8]+=E*M.x,this._coffs[9]+=E*M.y,this._coffs[10]+=E*M.z,this._coffs[11]+=E*M.w,E=v.w*b,this._coffs[12]+=E*M.x,this._coffs[13]+=E*M.y,this._coffs[14]+=E*M.z,this._coffs[15]+=E*M.w}addTranslationSandwichInPlace(v,M,b,E,D){const X=v._coffs[3],z=v._coffs[7],R=v._coffs[11],O=v._coffs[12],Y=v._coffs[13],N=v._coffs[14],B=v._coffs[15],V=M*B,L=b*B,U=E*B;this._coffs[0]+=D*(v._coffs[0]+M*X+O*M+M*V),this._coffs[1]+=D*(v._coffs[1]+b*X+Y*M+M*L),this._coffs[2]+=D*(v._coffs[2]+E*X+N*M+M*U),this._coffs[3]+=D*(X+V),this._coffs[4]+=D*(v._coffs[4]+M*z+O*b+b*V),this._coffs[5]+=D*(v._coffs[5]+b*z+Y*b+b*L),this._coffs[6]+=D*(v._coffs[6]+E*z+N*b+b*U),this._coffs[7]+=D*(z+L),this._coffs[8]+=D*(v._coffs[8]+M*R+O*E+E*V),this._coffs[9]+=D*(v._coffs[9]+b*R+Y*E+E*L),this._coffs[10]+=D*(v._coffs[10]+E*R+N*E+E*U),this._coffs[11]+=D*(R+U),this._coffs[12]+=D*(O+V),this._coffs[13]+=D*(Y+L),this._coffs[14]+=D*(N+U),this._coffs[15]+=D*B}multiplyTranslationSandwichInPlace(v,M,b){const E=this._coffs[3],D=this._coffs[7],X=this._coffs[11],z=this._coffs[12],R=this._coffs[13],O=this._coffs[14],Y=this._coffs[15],N=v*Y,B=M*Y,V=b*Y;this._coffs[0]+=v*E+z*v+v*N,this._coffs[1]+=M*E+R*v+v*B,this._coffs[2]+=b*E+O*v+v*V,this._coffs[3]+=N,this._coffs[4]+=v*D+z*M+M*N,this._coffs[5]+=M*D+R*M+M*B,this._coffs[6]+=b*D+O*M+M*V,this._coffs[7]+=B,this._coffs[8]+=v*X+z*b+b*N,this._coffs[9]+=M*X+R*b+b*B,this._coffs[10]+=b*X+O*b+b*V,this._coffs[11]+=V,this._coffs[12]+=N,this._coffs[13]+=B,this._coffs[14]+=V}}class Rt{constructor(v,M){this.xTest=v,this.yTest=M,this.u0=this.v0=this.u1=this.v1=0,this.numLeftCrossing=this.numRightCrossing=0,this.numHit=0}tryStartEdge(v,M,b,E){return M!==this.yTest&&(this.u0=v-this.xTest,this.v0=M-this.yTest,this.u1=b-this.xTest,this.v1=E-this.yTest,!0)}advance(v,M){const b=v-this.xTest,E=M-this.yTest,D=E*this.v1;if(D>0)return this.u0=this.u1,this.v0=this.v1,this.u1=b,this.v1=E,!0;if(D<0){const v=-this.v1/(E-this.v1),M=this.u1+v*(b-this.u1);return 0===M?(this.numHit++,!1):(M>0?this.numRightCrossing++:this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=b,this.v1=E,!0)}if(0===E)return 0===this.v1?b*this.u1<=0?(this.numHit++,!1):(this.u1=b,this.v1=E,!0):(this.u0=this.u1,this.v0=this.v1,this.u1=b,this.v1=E,!0);const X=this.v0*E;return this.u1>0?X<0&&this.numRightCrossing++:X<0&&this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=b,this.v1=E,!0}classifyCounts(){return this.numHit>0?0:1==(1&this.numLeftCrossing)?1:-1}}class zt{constructor(v,M,b,E,D){this.numStroke=v,this.curveLength=M,this.a0=b,this.a1=E,this.componentData=D}static createWithCurvePrimitive(v,M,b,E,D,X){const z=new zt(M,b,E,D,X);return z.primitive=v,z}static createWithComponentIndex(v=0,M=0,b=0,E=0,D=0){const X=new zt(M,b,E,D);return X.componentIndex=v,X}static createWithCurvePrimitiveAndOptionalParent(v,M,b){const E=M?M.a1:0,D=new zt(0,0,E,E,b);return D.primitive=v,D}addToCountAndLength(v,M){const b=this.a1+M;this.componentData&&this.componentData.push(new zt(v,M,this.a1,b)),this.numStroke+=v,this.curveLength+=M,this.a1=b}isCompatibleComponentStructure(v,M){if(M&&this.numStroke!==v.numStroke)return!1;if(void 0===this.componentData&&void 0===v.componentData)return!0;if(this.componentData&&v.componentData){if(this.componentData.length!==v.componentData.length)return!1;const b=this.componentData.length;for(let E=0;E<b;E++)if(!this.componentData[E].isCompatibleComponentStructure(v.componentData[E],M))return!1;return!0}return!1}clone(){const v=new zt(this.numStroke,this.curveLength,this.a0,this.a1);if(this.componentData){v.componentData=[];for(const M of this.componentData)v.componentData.push(M.clone())}return v}fractionToA(v){return K.interpolate(this.a0,v,this.a1)}}class Nt{range(v,M){M&&M.setNull();const b=M||ut.createNull();return this.extendRange(b,v),b}tryTranslateInPlace(v,M=0,b=0){return this.tryTransformInPlace(pt.createTranslationXYZ(v,M,b))}get children(){}isAlmostEqual(v){if(this.isSameGeometryClass(v)){const M=this.children,b=v.children;if(M&&b){if(M.length!==b.length)return!1;for(let v=0;v<M.length;v++)if(!M[v].isAlmostEqual(b[v]))return!1;return!0}return!M&&!b}return!1}static areAlmostEqual(v,M){return v instanceof Nt&&M instanceof Nt?v.isAlmostEqual(M):void 0===v&&void 0===M}}class Yt{static getRow(v){const M=Yt._allRows;for(0===M.length&&(M.push(new Float64Array([1])),M.push(new Float64Array([1,1])),M.push(new Float64Array([1,2,1])),M.push(new Float64Array([1,3,3,1])),M.push(new Float64Array([1,4,6,4,1])),M.push(new Float64Array([1,5,10,10,5,1])),M.push(new Float64Array([1,6,15,20,15,6,1])),M.push(new Float64Array([1,7,21,35,35,21,7,1])));M.length<=v;){const v=M.length,b=M[v-1],E=new Float64Array(v+1);E[0]=1;for(let M=1;M<v;M++)E[M]=b[M-1]+b[M];E[v]=1,M.push(E)}return M[v]}static getBezierBasisValues(v,M,b){const E=v-1,D=Yt.getRow(E);(void 0===b||b.length<v)&&(b=new Float64Array(v));for(let R=0;R<v;R++)b[R]=D[R];let X=M;for(let R=1;R<v;R++,X*=M)b[R]*=X;const z=1-M;X=z;for(let R=v-2;R>=0;R--,X*=z)b[R]*=X;return b}static getBezierBasisDerivatives(v,M,b){(void 0===b||b.length<v)&&(b=new Float64Array(v));const E=v-1;(b=this.getBezierBasisValues(v-1,M,b))[v-1]=E*b[v-2];for(let D=v-2;D>0;D--)b[D]=E*(b[D-1]-b[D]);return b[0]=-E*b[0],b}}Yt._allRows=[];class Ot{constructor(v){if(v instanceof Float64Array)this.coffs=v.slice();else if(Array.isArray(v)){this.coffs=new Float64Array(v.length);let M=0;for(const b of v)this.coffs[M++]=b}else this.coffs=new Float64Array(v)}allocateToOrder(v){this.coffs.length!==v?this.coffs=new Float64Array(v):this.coffs.fill(0)}createPeer(){return new Vt(this.order)}get order(){return this.coffs.length}copyFrom(v){if(this.order===v.order)for(let M=0;M<this.coffs.length;M++)this.coffs[M]=v.coffs[M];else this.coffs=v.coffs.slice()}scaleInPlace(v){for(let M=0;M<this.coffs.length;M++)this.coffs[M]*=v}addInPlace(v){for(let M=0;M<this.coffs.length;M++)this.coffs[M]+=v}roots(v,M){const b=Vt.create(this);b.addInPlace(-v);const E=Vt.deflateRoots(b);return this.filter01(E,!0)}filter01(v,M=!1){if(!v||!M)return v;let b=!1;for(const E of v)if(K.isIn01(E)){b=!0;break}if(b){const M=[];for(const b of v)K.isIn01(b)&&M.push(b);return M}}zero(){this.coffs.fill(0)}subdivide(v,M,b){const E=this.order;if(M.order!==E||b.order!==E)return!1;const D=1-v;b.copyFrom(this);let X=E-1;for(let z=0;z<E;z++){M.coffs[z]=b.coffs[0];for(let M=0;M<X;M++)b.coffs[M]=D*b.coffs[M]+v*b.coffs[M+1];X--}return!0}static maxAbsDiff(v,M){const b=v.order;if(M.order!==b)return;let E,D=0;for(let X=0;X<b;X++)E=Math.abs(v.coffs[X]-M.coffs[X]),E>D&&(D=E);return D}}class Bt{static accumulateScaledShiftedComponentTimesComponentDelta(v,M,b,E,D,X,z,R){const O=E-1,Y=E,N=E+O-1;if(v.length!==N)return;const B=Yt.getRow(Y-1),V=Yt.getRow(O-1),L=Yt.getRow(N-1);let U;for(let Sr=0;Sr<Y;Sr++){U=D*(z+M[X+Sr*b])*B[Sr];for(let E=0,D=R;E<O;E++,D+=b)v[Sr+E]+=U*V[E]*(M[D+b]-M[D])/L[Sr+E]}}static scaledComponentSum(v,M,b,E,D,X,z,R){const O=E;if(v.length===O)for(let Y=0,N=0;Y<O;Y++,N+=b)v[Y]=X*M[N+D]+R*M[N+z]}static componentDifference(v,M,b,E,D){const X=E-1;if(v.length===X)for(let z=0,R=D;z<X;R+=b,z++)v[z]=M[R+b]-M[R]}static accumulateProduct(v,M,b,E=1){const D=M.length,X=b.length,z=D+X-1;if(v.length!==z)return;let R,O,Y;const N=Yt.getRow(D-1),B=Yt.getRow(X-1),V=Yt.getRow(z-1);for(R=0;R<D;R++)for(Y=E*N[R]*M[R],O=0;O<X;O++)v[R+O]+=Y*B[O]*b[O]/V[R+O]}static accumulateProductWithDifferences(v,M,b,E=1){const D=M.length-1,X=b.length,z=D+X-1;if(v.length!==z)return;let R,O,Y;const N=Yt.getRow(D-1),B=Yt.getRow(X-1),V=Yt.getRow(z-1);for(R=0;R<D;R++)for(Y=E*N[R]*(M[R+1]-M[R]),O=0;O<X;O++)v[R+O]+=Y*B[O]*b[O]/V[R+O]}static univariateDifference(v,M){const b=M.length;if(M.length+1!==b)for(let E=0;E<b;E++)M[E]=v[E+1]-v[E]}static accumulate(v,M,b){if(b.length===M)for(let E=0;E<M;E++)b[E]+=v[E]}}class Vt extends Ot{get order(){return this._order}constructor(v){super(v),this._order=super.order}allocateOrder(v){this._order!==v&&(super.allocateToOrder(v),this._order=v),this.coffs.fill(0)}clone(v=!1){if(v){const v=new Vt(this.order);return v.coffs=this.coffs.slice(0,this.order),v}const M=new Vt(this.coffs.length);return M._order=this._order,M.coffs=this.coffs.slice(),M}static create(v){const M=new Vt(v.order);return M.coffs=v.coffs.slice(),M}static createCoffs(v){return new Vt(v)}static createArraySubset(v,M,b,E){E?E.order!==b&&E.allocateToOrder(b):E=new Vt(b);for(let D=0;D<b;D++)E.coffs[D]=v[M+D];return E}static createProduct(v,M){const b=new Vt(v.order+M.order-1),E=Yt.getRow(v.order-1),D=Yt.getRow(M.order-1),X=Yt.getRow(v.order+M.order-2);for(let z=0;z<v.order;z++){const R=v.coffs[z]*E[z];for(let v=0;v<M.order;v++){const E=M.coffs[v]*D[v],O=z+v,Y=X[O];b.coffs[O]+=R*E/Y}}return b}addSquaredSquaredBezier(v,M){const b=v.length,E=this.order;if(2*b!==E+1)return!1;const D=Yt.getRow(b-1),X=Yt.getRow(E-1),z=this.coffs;for(let R=0;R<b;R++){const E=v[R]*D[R]*M;for(let M=0;M<b;M++){const b=v[M]*D[M],O=R+M,Y=X[O];z[O]+=E*b/Y}}return!0}addConstant(v){for(let M=0;M<this.coffs.length;M++)this.coffs[M]+=v}basisFunctions(v,M){this._basisValues=Yt.getBezierBasisValues(this.order,v,this._basisValues),(!M||M.length<this.order)&&(M=new Float64Array(this.order));let b=0;for(const E of this._basisValues)M[b++]=E;return M}static sumWeightedBlocks(v,M,b,E,D){for(let R=0;R<E;R++)D[R]=0;let X,z=0;for(let R=0;R<M;R++){const M=v[R];for(X=0;X<E;X++)D[X]+=M*b[z++]}}sumBasisFunctions(v,M,b,E){return(!E||E.length<b)&&(E=new Float64Array(b)),this._basisValues=Yt.getBezierBasisValues(this.order,v,this._basisValues),Vt.sumWeightedBlocks(this._basisValues,this.order,M,b,E),E}sumBasisFunctionDerivatives(v,M,b,E){return(!E||E.length<b)&&(E=new Float64Array(b)),this._basisValues=Yt.getBezierBasisDerivatives(this.order,v,this._basisValues),Vt.sumWeightedBlocks(this._basisValues,this.order,M,b,E),E}evaluate(v){this._basisValues=Yt.getBezierBasisValues(this.order,v,this._basisValues);let M=0;for(let b=0;b<this.order;b++)M+=this._basisValues[b]*this.coffs[b];return M}deflateLeft(){const v=this.order,M=v-1,b=Yt.getRow(M-1),E=Yt.getRow(v-1);let D;for(let X=0;X<M;X++)D=this.coffs[X+1],this.coffs[X]=D*E[X+1]/b[X];this._order--}deflateRight(){const v=this.order,M=v-1,b=Yt.getRow(M-1),E=Yt.getRow(v-1);let D,X;for(let z=0;z<M;z++)D=this.coffs[z],X=D*E[z]/b[z],this.coffs[z]=X;this._order--}deflateRoot(v){const M=this.order,b=M-1;if(1===M)return this._order=0,this.coffs[0];if(M<1)return this._order=0,0;const E=Yt.getRow(M-1),D=Yt.getRow(b-1),X=-v,z=1-v;let R=0;if(v>.5){let v,O,Y=this.coffs[0]/X;this.coffs[0]=Y;for(let M=1;M<b;M++)O=this.coffs[M]*E[M],v=(O-Y*z)/X,this.coffs[M]=v/D[M],Y=v;R=this.coffs[M-1]-Y*z}else{let v,O,Y=this.coffs[M-1]/z;this.coffs[M-1]=Y;for(let b=M-2;b>0;b--)O=this.coffs[b]*E[b],v=(O-Y*X)/z,this.coffs[b]=v/D[b-1],Y=v;R=this.coffs[0]-Y*X;for(let M=0;M<b;M++)this.coffs[M]=this.coffs[M+1]}return this._order=b,R}runNewton(v,M=1e-11){const b=this.order-1;let E,D,X=0,z=v;const R=this.order,O=this.coffs,Y=R-1;for(let N=0;N++<10;){Vt._basisBuffer=Yt.getBezierBasisValues(R,z,Vt._basisBuffer),E=0;for(let M=0;M<R;M++)E+=O[M]*Vt._basisBuffer[M];Vt._basisBuffer1=Yt.getBezierBasisValues(Y,z,Vt._basisBuffer1),D=0;for(let M=0;M<Y;M++)D+=(O[M+1]-O[M])*Vt._basisBuffer1[M];if(D*=b,Math.abs(E)>10*Math.abs(D))return;const v=E/D;if(Math.abs(v)<M){if(X++,X>=2)return z-v}else X=0;z-=v}}static deflateRoots(v){const M=[],b=v.coffs;let E,D,X,z,R;for(;v.order>1;){const O=v.order;if(0===b[0]){v.deflateLeft(),M.push(0);continue}let Y=0,N=0;for(let B=1;B<O;B++)if(E=b[B-1],D=b[B],E*D<=0&&(Y++,X=-E/(D-E),z=(B-1+X)/(O-1),R=v.runNewton(z,1e-10),void 0!==R)){M.push(R),v.deflateRoot(R),N++;break}if(!N)return M}return M}}class Lt extends Ot{constructor(v=0,M=0){super(2),this.coffs[0]=v,this.coffs[1]=M}clone(){return new Lt(this.coffs[0],this.coffs[1])}static solveCoffs(v,M){return K.conditionalDivideFraction(-v,M-v)}basisFunctions(v,M){return(!M||M.length<2)&&(M=new Float64Array(2)),M[0]=1-v,M[1]=v,M}sumBasisFunctions(v,M,b,E){(!E||E.length<b)&&(E=new Float64Array(b));const D=1-v;for(let X=0;X<b;X++)E[X]=D*M[X]+v*M[X+b];return E}sumBasisFunctionDerivatives(v,M,b,E){(!E||E.length<b)&&(E=new Float64Array(b));for(let D=0;D<b;D++)E[D]=M[D+b]-M[D];return E}evaluate(v){return(1-v)*this.coffs[0]+v*this.coffs[1]}solve(v){const M=this.coffs[1]-this.coffs[0];return K.conditionalDivideFraction(v-this.coffs[0],M)}roots(v,M){const b=this.solve(v);if(void 0!==b)return!M||K.isIn01(b)?[b]:void 0}}class Ut{constructor(v=1e-11,M=2,b=15){this._numAccepted=0,this.numIterations=0,this._stepSizeTolerance=v,this._successiveConvergenceTarget=M,this._maxIterations=b}testConvergence(v){return Math.abs(v)<this._stepSizeTolerance?(this._numAccepted++,this._numAccepted>=this._successiveConvergenceTarget):(this._numAccepted=0,!1)}runIterations(){for(this._numAccepted=0,this.numIterations=0;this.numIterations++<this._maxIterations&&this.computeStep();){if(this.testConvergence(this.currentStepSize())&&this.applyCurrentStep(!0))return!0;this.applyCurrentStep(!1)}return!1}}class Zt{}class qt extends Ut{constructor(v){super(),this._func=v,this.setTarget(0)}setX(v){return this._currentX=v,!0}getX(){return this._currentX}setTarget(v){this._target=v}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const v=K.conditionalDivideFraction(this._func.currentF-this._target,this._func.currentdFdX);if(void 0!==v)return this._currentStep=v,!0}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Wt{}class Gt extends Ut{constructor(v){super(),this._func=v,this.derivativeH=1e-8}setX(v){return this._currentX=v,!0}getX(){return this._currentX}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const v=this._func.currentF;if(this._func.evaluate(this._currentX+this.derivativeH)){const M=this._func.currentF,b=K.conditionalDivideFraction(v,(M-v)/this.derivativeH);if(void 0!==b)return this._currentStep=b,!0}}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Ht{constructor(){this.currentF=bt.createXYPlane()}}class Jt extends Ut{constructor(v){super(void 0,void 0,100),this._func=v,this._currentStep=J.createZero(),this._currentUV=H.createZero()}setUV(v,M){return this._currentUV.set(v,M),!0}getU(){return this._currentUV.x}getV(){return this._currentUV.y}applyCurrentStep(){return this.setUV(this._currentUV.x-this._currentStep.x,this._currentUV.y-this._currentStep.y)}computeStep(){if(this._func.evaluate(this._currentUV.x,this._currentUV.y)){const v=this._func.currentF;if(Ft.linearSystem2d(v.vectorU.x,v.vectorV.x,v.vectorU.y,v.vectorV.y,v.origin.x,v.origin.y,this._currentStep))return!0}return!1}currentStepSize(){return K.maxAbsXY(this._currentStep.x/(1+Math.abs(this._currentUV.x)),this._currentStep.y/(1+Math.abs(this._currentUV.y)))}}class Kt extends Ht{constructor(v,M){super(),this._curveP=v,this._curveQ=M,this._rayP=Mt.createZero(),this._rayQ=Mt.createZero()}evaluate(v,M){return this._curveP.fractionToPointAndDerivative(v,this._rayP),this._curveQ.fractionToPointAndDerivative(M,this._rayQ),this.currentF.setOriginAndVectorsXYZ(this._rayP.origin.x-this._rayQ.origin.x,this._rayP.origin.y-this._rayQ.origin.y,0,this._rayP.direction.x,this._rayP.direction.y,0,-this._rayQ.direction.x,-this._rayQ.direction.y,0),!0}}class jt extends Zt{constructor(v,M){super(),this._curveP=v,this._pointQ=M,this._planeP=bt.createXYPlane()}evaluate(v){this._curveP.fractionToPointAnd2Derivatives(v,this._planeP);const M=this._planeP.origin.x-this._pointQ.x,b=this._planeP.origin.y-this._pointQ.y,E=this._planeP.vectorU.x,D=this._planeP.vectorU.y,X=this._planeP.vectorV.x,z=this._planeP.vectorV.y;return this.currentF=E*M+D*b,this.currentdFdX=X*M+E*E+z*b+D*D,!0}}class Qt extends Ht{constructor(v,M){super(),this._curveP=v,this._curveQ=M,this._planeP=bt.createXYPlane(),this._planeQ=bt.createXYPlane()}evaluate(v,M){this._curveP.fractionToPointAnd2Derivatives(v,this._planeP),this._curveQ.fractionToPointAnd2Derivatives(M,this._planeQ);const b=this._planeP.origin.x-this._planeQ.origin.x,E=this._planeP.origin.y-this._planeQ.origin.y,D=this._planeP.vectorU.x,X=this._planeP.vectorU.y,z=this._planeQ.vectorU.x,R=this._planeQ.vectorU.y,O=this._planeP.vectorV.x,Y=this._planeP.vectorV.y,N=this._planeQ.vectorV.x,B=this._planeQ.vectorV.y;return this.currentF.setOriginAndVectorsXYZ(D*b+X*E,z*b+R*E,0,O*b+Y*E+D*D+X*X,z*D+R*X,0,-(D*z+X*R),N*b+B*E-z*z-R*R,0),!0}}class $t extends Wt{constructor(){super(),this._parentCurvePrimitive=void 0}startParentCurvePrimitive(v){this._parentCurvePrimitive=v}endParentCurvePrimitive(v){this._parentCurvePrimitive=void 0}}class te extends $t{effectiveCurve(){return this._parentCurvePrimitive?this._parentCurvePrimitive:this._curve}get getDerivativeB(){return this._derivativeB}constructor(v,M){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._derivativeB=0,this._numThisCurve=0,this._plane=v,this._intersections=M,this.startCurvePrimitive(void 0),this._ray=Mt.createZero(),this._newtonSolver=new Gt(this)}startCurvePrimitive(v){this._curve=v,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(v,M,b,E){this.startCurvePrimitive(v),M<1&&(M=1);const D=1/M;for(let X=0;X<=M;X++){const M=K.interpolate(b,X*D,E);v.fractionToPointAndDerivative(M,this._ray),this.announcePointTangent(this._ray.origin,M,this._ray.direction)}}announceSegmentInterval(v,M,b,E,D,X){const z=this._plane.altitude(M),R=this._plane.altitude(b);if(z*R>0)return;const O=Lt.solveCoffs(z,R);if(void 0!==O){const v=K.interpolate(D,O,X);this._newtonSolver.setX(v),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX())}}announceSolutionFraction(v){const M=this.effectiveCurve();M&&(this._ray=M.fractionToPointAndDerivative(v,this._ray),this._intersections.push(vt.createCurveFractionPoint(M,v,this._ray.origin)))}evaluate(v){const M=this.effectiveCurve();return!!M&&(this.currentF=this._plane.altitude(M.fractionToPoint(v)),!0)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const v=K.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);v&&(this._newtonSolver.setX(v),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(v,M,b){this._functionB=this._plane.altitude(v),this._derivativeB=this._plane.velocity(b),this._fractionB=M}announcePointTangent(v,M,b){this.evaluateB(v,M,b),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}}!function(v){v[v.None=0]="None",v[v.OnTangent=1]="OnTangent",v[v.OnCurve=2]="OnCurve"}(Cr||(Cr={}));class ee{static resolveVariantCurveExtendParameterToCurveExtendMode(v,M){return!1===v?Cr.None:!0===v?Cr.OnCurve:Array.isArray(v)?v[M]:v}static correctFraction(v,M){return M<0?ee.resolveVariantCurveExtendParameterToCurveExtendMode(v,0)===Cr.None&&(M=0):M>1&&ee.resolveVariantCurveExtendParameterToCurveExtendMode(v,1)===Cr.None&&(M=1),M}static resolveRadiansToSweepFraction(v,M,b){let E=b.radiansToSignedPeriodicFraction(M);if(!b.isRadiansInSweep(M)){const D=b.fractionPeriod(),X=ee.resolveVariantCurveExtendParameterToCurveExtendMode(v,0),z=ee.resolveVariantCurveExtendParameterToCurveExtendMode(v,1);X!==Cr.None?z!==Cr.None?E=b.radiansToSignedPeriodicFraction(M):E>1&&(E-=D):z!==Cr.None?E<0&&(E+=D):E=K.clamp(E,0,1)}return E}}class ie extends $t{constructor(v,M,b){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._numThisCurve=0,this._spacePoint=v,this._workPoint=Q.create(),this._workRay=Mt.createZero(),this._closestPoint=b,this._extend=M,this.startCurvePrimitive(void 0),this._newtonSolver=new Gt(this)}claimResult(){if(this._closestPoint&&(this._newtonSolver.setX(this._closestPoint.fraction),this._curve=this._closestPoint.curve,this._newtonSolver.runIterations())){let v=this._newtonSolver.getX();v=ee.correctFraction(this._extend,v),this.announceSolutionFraction(v)}return this._closestPoint}needPrimaryGeometryForStrokes(){return!0}startCurvePrimitive(v){this._curve=v,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(v,M,b,E){this.startCurvePrimitive(v),this.announceSolutionFraction(0),this.announceSolutionFraction(1),M<1&&(M=1);const D=1/M;for(let X=0;X<=M;X++){const M=K.interpolate(b,X*D,E);v.fractionToPointAndDerivative(M,this._workRay),this.announceRay(M,this._workRay)}}announceCandidate(v,M,b){const E=this._spacePoint.distance(b);this._closestPoint&&E>this._closestPoint.a||(this._closestPoint=vt.createCurveFractionPoint(v,M,b,this._closestPoint),this._closestPoint.a=E,void 0!==this._parentCurvePrimitive&&(this._closestPoint.curve=this._parentCurvePrimitive))}announceSegmentInterval(v,M,b,E,D,X){let z=this._spacePoint.fractionOfProjectionToLine(M,b,0);this._extend?(0!==D&&(z=Math.max(z,0)),1!==X&&(z=Math.min(z,1))):z=K.clampToStartEnd(z,0,1),this._workPoint=M.interpolate(z,b);const R=K.interpolate(D,z,X);this.announceCandidate(v,R,this._workPoint)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const v=K.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);v&&(this._newtonSolver.setX(v),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(v,M){this._functionB=M.dotProductToPoint(this._spacePoint),this._fractionB=v}announceSolutionFraction(v){this._curve&&this.announceCandidate(this._curve,v,this._curve.fractionToPoint(v))}evaluate(v){let M=this._curve;return this._parentCurvePrimitive&&(M=this._parentCurvePrimitive),!!M&&(this._workRay=M.fractionToPointAndDerivative(v,this._workRay),this.currentF=this._workRay.dotProductToPoint(this._spacePoint),!0)}announceRay(v,M){this.evaluateB(v,M),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}announcePointTangent(v,M,b){this._workRay.set(v,b),this.announceRay(M,this._workRay)}}class se{static mapWeights(v,M,b,E,D,X){const z=b.length;for(let R=0;R<z;R++)D[R]=v+M*b[R],X[R]=M*E[R];return z}static setupGauss1(v,M,b,E){return se.mapWeights(v,M-v,se.gaussX1Interval01,se.gaussW1Interval01,b,E)}static setupGauss2(v,M,b,E){return se.mapWeights(v,M-v,se.gaussX2Interval01,se.gaussW2Interval01,b,E)}static setupGauss3(v,M,b,E){return se.mapWeights(v,M-v,se.gaussX3Interval01,se.gaussW3Interval01,b,E)}static setupGauss5(v,M,b,E){return se.mapWeights(v,M-v,se.gaussX5Interval01,se.gaussW5Interval01,b,E)}static setupGauss4(v,M,b,E){return se.mapWeights(v,M-v,se.gaussX4Interval01,se.gaussW4Interval01,b,E)}static sum1(v,M,b,E){let D=0;for(let X=0;X<b;X++)D+=M[X]*E(v[X]);return D}static doGaussIntegral(v,M,b,E,D=5){const X=new ne(D);E<1&&(E=1);const z=1/E;let R=0;for(let O=1;O<=E;O++){const D=K.interpolate(v,(O-1)*z,M),Y=O===E?M:K.interpolate(v,O*z,M),N=X.mapXAndW(D,Y);for(let v=0;v<N;v++)R+=X.gaussW[v]*b(X.gaussX[v])}return R}}se.gaussX1Interval01=new Float64Array([.5]),se.gaussW1Interval01=new Float64Array([1]),se.gaussX2Interval01=new Float64Array([.21132486540518708,.7886751345948129]),se.gaussW2Interval01=new Float64Array([.5,.5]),se.gaussX3Interval01=new Float64Array([.1127016653792583,.5,.8872983346207417]),se.gaussW3Interval01=new Float64Array([.2777777777777778,.4444444444444444,.2777777777777778]),se.gaussX4Interval01=new Float64Array([.06943184420297371,.33000947820757187,.6699905217924281,.9305681557970262]),se.gaussW4Interval01=new Float64Array([.17392742256872692,.3260725774312731,.3260725774312731,.17392742256872692]),se.gaussX5Interval01=new Float64Array([.04691007703066802,.23076534494715845,.5,.7692346550528415,.9530899229693319]),se.gaussW5Interval01=new Float64Array([.11846344252809454,.23931433524968324,.28444444444444444,.23931433524968324,.11846344252809454]);class ne{mapXAndW(v,M){return this.mapXAndWFunction(v,M,this.gaussX,this.gaussW)}constructor(v){switch(this.gaussX=new Float64Array(7),this.gaussW=new Float64Array(7),(v>5||v<1)&&(v=5),v){case 1:this.mapXAndWFunction=(v,M,b,E)=>se.setupGauss1(v,M,b,E);break;case 2:this.mapXAndWFunction=(v,M,b,E)=>se.setupGauss2(v,M,b,E);break;case 3:this.mapXAndWFunction=(v,M,b,E)=>se.setupGauss3(v,M,b,E);break;case 4:this.mapXAndWFunction=(v,M,b,E)=>se.setupGauss4(v,M,b,E);break;default:this.mapXAndWFunction=(v,M,b,E)=>se.setupGauss5(v,M,b,E)}}}class re{tangentMagnitude(v){return this._ray=this._curve.fractionToPointAndDerivative(v,this._ray),this._ray.direction.magnitude()}get getFraction0(){return this._fraction0}get getFraction1(){return this._fraction1}getSum(){return this._summedLength}constructor(v=0,M=1,b=5){this.startCurvePrimitive(void 0),this._summedLength=0,this._ray=Mt.createZero(),v<M?(this._fraction0=v,this._fraction1=M):(this._fraction0=M,this._fraction1=v),this._gaussMapper=new ne(b)}startCurvePrimitive(v){this._curve=v}startParentCurvePrimitive(v){}endParentCurvePrimitive(v){}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(v,M,b,E){const D=ft.createXX(b,E);if(D.intersectRangeXXInPlace(this._fraction0,this._fraction1),!D.isNull){this.startCurvePrimitive(v),M<1&&(M=1);const b=1/M;for(let v=1;v<=M;v++){const E=D.fractionToPoint((v-1)*b),X=v===M?D.high:D.fractionToPoint(v*b),z=this._gaussMapper.mapXAndW(E,X);for(let v=0;v<z;v++)this._summedLength+=this._gaussMapper.gaussW[v]*this.tangentMagnitude(this._gaussMapper.gaussX[v])}}}announceSegmentInterval(v,M,b,E,D,X){const z=M.distance(b);if(this._fraction0<=D&&X<=this._fraction1)this._summedLength+=z;else{const v=ft.createXX(D,X);v.intersectRangeXXInPlace(this._fraction0,this._fraction1),v.isNull||(this._summedLength+=z*v.length()/(X-D))}}announcePointTangent(v,M,b){}}class oe extends Nt{constructor(){super(),this.geometryCategory="curvePrimitive"}fractionToPointAndUnitTangent(v,M){const b=this.fractionToPointAndDerivative(v,M);return b.trySetDirectionMagnitudeInPlace(1),b}fractionToCurvature(v){const M=this.fractionToPointAnd2Derivatives(v),b=M.vectorU.crossProduct(M.vectorV).magnitude(),E=M.vectorU.magnitude();return K.conditionalDivideFraction(b,E*E*E)}fractionToFrenetFrame(v,M){const b=this.fractionToPointAnd2Derivatives(v);if(!b)return;let E=xt.createRigidFromColumns(b.vectorU,b.vectorV,z.XYZ);if(E)return pt.createRefs(b.origin,E,M);const D=xt.createPerpendicularVectorFavorXYPlane(b.vectorU,b.vectorV);return E=xt.createRigidFromColumns(b.vectorU,D,z.XYZ),E?pt.createRefs(b.origin,E,M):void 0}fractionToSignedXYRadiusOfCurvature(v){const M=this.fractionToPointAnd2Derivatives(v);if(!M)return 0;const b=M.vectorU.crossProductXY(M.vectorV),E=M.vectorU.magnitude();if(0===E)return 0;const D=K.conditionalDivideCoordinate(E*E*E,b);return void 0!==D?D:0}fractionAndDistanceToPointOnTangent(v,M){return this.fractionToPointAndUnitTangent(v).fractionToPoint(M)}curveLength(){const v=new re;return this.emitStrokableParts(v),v.getSum()}curveLengthBetweenFractions(v,M){if(v===M)return 0;if(void 0!==this.getFractionToDistanceScale()){const b=this.curveLength();return Math.abs((M-v)*b)}const b=new re(v,M);return this.emitStrokableParts(b),Math.abs(b.getSum())}rangeBetweenFractions(v,M,b){return this.rangeBetweenFractionsByClone(v,M,b)}rangeBetweenFractionsByClone(v,M,b){if(v===M)return ut.create(this.fractionToPoint(v));const E=this.clonePartialCurve(v,M);return E?E.range(b):ut.createNull()}rangeBetweenFractionsByCount(v,M,b,E,D=0){const X=ut.createNull(),z=Q.create();X.extendPoint(this.startPoint(z)),X.extendPoint(this.endPoint(z));const a=(v,M,b)=>{let D=v;for(let R=0;R<b;R++,D+=M)this.fractionToPoint(D,z),E?X.extendTransformedPoint(E,z):X.extendPoint(z)},R=b-2;if(R>0){const b=1/(R+1)*(M-v);a(v+b,b,R)}if(D>0){const b=X.clone(),E=R+1,z=.5/E*2*(M-v);a(v+.5*z,z,E),X.extendWhenLarger(b,D)}return X}curveLengthWithFixedIntervalCountQuadrature(v,M,b,E=5){if(v>M){const b=v;v=M,M=b}const D=new re(v,M,E);return D.announceIntervalForUniformStepStrokes(this,b,v,M),Math.abs(D.getSum())}moveSignedDistanceFromFraction(v,M,b,E){if(void 0!==this.getFractionToDistanceScale()){const D=this.curveLength(),X=K.conditionalDivideFraction(M,D);return void 0===X?vt.createCurveFractionPointDistanceCurveSearchStatus(this,v,this.fractionToPoint(v),0,U.error):vt.createConditionalMoveSignedDistance(b,this,v,v+X,M,E)}return this.moveSignedDistanceFromFractionGeneric(v,M,b,E)}moveSignedDistanceFromFractionGeneric(v,M,b,E){let D;if(0===M)return vt.createCurveEvaluatedFraction(this,v,E);if(M>0){if(D=1,v>=1){const b=.9;M+=this.curveLengthBetweenFractions(b,v),v=b}}else if(D=0,v<=0){const b=.1;M-=this.curveLengthBetweenFractions(v,b),v=b}const X=this.curveLengthBetweenFractions(v,D);e(X>0);const z=Math.abs(M);if(X<z&&!b)return vt.createConditionalMoveSignedDistance(b,this,v,D,M,E);const R=K.conditionalDivideCoordinate(z,X);if(void 0===R)return(E=vt.createCurveEvaluatedFraction(this,v,E)).curveSearchStatus=U.error,E;const O=M<0?-1:1;let Y=K.interpolate(v,R,D),N=v,B=0;const V=1e-12*X;let L=0;const Sr=Mt.createXAxis();for(let U=0;U<10;U++){const v=B+(Y>N?O:-O)*this.curveLengthBetweenFractions(N,Y),M=z-v;if(Math.abs(M)<V){if(L++,L>1)break}else L=0;if(this.fractionToPointAndDerivative(Y,Sr),N=Y,Y=N+O*M/Sr.direction.magnitude(),N===Y){L=100;break}B=v}return L>1?vt.createConditionalMoveSignedDistance(b,this,v,Y,M,E):((E=vt.createCurveEvaluatedFraction(this,v,E)).curveSearchStatus=U.error,E)}get isExtensibleFractionSpace(){return!1}closestPoint(v,M,b){const E=new ie(v,M,b);return this.emitStrokableParts(E),E.claimResult()}announceClipIntervals(v,M){return!1}clonePartialCurve(v,M){}getFractionToDistanceScale(){}appendPlaneIntersectionPoints(v,M){const b=new te(v,M),E=M.length;return this.emitStrokableParts(b),M.length-E}static snapAndRestrictDetails(v,M=!0,b=!1,E=K.smallAngleRadians,D=K.smallMetricDistance){const X=v.length;let z=0;const R=Q.create(),O=Q.create();let Y;for(let N=0;N<X;N++){Y=void 0;const X=v[N];let B=X.fraction,V=M||K.isIn01(B);X.curve&&(X.curve.startPoint(R),X.curve.endPoint(O)),E>0&&(Math.abs(B)<E&&(B=0,V=!0,X.intervalRole=L.isolatedAtVertex,Y=R),Math.abs(B-1)<E&&(B=1,V=!0,X.intervalRole=L.isolatedAtVertex,Y=O,X.curve&&(Y=X.curve.startPoint(O)))),D>0&&void 0!==X.curve&&(X.point.distance(R)<=D?(B=0,X.intervalRole=L.isolatedAtVertex,Y=R):X.point.distance(O)<=D&&(B=1,X.intervalRole=L.isolatedAtVertex,Y=O)),V&&(b&&(X.fraction=B,void 0!==Y&&X.point.setFrom(Y)),z<N&&(v[z]=X),z++)}z<X&&(v.length=z)}startPoint(v){return this.fractionToPoint(0,v)}endPoint(v){return this.fractionToPoint(1,v)}computeAndAttachRecursiveStrokeCounts(v,M){const b=this.computeStrokeCountForOptions(v),E=this.curveLength();oe.installStrokeCountMap(this,zt.createWithCurvePrimitive(this,b,E,0,E),M)}addMappedStrokesToLineString3D(v,M){const b=M.numPoints();if(v.primitive&&v.primitive===this&&v.numStroke>0)for(let E=0;E<=v.numStroke;E++){const b=E/v.numStroke;M.appendFractionToPoint(this,b)}return M.numPoints()-b}static installStrokeCountMap(v,M,b){b&&b.addToCountAndLength(M.numStroke,M.curveLength),v.strokeData=M}collectCurvePrimitivesGo(v,M,b=!1){v.push(this)}collectCurvePrimitives(v,M=!1,b=!1){const E=void 0===v?[]:v;return this.collectCurvePrimitivesGo(E,M,b),E}projectedParameterRange(v,M){}}class ae extends st{constructor(v){super(),this.data=v}isValidIndex(v){return v>=0&&v<this.data.length}getPoint3dAtCheckedPointIndex(v,M){if(this.isValidIndex(v)){const b=this.data[v];return Q.create(b.x,b.y,b.z,M)}}getPoint3dAtUncheckedPointIndex(v,M){const b=this.data[v];return Q.create(b.x,b.y,b.z,M)}getVector3dAtCheckedVectorIndex(v,M){if(this.isValidIndex(v)){const b=this.data[v];return $.create(b.x,b.y,b.z,M)}}getXAtUncheckedPointIndex(v){return this.data[v].x}getYAtUncheckedPointIndex(v){return this.data[v].y}getZAtUncheckedPointIndex(v){return this.data[v].z}vectorIndexIndex(v,M,b){if(this.isValidIndex(v)&&this.isValidIndex(M))return $.createStartEnd(this.data[v],this.data[M],b)}vectorXYAndZIndex(v,M,b){if(this.isValidIndex(M))return $.createStartEnd(v,this.data[M],b)}crossProductXYAndZIndexIndex(v,M,b,E){if(this.isValidIndex(M)&&this.isValidIndex(b))return $.createCrossProductToPoints(v,this.data[M],this.data[b],E)}crossProductIndexIndexIndex(v,M,b,E){if(this.isValidIndex(v)&&this.isValidIndex(M)&&this.isValidIndex(b))return $.createCrossProductToPoints(this.data[v],this.data[M],this.data[b],E)}accumulateCrossProductIndexIndexIndex(v,M,b,E){const D=this.data;this.isValidIndex(v)&&this.isValidIndex(M)&&this.isValidIndex(b)&&E.addCrossProductToTargetsInPlace(D[v].x,D[v].y,D[v].z,D[M].x,D[M].y,D[M].z,D[b].x,D[b].y,D[b].z)}accumulateScaledXYZ(v,M,b){if(this.isValidIndex(v)){const E=this.data[v];b.x+=M*E.x,b.y+=M*E.y,b.z+=M*E.z}}get length(){return this.data.length}push(v){this.data.push(v.clone())}pushXYZ(v,M,b){this.data.push(Q.create(void 0===v?0:v,void 0===M?0:M,void 0===b?0:b))}back(v){if(this.data.length>0)return this.data[this.data.length-1].clone(v)}front(v){if(this.data.length>0)return this.data[0].clone(v)}pop(){this.data.length>0&&this.data.pop()}clear(){this.data.length=0}reverseInPlace(){this.data.reverse()}distanceSquaredIndexIndex(v,M){const b=this.data.length;if(v>=0&&v<b&&M>=0&&M<b)return this.data[v].distanceSquared(this.data[M])}distanceIndexIndex(v,M){const b=this.data.length;if(v>=0&&v<b&&M>=0&&M<b)return this.data[v].distance(this.data[M])}cyclicIndex(v){return v%this.data.length}}function ce(v,M,b){if(void 0!==M){const E=M*b;if(E>=0&&E<=v)return E}return v}class he{static preciseSum(v){const M=v.length;if(0===M)return 0;let b,E,D=v[0],X=0;for(let z=1;z<M;z++)b=v[z]-X,E=D+b,X=E-D-b,D=E;return D}static isExactEqual(v,M){if(v&&M){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(v[b]!==M[b])return!1;return!0}return void 0===v&&void 0===M}static isAlmostEqual(v,M,b=K.smallMetricDistance){if(v&&M){if(v.length!==M.length)return!1;for(let E=0;E<v.length;E++)if(Math.abs(v[E]-M[E])>b)return!1;return!0}return void 0===v&&void 0===M}static sum(v){let M=0;for(const b of v)M+=b;return M}static isCoordinateInArray(v,M){if(M)for(const b of M)if(K.isSameCoordinate(v,b))return!0;return!1}static maxAbsArray(v){const M=v.length;if(0===M)return 0;let b=Math.abs(v[0]);for(let E=1;E<M;E++){const M=Math.abs(v[E]);b<M&&(b=M)}return b}static maxAbsTwo(v,M){return(v=Math.abs(v))>(M=Math.abs(M))?v:M}static maxAbsDiff(v,M){let b=0;const E=Math.min(v.length,M.length);for(let D=0;D<E;D++)b=Math.max(b,Math.abs(v[D]-M[D]));return b}static maxAbsDiffFloat64(v,M){let b=0;const E=Math.min(v.length,M.length);for(let D=0;D<E;D++)b=Math.max(b,Math.abs(v[D]-M[D]));return b}static createArrayWithMaxStepSize(v,M,b){if(v===M)return[v];const E=M-v,D=Math.max(1,Math.floor(Math.abs(E/b))),X=[];X.push(v);for(let z=1;z<D;z++)X.push(v+z/D*E);return X.push(M),X}static create(v){const M=[];for(const b of v)M.push(b);return M}static copy2d(v){const M=[];for(const b of v){const v=[];for(const M of b)v.push(M);M.push(v)}return M}static copy3d(v){const M=[];for(const b of v){const v=[];for(const M of b){const b=[];for(const v of M)b.push(v);v.push(b)}M.push(v)}return M}static unpack2d(v,M){if(!(M<1))return de.unpackNumbersToNestedArrays(v,M)}static unpack3d(v,M,b){if(!(b<1||M<1))return de.unpackNumbersToNestedArraysIJK(v,b,M)}static pack(v){const M=v.length;let b=0,E=0,D=0;M>0&&(D=M,Array.isArray(v[0])&&(b=v[0].length,b>0&&(D*=b,Array.isArray(v[0][0])&&(E=v[0][0].length,E>0&&(D*=E)))));const X=new Float64Array(D);if(E>0){const D=v;for(let v=0,z=0;v<M;++v)for(let M=0;M<b;++M)for(let b=0;b<E;++b)X[z++]=D[v][M][b]}else if(b>0){const E=v;for(let v=0,D=0;v<M;++v)for(let M=0;M<b;++M)X[D++]=E[v][M]}else if(M>0){const b=v;for(let v=0,E=0;v<M;++v)X[E++]=b[v]}return X}static cloneWithStartAndEndMultiplicity(v,M,b){const E=[];if(void 0===v||0===v.length)return E;let D=1;const X=v[0],z=v[v.length-1];for(;D<v.length&&v[D]===X;)D++;let R=1;const O=v.length-1;for(;O-R>=0&&v[O-R]===z;)R++;for(let Y=0;Y<M;Y++)E.push(X);for(let Y=D;Y+R<v.length;Y++)E.push(v[Y]);for(let Y=0;Y<b;Y++)E.push(z);return E}static linearCombination(v,M){const b=Math.min(v.length,M.length);let E=0;for(let D=0;D<b;++D)E+=M[D]*v[D];return E}static linearCombinationOfColors(v,M){const b=Math.min(v.length,M.length),E=[0,0,0,0];for(let D=0,X=0;D<4;++D,X+=8){for(let z=0;z<b;++z){const b=K.clamp(M[z],0,1),R=v[z]>>>X&255;E[D]+=b*R}E[D]=(255&Math.floor(E[D]))<<X}return E[0]|E[1]|E[2]|E[3]}}class le{static packPointsAndWeightsToFloat64Array(v,M,b){let E;if(Array.isArray(v)&&v[0]instanceof Q){if(E=v,E.length!==M.length)return;const D=4*E.length;(!b||b.length<D)&&(b=new Float64Array(D));for(let v=0,X=0;X<E.length;X++)b[v++]=E[X].x,b[v++]=E[X].y,b[v++]=E[X].z,b[v++]=M[X];return b}E=v;const D=M.length;if(E.length!==3*D)return;const X=4*D;(!b||b.length<X)&&(b=new Float64Array(X));for(let z=0,R=0;R<D;R++){const v=3*R;b[z++]=E[v],b[z++]=E[v+1],b[z++]=E[v+2],b[z++]=M[R]}return b}static packToFloat64Array(v,M){const b=4*v.length;(!M||M.length<b)&&(M=new Float64Array(b));let E=0;for(const D of v)M[E++]=D.x,M[E++]=D.y,M[E++]=D.z,M[E++]=D.w;return M}static unpackToPoint4dArray(v){const M=[];for(let b=0;b+3<v.length;b+=4)M.push(Dt.create(v[b],v[b+1],v[b+2],v[b+3]));return M}static unpackFloat64ArrayToPointsAndWeights(v,M,b,E=((v,M,b)=>Q.create(v,M,b))){M.length=0,b.length=0;for(let D=0;D+3<v.length;D+=4)M.push(E(v[D],v[D+1],v[D+2])),b.push(v[D+3])}static multiplyInPlace(v,M){const b=M.length,E=le._workPoint4d;for(let D=0;D+3<b;D+=4)v.multiplyXYZW(M[D],M[D+1],M[D+2],M[D+3],E),M[D]=E.x,M[D+1]=E.y,M[D+2]=E.z,M[D+3]=E.w}static isAlmostEqual(v,M){if(v&&M){if(v instanceof Float64Array&&M instanceof Float64Array){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(!K.isSameCoordinate(v[b],M[b]))return!1}else if(Array.isArray(v)&&Array.isArray(M)){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(!v[b].isAlmostEqual(M[b]))return!1}else{const b=v instanceof Float64Array?M:v,E=v instanceof Float64Array?v:M;if(E.length!==4*b.length)return!1;for(let v=0;v<b.length;++v)if(!(K.isSameCoordinate(b[v].x,E[4*v])&&K.isSameCoordinate(b[v].y,E[4*v+1])&&K.isSameCoordinate(b[v].z,E[4*v+2])&&K.isSameCoordinate(b[v].w,E[4*v+3])))return!1}return!0}return void 0===v&&void 0===M}static isCloseToPlane(v,M,b=K.smallMetricDistance){if(Array.isArray(v)){for(const E of v)if(Math.abs(M.altitudeXYZW(E.x,E.y,E.z,E.w))>b)return!1}else if(v instanceof Float64Array){const E=v.length;for(let D=0;D+2<E;D+=4)if(Math.abs(M.altitudeXYZW(v[D],v[D+1],v[D+2],v[D+3]))>b)return!1}return!0}}le._workPoint4d=Dt.create();class de{static packToFloat64Array(v,M){const b=3*v.length;(!M||M.length<b)&&(M=new Float64Array(b));let E=0;for(const D of v)M[E++]=D.x,M[E++]=D.y,M[E++]=D.z;return M}static evaluateTrilinearWeights(v,M,b,E,D,X,z){v[0]=M*E*X,v[1]=b*E*X,v[2]=M*D*X,v[3]=b*D*X,v[4]=M*E*z,v[5]=b*E*z,v[6]=M*D*z,v[7]=b*D*z}static sumWeightedX(v,M){let b=0;const E=v.length;for(let D=0;D<E;D++)b+=v[D]*M[D].x;return b}static sumWeightedY(v,M){let b=0;const E=v.length;for(let D=0;D<E;D++)b+=v[D]*M[D].y;return b}static sumWeightedZ(v,M){let b=0;const E=v.length;for(let D=0;D<E;D++)b+=v[D]*M[D].z;return b}static evaluateTrilinearPoint(v,M,b,E,D){let X;D||(D=Q.create(0,0,0)),this.evaluateTrilinearWeights(this._weightUVW,1-M,M,1-b,b,1-E,E);for(let z=0;z<8;z++)X=this._weightUVW[z],D.x+=X*v[z].x,D.y+=X*v[z].y,D.z+=X*v[z].z;return D}static evaluateTrilinearDerivativeTransform(v,M,b,E,D){return this.evaluateTrilinearWeights(this._weightUVW,1-M,M,1-b,b,1-E,E),this.evaluateTrilinearWeights(this._weightDU,-1,1,1-b,b,1-E,E),this.evaluateTrilinearWeights(this._weightDV,1-M,M,-1,1,1-E,E),this.evaluateTrilinearWeights(this._weightDW,1-M,M,1-b,b,-1,1),pt.createRowValues(this.sumWeightedX(this._weightDU,v),this.sumWeightedX(this._weightDV,v),this.sumWeightedX(this._weightDW,v),this.sumWeightedX(this._weightUVW,v),this.sumWeightedY(this._weightDU,v),this.sumWeightedY(this._weightDV,v),this.sumWeightedY(this._weightDW,v),this.sumWeightedY(this._weightUVW,v),this.sumWeightedZ(this._weightDU,v),this.sumWeightedZ(this._weightDV,v),this.sumWeightedZ(this._weightDW,v),this.sumWeightedZ(this._weightUVW,v),D)}static unpackNumbersToPoint3dArray(v){const M=[];for(let b=0;b+2<v.length;b+=3)M.push(Q.create(v[b],v[b+1],v[b+2]));return M}static unpackNumbersToNestedArrays(v,M){const b=[],E=v.length;let D=0,X=0;for(;D<E;){const z=[];for(X=D+M,X>E&&(X=E);D<X;D++)z.push(v[D]);b.push(z)}return b}static unpackNumbersToNestedArraysIJK(v,M,b){const E=[],D=v.length;let X,z=0,R=0;for(;z<D;){const O=[];for(X=z+M*b;z<X;){const b=[];for(R=z+M,R>D&&(R=D);z<R;z++)b.push(v[z]);O.push(b)}E.push(O)}return E}static multiplyInPlace(v,M){const b=Q.create(),E=M.length;for(let D=0;D+2<E;D+=3)v.multiplyXYZ(M[D],M[D+1],M[D+2],b),M[D]=b.x,M[D+1]=b.y,M[D+2]=b.z}static isAlmostEqual(v,M){if(v&&M){if(v instanceof Float64Array&&M instanceof Float64Array){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(!K.isSameCoordinate(v[b],M[b]))return!1}else if(Array.isArray(v)&&Array.isArray(M)){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(!v[b].isAlmostEqual(M[b]))return!1}else{const b=v instanceof Float64Array?M:v,E=v instanceof Float64Array?v:M;if(E.length!==3*b.length)return!1;for(let v=0;v<b.length;++v)if(!K.isSameCoordinate(b[v].x,E[3*v])||!K.isSameCoordinate(b[v].y,E[3*v+1])||!K.isSameCoordinate(b[v].z,E[3*v+2]))return!1}return!0}return void 0===v&&void 0===M}static centroid(v,M){if(v instanceof it){M=Q.create(0,0,0,M);const b=Q.create();if(v.length>0){for(let E=0;E<v.length;E++)v.getPoint3dAtCheckedPointIndex(E,b),M.x+=b.x,M.y+=b.y,M.z+=b.z;M.scaleInPlace(1/v.length)}return M}const b=new ae(v);return this.centroid(b)}static indexOfMostDistantPoint(v,M,b){if(0===v.length)return;let E,D=-1,X=-1;for(let z=0;z<v.length;z++)E=M.distance(v[z]),E>D&&(M.vectorTo(v[z],b),D=E,X=z);return X}static indexOfPointWithMaxCrossProductMagnitude(v,M,b,E){if(0===v.length)return;let D,X,z=-1,R=-1;for(let O=0;O<v.length;O++)X=M.vectorTo(v[O],X),D=X.crossProductMagnitude(b),D>z&&(E.setFrom(X),z=D,R=O);return R}static closestPointIndex(v,M){let b,E=-1,D=Number.MAX_VALUE;const X=M.x,z=M.y,R=M.z;for(let O=0;O<v.length;O++)b=K.distanceXYZXYZ(X,z,R,v[O].x,v[O].y,v[O].z),b<D&&(E=O,D=b);return E}static isCloseToPlane(v,M,b=K.smallMetricDistance){if(Array.isArray(v)){let E;for(E of v)if(Math.abs(M.altitude(E))>b)return!1}else if(v instanceof Float64Array){const E=v.length;for(let D=0;D+2<E;D+=3)if(Math.abs(M.altitudeXYZ(v[D],v[D+1],v[D+2]))>b)return!1}return!0}static sumEdgeLengths(v,M=!1,b){let E=0;if(Array.isArray(v)){const D=ce(v.length,b,1)-1;for(let M=0;M<D;M++)E+=v[M].distance(v[M+1]);M&&D>0&&(E+=v[0].distance(v[D]))}else if(v instanceof Float64Array){const D=ce(v.length,b,3);let X=0;for(;X+5<D;X+=3)E+=K.hypotenuseXYZ(v[X+3]-v[X],v[X+4]-v[X+1],v[X+5]-v[X+2]);M&&X>=3&&(E+=K.hypotenuseXYZ(v[0]-v[X],v[1]-v[X+1],v[2]-v[X+2]))}return E}static countNonDuplicates(v,M=K.smallMetricDistance){let b=v.length;for(;b>1&&v[0].isAlmostEqual(v[b-1],M);)b--;for(let E=0;E+1<b;E++)if(v[E].isAlmostEqual(v[E+1],M))return 0;return b}static clonePoint3dArray(v){const M=[];if(0===v.length)return M;if(v instanceof Float64Array){for(let b=0;b+2<v.length;b+=3)M.push(Q.create(v[b],v[b+1],v[b+2]));return M}for(const b of v)Array.isArray(b)?M.push(Q.create(b[0],b[1],b[2])):M.push(Q.create(b.x,b.y,b.z));return M}static clonePoint2dArray(v){return v.map((v=>H.create(v.x,v.y)))}static cloneWithMaxEdgeLength(v,M){if(0===v.length)return[];const b=[v[0]];for(let E=1;E<v.length;E++){const D=v[E-1].distance(v[E]),X=K.stepCount(M,D,1);for(let M=1;M<X;M++)b.push(v[E-1].interpolate(M/X,v[E]));b.push(v[E])}return b}static xyzToArray(v,M,b){return[v,M,b]}static cloneDeepJSONNumberArrays(v){const M=new ht(((v,M,b)=>this.xyzToArray(v,M,b)));return lt.streamXYZ(v,M),M.claimResult()}static cloneXYZPropsAsNumberArray(v){const M=[];for(const b of v)if(b instanceof Q)M.push([b.x,b.y,b.z]);else if(Array.isArray(b)){const v=b.length>0?b[0]:0,E=b.length>1?b[1]:0,D=b.length>2?b[2]:0;M.push([v,E,D])}else{const v=void 0!==b.x?b.x:0,E=void 0!==b.y?b.y:0,D=void 0!==b.z?b.z:0;M.push([v,E,D])}return M}static cloneXYZPropsAsFloat64Array(v){const M=new Float64Array(3*v.length);let b=0;for(const E of v)E instanceof Q?(M[b++]=E.x,M[b++]=E.y,M[b++]=E.z):Array.isArray(E)?(M[b++]=E.length>0?E[0]:0,M[b++]=E.length>1?E[1]:0,M[b++]=E.length>2?E[2]:0):(M[b++]=void 0!==E.x?E.x:0,M[b++]=void 0!==E.y?E.y:0,M[b++]=void 0!==E.z?E.z:0);return M}static cloneDeepXYZPoint3dArrays(v){const M=new ht(((v,M,b)=>Q.create(v,M,b)));return lt.streamXYZ(v,M),M.claimResult()}static distanceIndexedPointBToSegmentAC(v,M,b,E,D){const X=$.createStartEnd(v[M],v[E]),z=$.createStartEnd(v[M],v[b]),R=X.dotProduct(X),O=X.dotProduct(z),Y=K.conditionalDivideFraction(O,R);if(void 0===Y)return z.magnitude();if(!D){if(Y>1)return v[b].distance(v[E]);if(Y<0)return z.magnitude()}const N=z.magnitudeSquared()-Y*Y*R;return N<=0?0:Math.sqrt(N)}static computeConvexHullXY(v,M,b,E=!1){M.length=0,b.length=0;let D=v.length;const X=v.slice(0,D);if(X.sort(((v,M)=>K.lexicalXYLessThan(v,M))),D<3){for(const v of X)M.push(v);return void(E&&X.length>0&&M.push(X[0]))}M.push(X[0]),M.push(X[1]);let z=0;for(let O=2;O<D;O++){const v=X[O];let b=M.length-1;for(;b>=1&&M[b-1].crossProductToPointsXY(M[b],v)<=0;)X[z++]=M[b],b--,M.pop();M.push(v)}const R=M.length-1;X.length=z,X.push(M[0]),X.sort(((v,M)=>K.lexicalXYLessThan(v,M))),D=X.length,M.push(X[D-1]);for(let O=D-1;O-- >0;){const v=X[O];let E=M.length-1;for(;E>R&&M[E-1].crossProductToPointsXY(M[E],v)<=0;)b.push(M[E]),E--,M.pop();O>0&&M.push(v)}E&&M.push(M[0])}static minMaxPoints(v){if(0===v.length)return;const M={minXPoint:v[0].clone(),maxXPoint:v[0].clone(),minYPoint:v[0].clone(),maxYPoint:v[0].clone()};let b;for(let E=1;E<v.length;E++)b=v[E],b.x<M.minXPoint.x&&M.minXPoint.setFromPoint3d(b),b.x>M.maxXPoint.x&&M.maxXPoint.setFromPoint3d(b),b.y<M.minYPoint.y&&M.minYPoint.setFromPoint3d(b),b.y>M.maxYPoint.y&&M.maxYPoint.setFromPoint3d(b);return M}}de._weightUVW=new Float64Array(8),de._weightDU=new Float64Array(8),de._weightDV=new Float64Array(8),de._weightDW=new Float64Array(8);class ue{static decomposeLU(v,M,b){const E=v-1,D=Math.floor(M/2);let X;for(let z=0;z<=E;z++){const v=Math.min(E,z+D);for(let E=z;E<=v;E++){X=0;for(let v=Math.max(0,E-D);v<z;v++)X+=b[z*M+v-z+D]*b[v*M+E-v+D];b[z*M+E-z+D]-=X}for(let E=z+1;E<=v;E++){X=0;for(let v=Math.max(0,E-D);v<z;v++)X+=b[E*M+v-E+D]*b[v*M+z-v+D];if(Math.abs(b[z*M+D])<1e-9)return!1;b[E*M+z-E+D]=(b[E*M+z-E+D]-X)/b[z*M+D]}}return!0}static arrayAddScaledBlock(v,M,b,E){const D=v.length;let X=D*b;for(let z=0;z<D;z++,X++)v[z]+=M[X]*E}static blockAssignBlockMinusArray(v,M,b,E,D){const X=D.length;let z=M*X,R=E*X;for(let O=0;O<X;O++,R++,z++)v[z]=b[R]-D[O]}static blockSumOfScaledBlockScaledArray(v,M,b,E,D,X,z){const R=X.length;let O=M*R,Y=E*R;for(let N=0;N<R;N++,Y++,O++)v[O]=b[Y]*D+X[N]*z}static solveBandedSystemMultipleRHS(v,M,b,E,D){if(!this.decomposeLU(v,M,b))return;const X=v-1,z=Math.floor(M/2),R=new Float64Array(E),O=new Float64Array(E*v),Y=new Float64Array(E*v);for(let N=0;N<=X;N++){R.fill(0);for(let v=Math.max(0,N-z);v<N;v++)this.arrayAddScaledBlock(R,O,v,b[N*M+v-N+z]);this.blockAssignBlockMinusArray(O,N,D,N,R)}for(let N=X;N>=0;N--){const v=K.conditionalDivideCoordinate(1,b[N*M+z]);if(void 0===v)return;R.fill(0);const E=Math.min(X,N+z);for(let D=N+1;D<=E;D++)this.arrayAddScaledBlock(R,Y,D,b[N*M+D-N+z]);this.blockSumOfScaledBlockScaledArray(Y,N,O,N,v,R,-v)}return Y}static multiplyBandedTimesFull(v,M,b,E,D){const X=new Float64Array(D.length),z=Math.floor(M/2);let R,O,Y,N;for(let B=0;B<v;B++){O=B-z,O<0&&(O=0),Y=B+z+1,Y>v&&(Y=v),N=z+B*(M-1);for(let v=0;v<E;v++){R=0;for(let M=O;M<Y;M++)R+=b[N+M]*D[M*E+v];X[B*E+v]=R}}return X}}!function(v){v[v.None=0]="None",v[v.OpenByAddingControlPoints=1]="OpenByAddingControlPoints",v[v.OpenByRemovingKnots=2]="OpenByRemovingKnots"}(kr||(kr={}));class fe{get leftKnot(){return this._knot0}get rightKnot(){return this._knot1}get leftKnotIndex(){return this.degree-1}get rightKnotIndex(){return this.knots.length-this.degree}get wrappable(){return void 0===this._wrapMode?kr.None:this._wrapMode}set wrappable(v){this._wrapMode=v}get numSpans(){return this.rightKnotIndex-this.leftKnotIndex}constructor(v,M,b){this.degree=M,this._wrapMode=b,this._knot0=0,this._knot1=1,Array.isArray(v)?(this.knots=new Float64Array(v.length),this.setKnots(v),this.setupFixedValues()):v instanceof Float64Array?(this.knots=v.slice(),this.setupFixedValues()):this.knots=new Float64Array(v)}clone(){return new fe(this.knots,this.degree,this.wrappable)}setupFixedValues(){this.degree>0&&this.knots.length>this.degree&&(this._knot0=this.knots[this.degree-1],this._knot1=this.knots[this.knots.length-this.degree])}get knotLength01(){return this._knot1-this._knot0}testClosable(v){void 0===v&&(v=this.wrappable);const M=this.degree,b=this.leftKnotIndex,E=this.rightKnotIndex;if(v===kr.OpenByAddingControlPoints){const v=this.rightKnot-this.leftKnot,D=E-b;for(let E=0;E<b+M;E++){const M=E+D;if(Math.abs(this.knots[E]+v-this.knots[M])>=fe.knotTolerance)return!1}return!0}if(v===kr.OpenByRemovingKnots){const v=M-1,D=this.leftKnot,X=this.rightKnot;for(let M=0;M<v;M++){if(Math.abs(D-this.knots[b-M-1])>=fe.knotTolerance)return!1;if(Math.abs(X-this.knots[E+M+1])>=fe.knotTolerance)return!1}return!0}return!1}isAlmostEqual(v){return this.degree===v.degree&&he.isAlmostEqual(this.knots,v.knots,fe.knotTolerance)}getKnotMultiplicity(v){let M=0;for(const b of this.knots)if(Math.abs(b-v)<fe.knotTolerance)++M;else if(v<b)break;return M}getKnotMultiplicityAtIndex(v){let M=0;if(v>=0&&v<this.knots.length){const b=this.knots[v];++M;for(let E=v-1;E>=0;--E){const v=this.knots[E];if(Math.abs(v-b)<fe.knotTolerance)++M;else if(b>v)break}for(let E=v+1;E<this.knots.length;++E){const v=this.knots[E];if(Math.abs(v-b)<fe.knotTolerance)++M;else if(b<v)break}}return M}normalize(){if(this.knotLength01<fe.knotTolerance)return!1;const v=1/this.knotLength01,M=this.leftKnot;for(let b=0;b<this.knots.length;++b)this.knots[b]=(this.knots[b]-M)*v;for(let b=this.rightKnotIndex-1;b>this.leftKnotIndex&&this.knots[b]===this.knots[this.rightKnotIndex];--b)this.knots[b]=1;for(let b=this.rightKnotIndex+1;b<this.knots.length&&this.knots[b]===this.knots[this.rightKnotIndex];++b)this.knots[b]=1;return this.knots[this.rightKnotIndex]=1,this.setupFixedValues(),!0}setKnots(v,M){const b=M?v.length-2:v.length;if(b!==this.knots.length&&(this.knots=new Float64Array(b)),M)for(let E=1;E+1<v.length;E++)this.knots[E-1]=v[E];else for(let E=0;E<v.length;E++)this.knots[E]=v[E];this.setupFixedValues()}setKnotsCapture(v){this.knots=v,this.setupFixedValues()}static createUniformClamped(v,M,b,E){const D=new fe(v+M-1,M);let X=0;for(let R=0;R<M;R++)D.knots[X++]=b;const z=1/(v-M);for(let R=1;R+M<v;R++)D.knots[X++]=b+R*z*(E-b);for(let R=0;R<M;R++)D.knots[X++]=E;return D.setupFixedValues(),D}static createUniformWrapped(v,M,b,E){const D=new fe(v+2*M-1,M),X=1/v;for(let z=1-M,R=0;z<v+M;z++,R++)D.knots[R]=K.interpolate(b,z*X,E);return D.setupFixedValues(),D}static create(v,M,b){const E=b?v.length-2:v.length,D=new fe(E,M);return D.setKnots(v,b),D}grevilleKnot(v){if(v<0)return this.leftKnot;if(v>this.rightKnotIndex)return this.rightKnot;let M=0;for(let b=v;b<v+this.degree;b++)M+=this.knots[b];return M/this.degree}createBasisArray(){return new Float64Array(this.degree+1)}baseKnotFractionToKnot(v,M){const b=this.knots[v];return b+(M=K.clamp(M,0,1))*(this.knots[v+1]-b)}spanFractionToKnot(v,M){const b=this.spanIndexToLeftKnotIndex(v);return M=K.clamp(M,0,1),this.knots[b]+M*(this.knots[b+1]-this.knots[b])}spanFractionToFraction(v,M){return(this.spanFractionToKnot(v,M)-this.leftKnot)/(this.rightKnot-this.leftKnot)}fractionToKnot(v){return v=K.clamp(v,0,1),K.interpolate(this.knots[this.degree-1],v,this.knots[this.knots.length-this.degree])}evaluateBasisFunctions(v,M,b){if(b.length<this.degree+1)return!1;if(b[0]=1,this.degree<1)return!0;const E=this.knots[v],D=this.knots[v+1];if(b[1]=(M-E)/(D-E),b[0]=1-b[1],this.degree<2)return!0;for(let X=1;X<this.degree;X++){let E=v-X,D=E+X+1,z=0;for(let v=0;v<=X;v++){const X=this.knots[E++],R=(M-X)/(this.knots[D++]-X),O=b[v]*R,Y=b[v]*(1-R);b[v]=z+Y,z=O}b[X+1]=z}return!0}evaluateBasisFunctions1(v,M,b,E,D){if(b.length<this.degree+1)return!1;if(E.length<this.degree+1)return!1;if(D&&D.length<this.degree+1)return!1;if(b[0]=1,E[0]=0,this.degree<1)return!0;const X=this.knots[v];let z=1/(this.knots[v+1]-X);if(b[1]=(M-X)*z,b[0]=1-b[1],E[0]=-z,E[1]=z,D&&(D[0]=0,D[1]=0),this.degree<2)return!0;for(let R=1;R<this.degree;R++){let X=v-R,O=X+R+1,Y=0,N=0,B=0;for(let v=0;v<=R;v++){const R=this.knots[X++];z=1/(this.knots[O++]-R);const V=(M-R)*z,L=1-V,U=b[v]*V,Sr=b[v]*L,Cr=E[v]*V+b[v]*z,kr=E[v]*L-b[v]*z,Fr=2*E[v]*z;if(b[v]=Y+Sr,E[v]=N+kr,Y=U,N=Cr,D){const M=D[v]*V+Fr,b=D[v]*L-Fr;D[v]=B+b,B=M}}b[R+1]=Y,E[R+1]=N,D&&(D[R+1]=B)}return!0}knotToLeftKnotIndex(v){for(let M=this.leftKnotIndex;M<this.rightKnotIndex;++M)if(v<this.knots[M+1])return M;for(let M=this.rightKnotIndex;M>this.leftKnotIndex;--M)if(this.knots[M]-this.knots[M-1]>=fe.knotTolerance)return M-1;return this.rightKnotIndex-1}spanIndexToLeftKnotIndex(v){const M=this.degree;return v<=0?M-1:Math.min(v+M-1,this.knots.length-M-1)}spanIndexToSpanLength(v){const M=this.spanIndexToLeftKnotIndex(v);return this.knots[M+1]-this.knots[M]}isIndexOfRealSpan(v){return v>=0&&v<this.numSpans&&!K.isSmallMetricDistance(this.spanIndexToSpanLength(v))}reflectKnots(){const v=this.leftKnot,M=this.rightKnot,b=this.knots.length;for(let E=0;E<b;E++)this.knots[E]=v+(M-this.knots[E]);this.knots.reverse()}static copyKnots(v,M,b,E){const D=b&&E===kr.OpenByAddingControlPoints,X=M-1,z=v.length-M,R=v[X],O=v[z]-R,Y=[];b&&(D?Y.push(v[z-M]-O):Y.push(v[0]));for(const N of v)Y.push(N);return b&&(D?Y.push(v[X+M]+O):Y.push(v[v.length-1])),Y}copyKnots(v){const M=v&&this.testClosable()?this.wrappable:void 0;return fe.copyKnots(this.knots,this.degree,v,M)}}fe.knotTolerance=1e-9;class ge{static createThroughPoints(v,M){const b=v.length;if(M>b||M<2)return;const E=M-1,D=1+2*E,X=new Float64Array(D*b),z=new Float64Array(M),R=new nt,O=fe.createUniformClamped(b,M-1,0,1),Y=Q.create();for(let B=0;B<b;B++){const N=O.grevilleKnot(B),V=O.knotToLeftKnotIndex(N);O.evaluateBasisFunctions(V,N,z);let L=0;for(let v=1;v<M;v++)z[v]>z[L]&&(L=v);const U=E-L,Sr=B*D;for(let v=0;v<M;v++){const M=B-E+U+v;Sr+M>=0&&M<b&&(X[Sr+U+v]=z[v])}v instanceof it?R.push(v.getPoint3dAtUncheckedPointIndex(B,Y)):R.push(v[B].clone())}const N=ue.solveBandedSystemMultipleRHS(b,D,X,3,R.float64Data());return N?$e.create(N,O.knots,M):void 0}static createThroughPointsC2Cubic(v){const M=v.clone();if(!this.C2CubicFit.validateOptions(M))return;const b=this.C2CubicFit.constructPoles(M);if(void 0===b)return;const E=this.C2CubicFit.convertFitParamsToCubicKnotVector(M.knots,M.closed);if(void 0===E)return;const D=$e.create(b,E,M.order);return M.closed&&D?.setWrappable(kr.OpenByAddingControlPoints),D}}!function(v){v.C2CubicFit=class{static normalizeKnots(v){if(void 0===v||v.length<2)return v=void 0,!1;const M=fe.create(v,1,!1);if(!M.normalize())return v=void 0,!1;for(let b=0;b<v.length;++b)v[b]=M.knots[b];return!0}static constructChordLengthParameters(v){if(v.length<2)return;const M=[0];for(let b=1;b<v.length;++b)M[b]=M[b-1]+v[b].distance(v[b-1]);return this.normalizeKnots(M)?M:void 0}static constructUniformParameters(v){if(v<2)return;const M=fe.createUniformClamped(v+2,3,0,1),b=[];for(let E=M.leftKnotIndex;E<=M.rightKnotIndex;++E)b.push(M.knots[E]);return b}static removeDuplicateFitPoints(v){void 0!==v.knots&&v.knots.length!==v.fitPoints.length&&(v.knots=void 0);const M=nt.create(v.fitPoints),b=M.findOrderedDuplicates();M.clear();for(let E=0,D=0;E<v.fitPoints.length;++E)E===b[D]?++D:M.push(v.fitPoints[E].clone());if(v.fitPoints=M.getPoint3dArray(),void 0!==v.knots){const M=[];for(let E=0,D=0;E<v.knots.length;++E)E===b[D]?++D:M.push(v.knots[E]);v.knots=M.slice()}return!0}static constructFitParametersFromPoints(v,M,b){let E;return!M&&b||(E=this.constructChordLengthParameters(v)),void 0===E&&(E=this.constructUniformParameters(v.length)),E}static constructFitParameters(v){return void 0===v.knots&&(v.knots=this.constructFitParametersFromPoints(v.fitPoints,v.isChordLenKnots,v.closed)),v.knots?.length===v.fitPoints.length}static computeAlphaBetaGamma(v,M,b,E,D,X,z,R){let O=1/(R+z+X);v[E]=X*X*O,M[E]=X*(R+z)*O,O=1/(z+X+D),M[E]+=z*(X+D)*O,b[E]=z*z*O,O=1/(z+X),v[E]*=O,M[E]*=O,b[E]*=O}static setUpSystem2Points(v,M,b){return 2===v.length&&2===M.length&&2===b.length&&(v[0]=v[1]=b[0]=b[1]=0,M[0]=M[1]=1,!0)}static setUpSystem3Points(v,M,b,E,D,X){if(void 0===E.knots)return!1;if(3!==v.length||3!==M.length||3!==b.length)return!1;if(3!==E.knots.length||3!==E.fitPoints.length)return!1;let z=0,R=0,O=0,Y=0,N=0,B=0;return D?(v[0]=0,R=E.knots[1]-E.knots[0],z=E.knots[2]-E.knots[1],N=R+z,B=1/N,M[0]=(R+N)*B,b[0]=-R*B):(v[0]=b[0]=0,M[0]=1),O=E.knots[1]-E.knots[0],R=E.knots[2]-E.knots[1],B=1/(O+R),B*=B,v[1]=R*R*B,M[1]=R*O*2*B,b[1]=O*O*B,X?(O=E.knots[2]-E.knots[1],Y=E.knots[1]-E.knots[0],N=Y+O,B=1/N,v[2]=-O*B,M[2]=(O+N)*B,b[2]=0):(v[2]=b[2]=0,M[2]=1),!0}static setUpSystem4PointsOrMore(v,M,b,E,D,X){if(void 0===E.knots)return!1;if(v.length!==M.length||v.length!==b.length||v.length!==E.knots.length)return!1;if(E.knots.length!==E.fitPoints.length)return!1;const z=E.fitPoints.length-1,R=z-1;let O=0,Y=0,N=0,B=0,V=0,L=0;E.closed?(Y=E.knots[1]-E.knots[0],B=E.knots[R]-E.knots[R-1],N=E.knots[R+1]-E.knots[R],O=E.knots[2]-E.knots[1],this.computeAlphaBetaGamma(v,M,b,0,O,Y,N,B),B=N,N=Y,Y=E.knots[2]-E.knots[1],O=E.knots[3]-E.knots[2],this.computeAlphaBetaGamma(v,M,b,1,O,Y,N,B),O=N,Y=E.knots[R+1]-E.knots[R],B=E.knots[R-1]-E.knots[R-2],N=E.knots[R]-E.knots[R-1],this.computeAlphaBetaGamma(v,M,b,R,O,Y,N,B)):(D?(v[0]=0,Y=E.knots[1]-E.knots[0],O=E.knots[2]-E.knots[1],V=Y+O,L=1/V,M[0]=(Y+V)*L,b[0]=-Y*L):(v[0]=b[0]=0,M[0]=1),Y=E.knots[2]-E.knots[1],N=E.knots[1]-E.knots[0],B=0,O=E.knots[3]-E.knots[2],this.computeAlphaBetaGamma(v,M,b,1,O,Y,N,B),Y=E.knots[R+1]-E.knots[R],N=E.knots[R]-E.knots[R-1],B=E.knots[R-1]-E.knots[R-2],O=0,this.computeAlphaBetaGamma(v,M,b,R,O,Y,N,B),X?(N=E.knots[z]-E.knots[z-1],B=E.knots[z-1]-E.knots[z-2],V=B+N,L=1/V,v[z]=-N*L,M[z]=(N+V)*L,b[z]=0):(v[z]=b[z]=0,M[z]=1));for(let U=2;U<R;++U)Y=E.knots[U+1]-E.knots[U],B=E.knots[U-1]-E.knots[U-2],N=E.knots[U]-E.knots[U-1],O=E.knots[U+2]-E.knots[U+1],this.computeAlphaBetaGamma(v,M,b,U,O,Y,N,B);return!0}static setUpSystem(v,M,b,E){let D=!1,X=!1;E.isNaturalTangents&&!E.closed&&(D=void 0===E.startTangent,X=void 0===E.endTangent);let z=!1;return 2===E.fitPoints.length?z=this.setUpSystem2Points(v,M,b):3===E.fitPoints.length?z=this.setUpSystem3Points(v,M,b,E,D,X):4<=E.fitPoints.length&&(z=this.setUpSystem4PointsOrMore(v,M,b,E,D,X)),z}static setBesselEndCondition(v,M,b){if(v.length!==M.fitPoints.length+2)return!1;if(void 0===M.knots)return!1;const E=1/3,D=M.fitPoints.length-1;if(1===D)return b?v[0].interpolate(E,v[3],v[1]):v[3].interpolate(E,v[0],v[2]),!0;if(2===D){const D=(M.knots[2]-M.knots[1])/(M.knots[2]-M.knots[0]),X=1-D,z=v[2].plus2Scaled(v[0],-D*D,v[4],-X*X);return b?Q.createAdd2Scaled(z,1/(2*D),v[0],D).interpolate(E,v[0],v[1]):Q.createAdd2Scaled(z,1/(2*X),v[4],X).interpolate(E,v[4],v[3]),!0}if(b){const b=(M.knots[2]-M.knots[1])/(M.knots[2]-M.knots[0]),D=1-b,X=v[2].plus2Scaled(v[0],-b*b,v[3],-D*D);Q.createAdd2Scaled(X,1/(2*b),v[0],b).interpolate(E,v[0],v[1])}else{const b=(M.knots[D]-M.knots[D-1])/(M.knots[D]-M.knots[D-2]),X=1-b,z=v[D].plus2Scaled(v[D-1],-b*b,v[D+2],-X*X);Q.createAdd2Scaled(z,1/(2*X),v[D+2],X).interpolate(E,v[D+2],v[D+1])}return!0}static setNaturalEndCondition(v,M,b){return v.length===M.fitPoints.length+2&&(1==M.fitPoints.length-1?this.setBesselEndCondition(v,M,b):(b?v[1]=v[0]:v[v.length-2]=v[v.length-1],!0))}static setChordLengthScaledEndCondition(v,M,b){if(v.length!==M.fitPoints.length+2)return!1;const E=b?M.startTangent:M.endTangent;if(void 0===E)return!1;let D=0,X=0,z=0;const R=M.fitPoints.length-1;1===R?b?(D=0,X=1,z=3):(D=3,X=2,z=0):b?(D=0,X=1,z=2):(D=R+2,X=R+1,z=R);const O=v[z].distance(v[D]);return v[D].plusScaled(E,O/3,v[X]),!0}static setBesselLengthScaledEndCondition(v,M,b){if(v.length!==M.fitPoints.length+2)return!1;const E=b?M.startTangent:M.endTangent;if(void 0===E)return!1;if(!this.setBesselEndCondition(v,M,b))return!1;const D=M.fitPoints.length-1,X=b?0:D+2,z=b?1:D+1;return v[X].plusScaled(E,v[X].distance(v[z]),v[z]),!0}static setPhysicallyClosedEndCondition(v,M){const b=M.fitPoints.length-1;if(!M.isColinearTangents||b<=2||void 0!==M.startTangent&&void 0!==M.endTangent||M.isNaturalTangents||!v[0].isAlmostEqual(v[b+2]))return!0;if(void 0!==M.startTangent){const M=$.createStartEnd(v[1],v[0]).normalize();if(void 0!==M){const E=v[b+2].distance(v[b+1]);v[b+2].plusScaled(M,E,v[b+1])}}else if(void 0!==M.endTangent){const M=$.createStartEnd(v[b+1],v[b+2]).normalize();if(void 0!==M){const b=v[0].distance(v[1]);v[0].plusScaled(M,b,v[1])}}else{const M=$.createStartEnd(v[b+1],v[1]).normalize();if(void 0!==M){const E=v[0].distance(v[1]);v[0].plusScaled(M,E,v[1]);const D=v[b+2].distance(v[b+1]);v[b+2].plusScaled(M,-D,v[b+1])}}return!0}static setEndConditions(v,M){if(v.length!==M.fitPoints.length)return!1;const b=Q.createZero(),E=Q.createZero();v.splice(1,0,b),v.splice(v.length-1,0,E);let D=!1;return D=void 0===M.startTangent?M.isNaturalTangents?this.setNaturalEndCondition(v,M,!0):this.setBesselEndCondition(v,M,!0):M.isChordLenTangents?this.setChordLengthScaledEndCondition(v,M,!0):this.setBesselLengthScaledEndCondition(v,M,!0),D=void 0===M.endTangent?M.isNaturalTangents?this.setNaturalEndCondition(v,M,!1):this.setBesselEndCondition(v,M,!1):M.isChordLenTangents?this.setChordLengthScaledEndCondition(v,M,!1):this.setBesselLengthScaledEndCondition(v,M,!1),D&&(D=this.setPhysicallyClosedEndCondition(v,M)),D}static solveNearTridiagonal(v,M,b,E){if(M.length!==b.length||M.length!==E.length||M.length!==v.length)return;const D=[],X=v.length-1,z=v.slice(0,-1);let R=0;for(let O=1;O<X;++O){if(void 0===(R=K.conditionalDivideFraction(-M[O],b[O-1])))return;b[O]+=R*E[O-1],M[O]=R*M[O-1],z[O].addScaledInPlace(z[O-1],R)}if(void 0!==(R=K.conditionalDivideFraction(1,b[X-1]+M[X-1]))){E[X-1]*=R,z[X-1].scaleInPlace(R);for(let v=X-2;v>=0;--v){if(void 0===(R=K.conditionalDivideFraction(1,b[v])))return;Q.createScale(z[v].plus2Scaled(z[v+1],-E[v],z[X-1],-M[v]),R,z[v]),E[v]=-(E[v]*E[v+1]+M[v]*E[X-1])*R}if(void 0!==(R=K.conditionalDivideFraction(1,1+E[0]))){D.push(Q.createScale(z[0],R));for(let v=1;v<X;++v)D.push(z[v].plusScaled(D[0],-E[v]));return D}}}static validateOptions(v){if(v.order=4,v.knots=this.convertCubicKnotVectorToFitParams(v.knots,v.fitPoints.length,!0),!this.removeDuplicateFitPoints(v))return!1;let M=v.fitPoints[0].isAlmostEqual(v.fitPoints[v.fitPoints.length-1]);if(3===v.fitPoints.length&&M&&(v.fitPoints.pop(),void 0!==v.knots&&v.knots.pop(),M=v.fitPoints[0].isAlmostEqual(v.fitPoints[v.fitPoints.length-1])),v.fitPoints.length<=2){if(M)return!1;v.closed=!1}return v.closed&&(M||(v.fitPoints.push(v.fitPoints[0].clone()),void 0!==v.knots&&v.knots.push(v.knots[v.knots.length-1]+(v.knots[v.knots.length-1]-v.knots[0])/(v.knots.length-1))),v.fitPoints.length<=4&&(v.closed=!1)),!(v.fitPoints.length<2||(void 0!==v.startTangent&&(v.startTangent.isAlmostZero?v.startTangent=void 0:v.startTangent.normalizeInPlace()),void 0!==v.endTangent&&(v.endTangent.isAlmostZero?v.endTangent=void 0:v.endTangent.normalizeInPlace()),0))}static convertCubicKnotVectorToFitParams(v,M,b){let E=v?.slice();if(void 0!==E){const v=E.length-M;switch(v){case 0:break;case 4:case 6:for(let M=0;M<v/2;++M)E.pop(),E.shift();break;default:E=void 0}b&&!this.normalizeKnots(E)&&(E=void 0)}return E}static convertFitParamsToCubicKnotVector(v,M,b){const E=v?.slice();if(void 0!==E){const v=b?6:4;if(M){const M=E.length-2;for(let b=2;b<=v;b+=2)E.unshift(E[M]-1),E.push(1+E[b])}else for(let M=0;M<v/2;++M)E.unshift(0),E.push(1)}return E}static convertToJsonKnots(v){void 0!==v.knots?(v.knots=this.convertCubicKnotVectorToFitParams(v.knots,v.fitPoints.length,!1),v.knots=this.convertFitParamsToCubicKnotVector(v.knots,v.closed,!0)):(v.knots=this.constructFitParametersFromPoints(de.clonePoint3dArray(v.fitPoints),v.isChordLenKnots,v.closed),v.knots=this.convertFitParamsToCubicKnotVector(v.knots,v.closed,!0))}static constructPoles(v){if(!this.constructFitParameters(v)||void 0===v.knots)return;const M=v.fitPoints.length,b=Array(M),E=Array(M),D=Array(M);if(!this.setUpSystem(b,E,D,v))return;let X=[];if(v.closed){if(void 0!==(X=this.solveNearTridiagonal(v.fitPoints,b,E,D))&&X.length>2){X.unshift(X.pop());for(let M=0;M<v.order-1;++M)X.push(X[M].clone())}}else{const z=v.fitPoints.slice();if(!this.setEndConditions(z,v))return;if(z.length!==M+2)return;const R=new Float64Array(3*M),O=new Float64Array(3*M);for(let v=0,X=0,B=0;v<M;++v)R[X++]=b[v],R[X++]=E[v],R[X++]=D[v],O[B++]=z[v+1].x,O[B++]=z[v+1].y,O[B++]=z[v+1].z;const Y=ue.solveBandedSystemMultipleRHS(M,3,R,3,O);if(void 0===Y)return;X=new Float64Array(3+Y.length+3);let N=0;X[N++]=v.fitPoints[0].x,X[N++]=v.fitPoints[0].y,X[N++]=v.fitPoints[0].z;for(let v=0;v<Y.length;)X[N++]=Y[v++];X[N++]=v.fitPoints[v.fitPoints.length-1].x,X[N++]=v.fitPoints[v.fitPoints.length-1].y,X[N++]=v.fitPoints[v.fitPoints.length-1].z}return X}}}(ge||(ge={}));class pe extends oe{dispatchToGeometryHandler(v){return this._proxyCurve.dispatchToGeometryHandler(v)}constructor(v){super(),this._proxyCurve=v}get proxyCurve(){return this._proxyCurve}computeStrokeCountForOptions(v){return this._proxyCurve.computeStrokeCountForOptions(v)}emitStrokableParts(v,M){this._proxyCurve.emitStrokableParts(v,M)}cloneTransformed(v){const M=this.clone();if(M.tryTransformInPlace(v))return M}clonePartialCurve(v,M){return this._proxyCurve.clonePartialCurve(v,M)}emitStrokes(v,M){this._proxyCurve.emitStrokes(v,M)}extendRange(v,M){this._proxyCurve.extendRange(v,M)}range(v,M){return this._proxyCurve.range(v,M)}fractionToPoint(v,M){return this._proxyCurve.fractionToPoint(v,M)}fractionToPointAndDerivative(v,M){return this._proxyCurve.fractionToPointAndDerivative(v,M)}fractionToPointAnd2Derivatives(v,M){return this._proxyCurve.fractionToPointAnd2Derivatives(v,M)}isInPlane(v){return this._proxyCurve.isInPlane(v)}quickLength(){return this._proxyCurve.quickLength()}constructOffsetXY(v){return this._proxyCurve.constructOffsetXY(v)}projectedParameterRange(v,M){return this._proxyCurve.projectedParameterRange(v,M)}}class me{constructor(v,M){this._fitPoints=v||[],this._knots=M}get order(){return K.resolveNumber(this._order,4)}set order(v){this._order=v}get closed(){return K.resolveValue(this._closed,!1)}set closed(v){this._closed=v}get isChordLenKnots(){return K.resolveNumber(this._isChordLenKnots,0)}set isChordLenKnots(v){this._isChordLenKnots=v}get isColinearTangents(){return K.resolveNumber(this._isColinearTangents,0)}set isColinearTangents(v){this._isColinearTangents=v}get isChordLenTangents(){return K.resolveNumber(this._isChordLenTangents,0)}set isChordLenTangents(v){this._isChordLenTangents=v}get isNaturalTangents(){return K.resolveNumber(this._isNaturalTangents,0)}set isNaturalTangents(v){this._isNaturalTangents=v}get startTangent(){return this._startTangent}set startTangent(v){this._startTangent=v}get endTangent(){return this._endTangent}set endTangent(v){this._endTangent=v}get fitPoints(){return this._fitPoints}set fitPoints(v){this._fitPoints=v}get knots(){return this._knots}set knots(v){this._knots=v}captureOptionalProps(v,M,b,E,D,X,z,R){this._order=K.resolveToUndefined(v,0),this._closed=K.resolveToUndefined(M,!1),this._isChordLenKnots=K.resolveToUndefined(b,0),this._isColinearTangents=K.resolveToUndefined(E,0),this._isChordLenTangents=K.resolveToUndefined(D,0),this._isNaturalTangents=K.resolveToUndefined(X,0),this._startTangent=z,this._endTangent=R}cloneAsInterpolationCurve3dProps(){const v={fitPoints:de.cloneDeepJSONNumberArrays(this.fitPoints),knots:this._knots?.slice()};return void 0!==this._order&&(v.order=this._order),void 0!==this._closed&&(v.closed=this._closed),void 0!==this._isChordLenKnots&&(v.isChordLenKnots=this._isChordLenKnots),void 0!==this._isColinearTangents&&(v.isColinearTangents=this._isColinearTangents),void 0!==this._isChordLenTangents&&(v.isChordLenTangents=this._isChordLenTangents),void 0!==this._isNaturalTangents&&(v.isNaturalTangents=this._isNaturalTangents),void 0!==this._startTangent&&(v.startTangent=this._startTangent?.toArray()),void 0!==this._endTangent&&(v.endTangent=this._endTangent?.toArray()),v}clone(){const v=new me(de.clonePoint3dArray(this.fitPoints),this.knots?.slice());return v._order=this.order,v._closed=this.closed,v._isChordLenKnots=this.isChordLenKnots,v._isColinearTangents=this.isColinearTangents,v._isChordLenTangents=this.isChordLenTangents,v._isNaturalTangents=this.isNaturalTangents,v._startTangent=this._startTangent?.clone(),v._endTangent=this._endTangent?.clone(),v}static create(v){const M=new me(de.clonePoint3dArray(v.fitPoints),v.knots?.slice());return M._order=v.order,M._closed=v.closed,M._isChordLenKnots=v.isChordLenKnots,M._isColinearTangents=v.isColinearTangents,M._isChordLenTangents=v.isChordLenTangents,M._isNaturalTangents=v.isNaturalTangents,M._startTangent=v.startTangent?$.fromJSON(v.startTangent):void 0,M._endTangent=v.endTangent?$.fromJSON(v.endTangent):void 0,M}static areAlmostEqualAllow000AsUndefined(v,M){return void 0!==v&&0===v.maxAbs()&&(v=void 0),void 0!==M&&0===M.maxAbs()&&(M=void 0),void 0!==v&&void 0!==M?v.isAlmostEqual(M):void 0===v&&void 0===M}static areAlmostEqual(v,M){if(void 0===v&&void 0===M)return!0;if(void 0!==v&&void 0!==M&&K.areEqualAllowUndefined(v.order,M.order)&&K.areEqualAllowUndefined(v.closed,M.closed)&&K.areEqualAllowUndefined(v.isChordLenKnots,M.isChordLenKnots)&&K.areEqualAllowUndefined(v.isColinearTangents,M.isColinearTangents)&&K.areEqualAllowUndefined(v.isNaturalTangents,M.isNaturalTangents)&&this.areAlmostEqualAllow000AsUndefined(v.startTangent,M.startTangent)&&this.areAlmostEqualAllow000AsUndefined(v.endTangent,M.endTangent)&&K.almostEqualArrays(v.fitPoints,M.fitPoints,((v,M)=>v.isAlmostEqual(M)))){if(K.almostEqualNumberArrays(v.knots,M.knots,((v,M)=>v===M)))return!0;if(void 0===v.knots&&void 0===M.knots)return!0;let b=v.knots,E=M.knots;return void 0===v.knots?b=ge.C2CubicFit.constructFitParametersFromPoints(v.fitPoints,v.isChordLenKnots,v.closed):void 0===M.knots&&(E=ge.C2CubicFit.constructFitParametersFromPoints(M.fitPoints,M.isChordLenKnots,M.closed)),b=ge.C2CubicFit.convertCubicKnotVectorToFitParams(b,v.fitPoints.length,!1),E=ge.C2CubicFit.convertCubicKnotVectorToFitParams(E,M.fitPoints.length,!1),K.almostEqualNumberArrays(b,E,((v,M)=>K.isAlmostEqualNumber(v,M)))}return!1}reverseInPlace(){this.fitPoints.reverse(),this.knots&&this.knots.reverse();const v=this._startTangent;this._startTangent=this.endTangent,this._endTangent=v}}class xe extends pe{constructor(v,M){super(M),this.curvePrimitiveType="interpolationCurve",this._options=v}dispatchToGeometryHandler(v){let M=v.handleInterpolationCurve3d(this);return void 0===M&&(M=this._proxyCurve.dispatchToGeometryHandler(v)),M}static create(v){let M;return M=v instanceof me?v.clone():me.create(v),xe.createCapture(M)}static createCapture(v){const M=$e.createFromInterpolationCurve3dOptions(v);if(M)return new xe(v,M)}copyFitPointsFloat64Array(){return de.cloneXYZPropsAsFloat64Array(this._options.fitPoints)}toJSON(){return this._options.cloneAsInterpolationCurve3dProps()}cloneProps(){return this._options.cloneAsInterpolationCurve3dProps()}get options(){return this._options}reverseInPlace(){this._proxyCurve.reverseInPlace(),this._options.reverseInPlace()}tryTransformInPlace(v){const M=this._proxyCurve.tryTransformInPlace(v);return M&&(v.multiplyPoint3dArrayInPlace(this._options.fitPoints),this._options.startTangent&&v.multiplyVectorInPlace(this._options.startTangent),this._options.endTangent&&v.multiplyVectorInPlace(this._options.endTangent)),M}clone(){return new xe(this._options.clone(),this._proxyCurve.clone())}isAlmostEqual(v){return v instanceof xe&&me.areAlmostEqual(this._options,v._options)}isSameGeometryClass(v){return v instanceof xe}}class ye{constructor(v,M){this._p0=Q.createZero(),this._p1=Q.createZero(),this._v0=$.createZero(),this._v1=$.createZero(),this._r0=Mt.createZero(),this._offsetDistance=M,this._fitOptions=new me;const b=v.fractionToPointAndUnitTangent(0,this._r0).direction.clone(),E=v.fractionToPointAndUnitTangent(1,this._r0).direction.negate();this._fitOptions.startTangent=b,this._fitOptions.endTangent=E,(this._fitOptions.closed=v.startPoint(this._p0).isAlmostEqual(v.endPoint(this._p1))&&b.isParallelTo(E,!0))&&(this._fitOptions.isChordLenKnots=1)}pushOffsetPoint(v,M){K.isSmallMetricDistance(M.x)&&K.isSmallMetricDistance(M.y)||this._fitOptions.fitPoints.push(v.plusScaled(M.unitPerpendicularXY(this._v0),this._offsetDistance))}needPrimaryGeometryForStrokes(){return!0}startParentCurvePrimitive(v){}startCurvePrimitive(v){}endCurvePrimitive(v){}endParentCurvePrimitive(v){}announceIntervalForUniformStepStrokes(v,M,b,E){for(let D=0;D<=M;++D){const X=K.interpolate(b,D/M,E),z=v.fractionToPointAndDerivative(X,this._r0);this.pushOffsetPoint(z.origin,z.direction)}}announceSegmentInterval(v,M,b,E,D,X){if(E>0){const v=$.createStartEnd(M,b,this._v1);for(let D=0;D<=E;++D)this.pushOffsetPoint(M.interpolate(D/E,b,this._p0),v)}}announcePointTangent(v,M,b){this.pushOffsetPoint(v,b)}claimResult(){return ge.createThroughPointsC2Cubic(this._fitOptions)}}class _e{constructor(){}announceUnexpected(v,M){}announceCurvePrimitive(v,M=-1){}announcePath(v,M=-1){let b=0;for(const E of v.children)this.announceCurvePrimitive(E,b++)}announceLoop(v,M=-1){let b=0;for(const E of v.children)this.announceCurvePrimitive(E,b++)}announceParityRegion(v,M=-1){let b=0;for(const E of v.children)this.announceLoop(E,b++)}announceUnionRegion(v,M=-1){let b=0;for(const E of v.children)E.announceToCurveProcessor(this,b++)}announceBagOfCurves(v,M=-1){for(const b of v.children)b instanceof oe?this.announceCurvePrimitive(b):b.announceToCurveProcessor(this)}}class ve extends _e{constructor(){super(),this._stack=[]}enter(v){this._stack.push(v)}leave(){return this._stack.pop()}announceUnexpected(v,M){}announceCurvePrimitive(v,M=-1){}announcePath(v,M=-1){this.enter(v),super.announcePath(v,M),this.leave()}announceLoop(v,M=-1){this.enter(v),super.announceLoop(v,M),this.leave()}announceParityRegion(v,M=-1){this.enter(v);let b=0;for(const E of v.children)this.announceLoop(E,b++);this.leave()}announceUnionRegion(v,M=-1){this.enter(v),super.announceUnionRegion(v,M),this.leave()}announceBagOfCurves(v,M=-1){this.enter(v);let b=0;for(const E of v.children)E instanceof oe?this.announceCurvePrimitive(E,b++):E.announceToCurveProcessor(this);this.leave()}}class Pe extends ve{constructor(v){super(),this._transform=v,this._result=void 0}static clone(v,M){const b=new Pe(M);return v.announceToCurveProcessor(b),b._result}enter(v){v instanceof ze&&super.enter(v.cloneEmptyPeer())}leave(){const v=super.leave();return v&&(0===this._stack.length?this._result=v:this._stack[this._stack.length-1].tryAddChild(v)),v}doClone(v){return this._transform?v.cloneTransformed(this._transform):v.clone()}announceCurvePrimitive(v,M){const b=this.doClone(v);if(void 0!==b&&this._stack.length>0){const v=this._stack[this._stack.length-1];if(v instanceof Ne||v instanceof Ye)if(Array.isArray(b))for(const M of b)v.tryAddChild(M);else v.tryAddChild(b)}}}class Ie{constructor(){this.shouldTriangulate=!1,this.defaultCircleStrokes=16}get needParams(){return void 0!==this._needParams&&this._needParams}set needParams(v){this._needParams=v}get needNormals(){return void 0!==this._needNormals&&this._needNormals}set needNormals(v){this._needNormals=v}get needTwoSided(){return void 0!==this._needTwoSided&&this._needTwoSided}set needTwoSided(v){this._needTwoSided=v}get hasAngleTol(){return void 0!==this.angleTol&&Math.abs(this.angleTol.radians)>0}get hasChordTol(){return void 0!==this.chordTol&&this.chordTol>0}get hasMaxEdgeLength(){return void 0!==this.maxEdgeLength&&this.maxEdgeLength>0}get maximizeConvexFacets(){return this._maximizeConvexFacets??!1}set maximizeConvexFacets(v){this._maximizeConvexFacets=v,v&&(this.shouldTriangulate=v)}clone(){const v=new Ie;return v.chordTol=this.chordTol,v.angleTol=this.angleTol?.clone(),v.maxEdgeLength=this.maxEdgeLength,v.minStrokesPerPrimitive=this.minStrokesPerPrimitive,v.shouldTriangulate=this.shouldTriangulate,v._needNormals=this._needNormals,v._needTwoSided=this._needTwoSided,v._needParams=this._needParams,v.needColors=this.needColors,v.defaultCircleStrokes=this.defaultCircleStrokes,v._maximizeConvexFacets=this._maximizeConvexFacets,v}applyMaxEdgeLength(v,M){return M=Math.abs(M),this.maxEdgeLength&&this.maxEdgeLength>0&&v*this.maxEdgeLength<M&&(v=K.stepCount(this.maxEdgeLength,M,v)),v}applyAngleTol(v,M,b){return Ie.applyAngleTol(this,v,M,b)}static applyAngleTol(v,M,b,E){b=Math.abs(b);let D=E||Math.PI/8;return v&&v.angleTol&&v.angleTol.radians>0&&(D=v.angleTol.radians),M*D<b&&(M=K.stepCount(D,b,M)),M}static applyMaxEdgeLength(v,M,b){return b<0&&(b=-b),M<1&&(M=1),v&&v.maxEdgeLength&&v.maxEdgeLength*M<b&&(M=K.stepCount(v.maxEdgeLength,b,M)),M}applyTolerancesToArc(v,M=2*Math.PI){let b=1;return b=this.applyAngleTol(b,M,.25*Math.PI),b=this.applyMaxEdgeLength(b,M*v),b=this.applyChordTol(b,v,M),b=this.applyMinStrokesPerPrimitive(b),b}applyChordTol(v,M,b){if(this.chordTol&&this.chordTol>0&&this.chordTol<M){const E=this.chordTol,D=2*Math.acos(1-E/M);v=K.stepCount(D,b,v)}return v}applyChordTolToLengthAndRadians(v,M,b){if(this.chordTol&&this.chordTol>0){const E=K.conditionalDivideFraction(M,b);if(void 0!==E)return this.applyChordTol(v,E,b)}return v}applyMinStrokesPerPrimitive(v){return void 0!==this.minStrokesPerPrimitive&&Number.isFinite(this.minStrokesPerPrimitive)&&this.minStrokesPerPrimitive>v&&(v=this.minStrokesPerPrimitive),v}static createForCurves(){const v=new Ie;return v.angleTol=W.createDegrees(15),v}static createForFacets(){const v=new Ie;return v.angleTol=W.createDegrees(22.5),v}}class Ae{constructor(v,M=180,b=90,E=!1,D=!1){this.minArcDegrees=180,this.maxChamferTurnDegrees=90,this.allowSharpestCorners=!1,this.leftOffsetDistance=0,this.preserveEllipticalArcs=!1,this.leftOffsetDistance=v,this.minArcDegrees=M,this.maxChamferTurnDegrees=b,this.preserveEllipticalArcs=E,this.allowSharpestCorners=D}clone(){return new Ae(this.leftOffsetDistance,this.minArcDegrees,this.maxChamferTurnDegrees,this.preserveEllipticalArcs,this.allowSharpestCorners)}setFrom(v){this.leftOffsetDistance=v.leftOffsetDistance,this.minArcDegrees=v.minArcDegrees,this.maxChamferTurnDegrees=v.maxChamferTurnDegrees,this.preserveEllipticalArcs=v.preserveEllipticalArcs,this.allowSharpestCorners=v.allowSharpestCorners}static create(v){return v instanceof Ae?v:new Ae(v)}needArc(v){return Math.abs(v.degrees)>=this.minArcDegrees}numChamferPoints(v){const M=Math.abs(v.degrees);let b=120;this.allowSharpestCorners&&(b=this.maxChamferTurnDegrees);const E=K.clamp(this.maxChamferTurnDegrees,10,b);return M<=E?1:Math.ceil(M/E)}}class Se{constructor(v,M){this.jointOptions=Ae.create(v),this.strokeOptions=void 0!==M?M:Ie.createForCurves()}get minArcDegrees(){return this.jointOptions.minArcDegrees}set minArcDegrees(v){this.jointOptions.minArcDegrees=v}get maxChamferTurnDegrees(){return this.jointOptions.maxChamferTurnDegrees}set maxChamferTurnDegrees(v){this.jointOptions.maxChamferTurnDegrees=v}get allowSharpestCorners(){return this.jointOptions.allowSharpestCorners}set allowSharpestCorners(v){this.jointOptions.allowSharpestCorners=v}get leftOffsetDistance(){return this.jointOptions.leftOffsetDistance}set leftOffsetDistance(v){this.jointOptions.leftOffsetDistance=v}get preserveEllipticalArcs(){return this.jointOptions.preserveEllipticalArcs}set preserveEllipticalArcs(v){this.jointOptions.preserveEllipticalArcs=v}static create(v){return v instanceof Se?v:new Se(v)}static getOffsetDistance(v){return"number"==typeof v?v:v.leftOffsetDistance}clone(){return new Se(this.jointOptions.clone(),this.strokeOptions.clone())}}class we extends oe{isSameGeometryClass(v){return v instanceof we}get point0Ref(){return this._point0}get point1Ref(){return this._point1}get isExtensibleFractionSpace(){return!0}constructor(v,M){super(),this.curvePrimitiveType="lineSegment",this._point0=v,this._point1=M}setRefs(v,M){this._point0=v,this._point1=M}set(v,M){this._point0=v.clone(),this._point1=M.clone()}setFrom(v){this._point0.setFrom(v._point0),this._point1.setFrom(v._point1)}startPoint(v){return v?(v.setFrom(this._point0),v):this._point0.clone()}endPoint(v){return v?(v.setFrom(this._point1),v):this._point1.clone()}fractionToPointAndDerivative(v,M){return(M=M||Mt.createZero()).direction.setStartEnd(this._point0,this._point1),this._point0.interpolate(v,this._point1,M.origin),M}fractionToPointAnd2Derivatives(v,M){return(M=M||bt.createXYPlane()).vectorU.setStartEnd(this._point0,this._point1),M.vectorV.set(0,0,0),this._point0.interpolate(v,this._point1,M.origin),M}clone(){return we.create(this._point0,this._point1)}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}static create(v,M,b){return b?(b.set(v,M),b):new we(v.clone(),M.clone())}static createCapture(v,M){return new we(v,M)}static createXYXY(v,M,b,E,D=0,X){return X?(X._point0.set(v,M,D),X._point1.set(b,E,D),X):new we(Q.create(v,M,D),Q.create(b,E,D))}static createXYZXYZ(v,M,b,E,D,X,z){return z?(z._point0.set(v,M,b),z._point1.set(E,D,X),z):new we(Q.create(v,M,b),Q.create(E,D,X))}fractionToPoint(v,M){return this._point0.interpolate(v,this._point1,M)}curveLength(){return this._point0.distance(this._point1)}curveLengthBetweenFractions(v,M){return Math.abs(M-v)*this._point0.distance(this._point1)}quickLength(){return this.curveLength()}closestPoint(v,M,b){let E=v.fractionOfProjectionToLine(this._point0,this._point1,0);return E=ee.correctFraction(M,E),(b=vt.create(this,b)).fraction=E,this._point0.interpolate(E,this._point1,b.point),b.vectorInCurveLocationDetail=void 0,b.a=b.point.distance(v),b}reverseInPlace(){const v=this._point0;this._point0=this._point1,this._point1=v}tryTransformInPlace(v){return this._point0=v.multiplyPoint3d(this._point0,this._point0),this._point1=v.multiplyPoint3d(this._point1,this._point1),!0}isInPlane(v){return K.isSmallMetricDistance(v.altitude(this._point0))&&K.isSmallMetricDistance(v.altitude(this._point1))}appendPlaneIntersectionPoints(v,M){const b=v.altitude(this._point0),E=v.altitude(this._point1),D=Lt.solveCoffs(b,E);let X=0;if(void 0!==D){X++;const v=vt.createCurveFractionPoint(this,D,this.fractionToPoint(D));v.intervalRole=L.isolated,M.push(v)}return X}extendRange(v,M){M?(v.extendTransformedPoint(M,this._point0),v.extendTransformedPoint(M,this._point1)):(v.extendPoint(this._point0),v.extendPoint(this._point1))}setFromJSON(v){if(!v)return this._point0.set(0,0,0),void this._point1.set(1,0,0);v.startPoint&&v.endPoint?(this._point0.setFromJSON(v.startPoint),this._point1.setFromJSON(v.endPoint)):Array.isArray(v)&&v.length>1&&(this._point0.setFromJSON(v[0]),this._point1.setFromJSON(v[1]))}getFractionToDistanceScale(){return this.curveLength()}toJSON(){return[this._point0.toJSON(),this._point1.toJSON()]}static fromJSON(v){const M=new we(Q.createZero(),Q.create());return M.setFromJSON(v),M}isAlmostEqual(v){if(v instanceof we){const M=v;return this._point0.isAlmostEqual(M._point0)&&this._point1.isAlmostEqual(M._point1)}return!1}emitStrokes(v,M){const b=this.computeStrokeCountForOptions(M);v.appendFractionalStrokePoints(this,b,0,1)}emitStrokableParts(v,M){v.startCurvePrimitive(this);const b=this.computeStrokeCountForOptions(M);v.announceSegmentInterval(this,this._point0,this._point1,b,0,1),v.endCurvePrimitive(this)}computeStrokeCountForOptions(v){let M=1;return v&&(v.maxEdgeLength&&(M=v.applyMaxEdgeLength(M,this.curveLength())),M=v.applyMinStrokesPerPrimitive(M)),M}dispatchToGeometryHandler(v){return v.handleLineSegment3d(this)}announceClipIntervals(v,M){return v.announceClippedSegmentIntervals(0,1,this._point0,this._point1,M?(v,b)=>M(v,b,this):void 0)}clonePartialCurve(v,M){return we.create(this.fractionToPoint(v),this.fractionToPoint(M))}rangeBetweenFractions(v,M,b){if(!b){const b=ut.create();return b.extendInterpolated(this._point0,v,this._point1),b.extendInterpolated(this._point0,M,this._point1),b}const E=this.fractionToPoint(v),D=this.fractionToPoint(M);return b&&(b.multiplyPoint3d(E,E),b.multiplyPoint3d(D,D)),ut.create(E,D)}constructOffsetXY(v){const M=$.createStartEnd(this._point0,this._point1);if(M.normalizeInPlace()){M.rotate90CCWXY(M);const b=Se.getOffsetDistance(v);return we.create(this._point0.plusScaled(M,b),this._point1.plusScaled(M,b))}}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}}class Ce{getXAtUncheckedPointIndex(v){const M=this.getPoint2dAtCheckedPointIndex(v,Ce._workPoint);return void 0===Ce._workPoint&&(Ce._workPoint=M),M?M.x:0}getYAtUncheckedPointIndex(v){const M=this.getPoint2dAtCheckedPointIndex(v,Ce._workPoint);return void 0===Ce._workPoint&&(Ce._workPoint=M),M?M.y:0}linearCombination(v,M){const b=Math.min(this.length,v.length),E=M instanceof J?J.createZero(M):H.createZero(M);for(let D=0;D<b;++D)E.x+=v[D]*this.getXAtUncheckedPointIndex(D),E.y+=v[D]*this.getYAtUncheckedPointIndex(D);return E}}class Te extends Ce{constructor(v=8,M){super(),this._data=new Float64Array(2*v),this._xyInUse=0,this._xyCapacity=v,this._growthFactor=void 0!==M&&M>=1?M:1.5}copyData(v,M,b){let E=void 0!==b?2*b:0;if(E<0&&(E=0),E>=this._data.length)return{count:0,offset:0};let D=void 0!==M?2*M:v.length;return D>0&&(D>v.length&&(D=v.length),E+D>this._data.length&&(D=this._data.length-E),D%2!=0&&(D-=D%2)),D<=0?{count:0,offset:0}:(D===v.length?this._data.set(v,E):v instanceof Float64Array?this._data.set(v.subarray(0,D),E):this._data.set(v.slice(0,D),E),{count:D/2,offset:E/2})}get length(){return this._xyInUse}set length(v){this.resize(v,!0)}get float64Length(){return 2*this._xyInUse}float64Data(){return this._data}ensureCapacity(v,M=!0){if(v>this._xyCapacity){M&&(v*=this._growthFactor);const b=this._data;this._data=new Float64Array(2*v),this.copyData(b,this._xyInUse),this._xyCapacity=v}}resize(v,M){v>=0&&v<this._xyInUse?this._xyInUse=v:v>this._xyInUse&&(this.ensureCapacity(v,!1),M&&this._data.fill(0,2*this._xyInUse),this._xyInUse=v)}clone(){const v=new Te(this.length);return v.copyData(this._data,this.length),v._xyInUse=this.length,v}static create(v,M){if(M)M.clear();else{const b="number"==typeof v[0]?v.length/2:v.length;M=new Te(b)}return M.pushFrom(v),M}static createArrayOfGrowableXYZArray(v){return nt.createArrayOfGrowableXYZArray(v)}push(v){this.pushXY(v.x,v.y)}pushAll(v){this.ensureCapacity(this._xyInUse+v.length,!1);for(const M of v)this.push(M)}pushAllXYAndZ(v){if(this.ensureCapacity(this._xyInUse+v.length,!1),v instanceof nt){const M=v.float64Data(),b=3*v.length;for(let v=0;v+2<b;v+=3)this.pushXY(M[v],M[v+1])}else for(const M of v)this.pushXY(M.x,M.y)}pushFrom(v){if(v instanceof Q)this.pushXY(v.x,v.y);else if(v instanceof nt)this.pushAllXYAndZ(v);else if(v instanceof H)this.pushXY(v.x,v.y);else if(K.isNumberArray(v,3)||v instanceof Float64Array){const M=Math.trunc(v.length/2);this.ensureCapacity(this._xyInUse+M,!1),this.copyData(v,M,this._xyInUse),this._xyInUse+=M}else if(K.isNumberArray(v,2))this.pushXY(v[0],v[1]);else if(Array.isArray(v))for(const M of v)this.pushFrom(M);else if(Q.isXAndY(v))this.pushXY(v.x,v.y);else if(v instanceof Ce){const M=v.length;this.ensureCapacity(this._xyInUse+M,!1);for(let b=0;b<M;b++)this.pushXY(v.getXAtUncheckedPointIndex(b),v.getYAtUncheckedPointIndex(b))}}pushWrap(v){if(this._xyInUse>=v){this.ensureCapacity(this._xyInUse+v,!1);for(let M=0;M<v;M++){const v=2*M;this.pushXY(this._data[v],this._data[v+1])}}}pushXY(v,M){this.ensureCapacity(this._xyInUse+1);const b=2*this._xyInUse;this._data[b]=v,this._data[b+1]=M,this._xyInUse++}pop(){this._xyInUse>0&&this._xyInUse--}isIndexValid(v){return!(v>=this._xyInUse||v<0)}clear(){this._xyInUse=0}getPoint2dAtUncheckedPointIndex(v,M){const b=2*v;return H.create(this._data[b],this._data[b+1],M)}getXAtUncheckedPointIndex(v){return this._data[2*v]}getYAtUncheckedPointIndex(v){return this._data[2*v+1]}getPoint2dArray(){const v=2*this._xyInUse,M=[],b=this._data;for(let E=0;E<v;E+=2)M.push(H.create(b[E],b[E+1]));return M}getPoint2dAtCheckedPointIndex(v,M){if(this.isIndexValid(v)){const b=2*v;return H.create(this._data[b],this._data[b+1],M)}}getVector2dAtCheckedVectorIndex(v,M){if(this.isIndexValid(v)){const b=2*v;return J.create(this._data[b],this._data[b+1],M)}}transferFromGrowableXYArray(v,M,b){if(this.isIndexValid(v)&&M.isIndexValid(b)){const E=2*v,D=2*b;return this._data[E]=M._data[D],this._data[E+1]=M._data[D+1],!0}return!1}pushFromGrowableXYArray(v,M){if(void 0===M){const M=v.length;return this.ensureCapacity(this.length+M,!1),this.copyData(v._data,M,this.length),this._xyInUse+=M,M}if(v.isIndexValid(M)){const b=2*M;return this.pushXY(v._data[b],v._data[b+1]),1}return 0}pushInterpolatedFromGrowableXYArray(v,M,b,E){if(v.isIndexValid(M)&&v.isIndexValid(E)){const D=1-b,X=v._data;M*=2,E*=2,this.pushXY(D*X[M]+b*X[E],D*X[M+1]+b*X[E+1])}}static createFromGrowableXYZArray(v,M,b){const E=v.length;if(b?(b.ensureCapacity(E,!1),b.clear()):b=new Te(E),M){const D=v.float64Data(),X=3*E;let z,R,O;for(let v=0;v<X;v+=3)z=D[v],R=D[v+1],O=D[v+2],b.pushXY(M.multiplyComponentXYZ(0,z,R,O),M.multiplyComponentXYZ(1,z,R,O))}else b.pushAllXYAndZ(v);return b}front(v){if(0!==this._xyInUse)return this.getPoint2dAtUncheckedPointIndex(0,v)}back(v){if(!(this._xyInUse<1))return this.getPoint2dAtUncheckedPointIndex(this._xyInUse-1,v)}setAtCheckedPointIndex(v,M){if(!this.isIndexValid(v))return!1;const b=2*v;return this._data[b]=M.x,this._data[b+1]=M.y,!0}setXYAtCheckedPointIndex(v,M,b){if(!this.isIndexValid(v))return!1;const E=2*v;return this._data[E]=M,this._data[E+1]=b,!0}setXYZAtCheckedPointIndex(v,M,b){return this.setXYAtCheckedPointIndex(v,M,b)}getPoint3dArray(v=0){const M=2*this._xyInUse,b=[],E=this._data;for(let D=0;D<M;D+=2)b.push(Q.create(E[D],E[D+1],v));return b}reverseInPlace(){const v=this.length;let M,b,E;const D=this._data;for(let X=0,z=v-1;X<z;X++,z--)M=2*X,b=2*z,E=D[M],D[M]=D[b],D[b]=E,M++,b++,E=D[M],D[M]=D[b],D[b]=E}multiplyTransformInPlace(v){const M=this._data,b=this.float64Length,E=v.matrix.coffs,D=v.origin,X=D.x,z=D.y;let R=0,O=0;for(let Y=0;Y+1<b;Y+=2)R=M[Y],O=M[Y+1],M[Y]=E[0]*R+E[1]*O+X,M[Y+1]=E[3]*R+E[4]*O+z}multiplyMatrix3dInPlace(v){const M=this._data,b=this.float64Length,E=v.coffs;let D=0,X=0;for(let z=0;z+1<b;z+=2)D=M[z],X=M[z+1],M[z]=E[0]*D+E[1]*X,M[z+1]=E[3]*D+E[4]*X}tryTransformInverseInPlace(v){const M=this._data,b=this.float64Length,E=v.matrix;E.computeCachedInverse(!0);const D=E.inverseCoffs;if(!D)return!1;const X=v.origin,z=X.x,R=X.y;let O=0,Y=0;for(let N=0;N+1<b;N+=2)O=M[N]-z,Y=M[N+1]-R,M[N]=D[0]*O+D[1]*Y,M[N+1]=D[3]*O+D[4]*Y;return!0}extendRange(v,M){const b=this.float64Length,E=this._data;if(M)for(let D=0;D+1<b;D+=2)v.extendTransformedXY(M,E[D],E[D+1]);else for(let D=0;D+1<b;D+=2)v.extendXY(E[D],E[D+1])}sumLengths(){let v=0;const M=2*(this._xyInUse-1),b=this._data;for(let E=0;E<M;E+=2)v+=K.hypotenuseXY(b[E+2]-b[E],b[E+3]-b[E+1]);return v}scaleInPlace(v){if(this._data){const M=this.float64Length;for(let b=0;b<M;b++)this._data[b]=this._data[b]*v}}interpolate(v,M,b,E){if(this.isIndexValid(v)&&this.isIndexValid(b)){const D=1-M,X=this._data;return v*=2,b*=2,H.create(D*X[v]+M*X[b],D*X[v+1]+M*X[b+1],E)}}areaXY(){let v=0;const M=2*this._xyInUse;if(M>4){const b=this._data[M-2],E=this._data[M-1];let D=this._data[0]-b,X=this._data[1]-E,z=0,R=0;for(let O=2;O<M;O+=2,D=z,X=R)z=this._data[O]-b,R=this._data[O+1]-E,v+=K.crossProductXYXY(D,X,z,R)}return.5*v}vectorIndexIndex(v,M,b){if(!this.isIndexValid(v)||!this.isIndexValid(M))return;const E=this._data;return v*=2,M*=2,J.create(E[M]-E[v],E[M+1]-E[v+1],b)}vectorXAndYIndex(v,M,b){if(this.isIndexValid(M)){const E=this._data;return M*=2,J.create(E[M]-v.x,E[M+1]-v.y,b)}}crossProductIndexIndexIndex(v,M,b){if(this.isIndexValid(v)&&this.isIndexValid(M)&&this.isIndexValid(b)){const E=2*v,D=2*M,X=2*b,z=this._data;return K.crossProductXYXY(z[D]-z[E],z[D+1]-z[E+1],z[X]-z[E],z[X+1]-z[E+1])}}crossProductXAndYIndexIndex(v,M,b){if(this.isIndexValid(M)&&this.isIndexValid(b)){const E=2*M,D=2*b,X=this._data;return K.crossProductXYXY(X[E]-v.x,X[E+1]-v.y,X[D]-v.x,X[D+1]-v.y)}}distance(v,M){if(this.isIndexValid(v)&&this.isIndexValid(M)){const b=2*v,E=2*M;return K.hypotenuseXY(this._data[E]-this._data[b],this._data[E+1]-this._data[b+1])}}distanceIndexToPoint(v,M){if(this.isIndexValid(v)){const b=2*v;return K.hypotenuseXY(M.x-this._data[b],M.y-this._data[b+1])}}static isAlmostEqual(v,M){if(v&&M){if(v.length!==M.length)return!1;for(let b=0;b<v.length;b++)if(!v.getPoint2dAtUncheckedPointIndex(b).isAlmostEqual(M.getPoint2dAtUncheckedPointIndex(b)))return!1;return!0}return!v&&!M}sortIndicesLexical(){const v=this._xyInUse,M=new Uint32Array(v);for(let b=0;b<v;b++)M[b]=b;return M.sort(((v,M)=>this.compareLexicalBlock(v,M))),M}compareLexicalBlock(v,M){let b=0,E=0;for(let D=0;D<2;D++){if(b=this._data[2*v+D],E=this._data[2*M+D],b>E)return 1;if(b<E)return-1}return v-M}component(v,M){return this._data[2*v+M]}isAlmostEqual(v,M=K.smallMetricDistance){const b=this._xyInUse;if(v._xyInUse!==b)return!1;const E=this._data,D=v._data;for(let X=0;X<2*b;X++)if(Math.abs(E[X]-D[X])>M)return!1;return!0}}function Fe(v,M,b,E,D,X,z){const R=v.length;if(E>0){for(let O=b;O+1<R;O++)if(v.vectorIndexIndex(O,O+1,z),M.crossProduct(z,z),z.normalizeInPlace())return X.addScaledInPlace(z,D),!0}else{b+1>=R&&(b=R-2);for(let E=b;E>=0;E--)if(v.vectorIndexIndex(E,E+1,z),z.crossProduct(M,z),z.normalizeInPlace())return X.addScaledInPlace(z,D),!0}return!1}class ke extends oe{isSameGeometryClass(v){return v instanceof ke}get isExtensibleFractionSpace(){return!0}get points(){return this._points.getPoint3dArray()}get packedPoints(){return this._points}get fractions(){return this._fractions}get packedDerivatives(){return this._derivatives}get packedUVParams(){return this._uvParams}get packedSurfaceNormals(){return this._surfaceNormals}get normalIndices(){return this._normalIndices}get paramIndices(){return this._uvIndices}get pointIndices(){return this._pointIndices}constructor(v){super(),this.curvePrimitiveType="lineString",this._points=v||new nt}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}static create(...v){const M=new ke;return M.addPoints(v),M}static createCapture(v){return new ke(v)}static createXY(v,M,b=!1){const E=new ke,D=E._points;for(const X of v)D.pushXYZ(X.x,X.y,M);if(b&&v.length>1){const v=D.distanceIndexIndex(0,D.length-1);if(void 0!==v&&0!==v&&K.isSameCoordinate(0,v)){D.pop();const v=D.front();D.push(v)}}return E}addPoints(...v){this._points.pushFrom(v)}addSteppedPoints(v,M,b,E){this._points.addSteppedPoints(v,M,b,E)}addPoint(v){this._points.push(v)}addPointXYZ(v,M,b=0){this._points.pushXYZ(v,M,b)}addFraction(v){this._fractions||(this._fractions=new At),this._fractions.push(v)}ensureEmptyFractions(){const v=this.numPoints();return this._fractions?(this._fractions.clear(),this._fractions.ensureCapacity(v),this._fractions):(this._fractions=new At(v),this._fractions)}ensureEmptyUVParams(){const v=this.numPoints();return this._uvParams?(this._uvParams.clear(),this._uvParams.ensureCapacity(v),this._uvParams):(this._uvParams=new Te(v),this._uvParams)}ensureEmptySurfaceNormals(){const v=this.numPoints();return this._surfaceNormals?(this._surfaceNormals.clear(),this._surfaceNormals.ensureCapacity(v),this._surfaceNormals):(this._surfaceNormals=new nt(v),this._surfaceNormals)}ensureEmptyDerivatives(){const v=this.numPoints();return this._derivatives?(this._derivatives.clear(),this._derivatives.ensureCapacity(v),this._derivatives):(this._derivatives=new nt(v),this._derivatives)}ensureEmptyNormalIndices(){const v=this.numPoints();return this._normalIndices?(this._normalIndices.clear(),this._normalIndices.ensureCapacity(v),this._normalIndices):(this._normalIndices=new At(v),this._normalIndices)}ensureEmptyUVIndices(){const v=this.numPoints();return this._uvIndices?(this._uvIndices.clear(),this._uvIndices.ensureCapacity(v),this._uvIndices):(this._uvIndices=new At(v),this._uvIndices)}ensureEmptyPointIndices(){const v=this.numPoints();return this._pointIndices?(this._pointIndices.clear(),this._pointIndices.ensureCapacity(v),this._pointIndices):(this._pointIndices=new At(v),this._pointIndices)}addUVParam(v){this._uvParams||(this._uvParams=new Te),this._uvParams.pushXY(v.x,v.y)}addUVParamAsUV(v,M){this._uvParams||(this._uvParams=new Te),this._uvParams.pushXY(v,M)}addDerivative(v){this._derivatives||(this._derivatives=new nt),this._derivatives.push(v)}addSurfaceNormal(v){this._surfaceNormals||(this._surfaceNormals=new nt),this._surfaceNormals.push(v)}addClosurePoint(){const v=this._points.distanceIndexIndex(0,this._points.length-1);void 0===v||K.isSameCoordinate(v,0)||this._points.pushWrap(1)}popPoint(){this._points.pop()}computeUVFromXYZTransform(v){this._uvParams=Te.createFromGrowableXYZArray(this._points,v)}static createRectangleXY(v,M,b,E=!0){const D=ke.create(),X=v.x,z=v.x+M,R=v.y,O=v.y+b,Y=v.z;return D.addPointXYZ(X,R,Y),D.addPointXYZ(z,R,Y),D.addPointXYZ(z,O,Y),D.addPointXYZ(X,O,Y),E&&D.addClosurePoint(),D}static createRegularPolygonXY(v,M,b,E=!0){M<3&&(M=3);const D=ke.create(),X=E?0:-1,z=Math.PI/M;let R,O,Y;E||(b/=Math.cos(z));for(let N=0;N<M;N++)Y=(X+2*N)*z,R=W.cleanupTrigValue(Math.cos(Y)),O=W.cleanupTrigValue(Math.sin(Y)),D.addPointXYZ(v.x+b*R,v.y+b*O,v.z);return D.addClosurePoint(),D}setFrom(v){this._points=v._points.clone(this._points),v._derivatives?this._derivatives=v._derivatives.clone(this._derivatives):this._derivatives=void 0,v._fractions?this._fractions=v._fractions.clone(!1):this._fractions=void 0,v._surfaceNormals?this._surfaceNormals=v._surfaceNormals.clone(this._surfaceNormals):this._surfaceNormals=void 0,v._uvParams?this._uvParams=v._uvParams.clone():this._uvParams=void 0}static createPoints(v){const M=new ke;let b;for(b of v)M._points.push(b);return M}static createIndexedPoints(v,M,b=!1){const E=new ke;for(const D of M)E._points.push(v[D]);return b&&M.length>1&&E._points.push(v[M[0]]),E}static createFloat64Array(v){const M=new ke;for(let b=0;b+3<=v.length;b+=3)M._points.push(Q.create(v[b],v[b+1],v[b+2]));return M}clone(){const v=new ke;return v.setFrom(this),v}setFromJSON(v){if(this._points.clear(),Array.isArray(v)){let M;for(M of v)this._points.push(Q.fromJSON(M))}}toJSON(){const v=[];let M=0;for(;this._points.isIndexValid(M);)v.push(this._points.getPoint3dAtUncheckedPointIndex(M).toJSON()),M++;return v}static fromJSON(v){const M=new ke;return M.setFromJSON(v),M}fractionToPoint(v,M){const b=this._points.length;if(0===b)return Q.createZero();if(1===b)return Q.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0),M);const E=1/(b-1);if(v<=E)return this._points.interpolate(0,v/E,1,M);if(v+E>=1)return this._points.interpolate(b-1,(1-v)/E,b-2,M);const D=Math.floor(v/E);return this._points.interpolate(D,(v-D*E)/E,D+1,M)}fractionToPointAndDerivative(v,M){M=M||Mt.createZero();const b=this._points.length;if(b<=1)return M.direction.setZero(),1===b?M.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0)):M.origin.setZero(),M;const E=1/(b-1);if(v<=E)return M=M||Mt.createZero(),this._points.interpolate(0,v/E,1,M.origin),this._points.vectorIndexIndex(0,1,M.direction),M.direction.scaleInPlace(1/E),M;if(v+E>=1)return M=M||Mt.createZero(),this._points.interpolate(b-2,1-(1-v)/E,b-1,M.origin),this._points.vectorIndexIndex(b-2,b-1,M.direction),M.direction.scaleInPlace(1/E),M;M=M||Mt.createZero();const D=Math.floor(v/E),X=(v-D*E)/E;return this._points.interpolate(D,X,D+1,M.origin),this._points.vectorIndexIndex(D,D+1,M.direction),M.direction.scaleInPlace(1/E),M}fractionToPointAnd2Derivatives(v,M){const b=this.fractionToPointAndDerivative(v);return bt.createCapture(b.origin,b.direction,$.createZero(),M)}segmentIndexAndLocalFractionToGlobalFraction(v,M){const b=this._points.length-1;return b<1?0:(v+M)/b}globalFractionToSegmentIndexAndLocalFraction(v){const M=this._points.length-1;if(M<1)return{index:0,fraction:0};const b=v*M;let E;return E=v<0?0:v>1?M-1:Math.floor(b),{index:E,fraction:b-E}}fractionToFrenetFrame(v,M){const b=this._points.length;if(b<=1)return 1===b?pt.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0),M):pt.createIdentity(M);if(2===b)return pt.createRefs(this._points.interpolate(0,v,1),xt.createRigidHeadsUp(this._points.vectorIndexIndex(0,1),z.XYZ));const E=b-1,D=1/E;let X=0,R=0;v<=D?(R=v/D,X=0):v+D>=1?(X=b-2,R=1-(1-v)/D):(X=Math.floor(v/D),R=v*E-X);const O=this._points.interpolate(X,R,X+1),Y=this._points.vectorIndexIndex(X,X+1),N=$.create(),B=$.create();0===X?Fe(this._points,Y,X+1,1,1,N,B):X+2>=b?Fe(this._points,Y,X-1,-1,1,N,B):(Fe(this._points,Y,X-1,-1,1-R,N,B),Fe(this._points,Y,X+1,1,R,N,B));const V=xt.createRigidFromColumns(N,Y,z.ZXY);return V?pt.createOriginAndMatrix(O,V,M):pt.createTranslation(O,M)}startPoint(){return 0===this._points.length?Q.createZero():this._points.getPoint3dAtUncheckedPointIndex(0)}pointAt(v,M){if(this._points.isIndexValid(v))return this._points.getPoint3dAtUncheckedPointIndex(v,M)}vectorBetween(v,M,b){return this._points.vectorIndexIndex(v,M,b)}derivativeAt(v,M){if(this._derivatives&&this._derivatives.isIndexValid(v))return this._derivatives.getVector3dAtCheckedVectorIndex(v,M)}surfaceNormalAt(v,M){if(this._surfaceNormals&&this._surfaceNormals.isIndexValid(v))return this._surfaceNormals.getVector3dAtCheckedVectorIndex(v,M)}numPoints(){return this._points.length}endPoint(){return 0===this._points.length?Q.createZero():this._points.getPoint3dAtUncheckedPointIndex(this._points.length-1)}reverseInPlace(){this._points.length>=2&&(this._points.reverseInPlace(),this._uvParams&&this._uvParams.reverseInPlace())}tryTransformInPlace(v){return this._points.multiplyTransformInPlace(v),this._derivatives&&this._derivatives.multiplyMatrix3dInPlace(v.matrix),this._surfaceNormals&&this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(v.matrix),!0}curveLength(){return this._points.sumLengths()}curveLengthBetweenFractions(v,M){const b=this._points.length-1;if(M===v||b<1)return 0;if(M<v)return this.curveLengthBetweenFractions(M,v);const E=v*b,D=M*b,X=Math.max(1,Math.ceil(E)),z=Math.min(Math.floor(D),b-1),R=X-E,O=D-z;if(X>z)return Math.abs(D-E)*this._points.distanceIndexIndex(X-1,X);{let v=R*this._points.distanceIndexIndex(X-1,X)+O*this._points.distanceIndexIndex(z,z+1);for(let M=X;M<z;M++)v+=this._points.distanceIndexIndex(M,M+1);return v}}rangeBetweenFractions(v,M,b){const E=ut.create();if(this.points.length<1)return E;if(M<v)return this.rangeBetweenFractions(M,v,b);const D=this._points.length-1,X=v*D,z=Math.max(0,Math.floor(X)),R=X-z,O=Q.create();if(this._points.interpolate(z,R,z+1,O),E.extendPoint(O,b),M===v)return E;const Y=M*D,N=Math.min(Math.floor(Y),D-1),B=Y-N;this._points.interpolate(N,B,N+1,O),E.extendPoint(O,b);for(let V=z+1;V<=N;V++)this._points.getPoint3dAtUncheckedPointIndex(V,O),E.extendPoint(O,b);return E}moveSignedDistanceFromFraction(v,M,b,E){const D=this._points.length-1,X=v*D;let z=K.restrictToInterval(Math.floor(X),0,D-1);const R=X-z,O=this._points.interpolate(z,R,z+1,ke._workPointA),Y=ke._workPointB,N=new Me(O,v,M);if(M>0){for(;z<=D;)if(z++,this._points.getPoint3dAtCheckedPointIndex(z,Y),N.announcePoint(Y,z/D))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,N.fraction0,N.point0,M,U.success,E);return b&&N.announceExtrapolation(this._points,D-1,D,(D-1)/D,1),vt.createCurveFractionPointDistanceCurveSearchStatus(this,N.fraction0,N.point0,M,N.distanceStatus(),E)}for(R<=0&&z--;z>=0;z--)if(this._points.getPoint3dAtCheckedPointIndex(z,Y),N.announcePoint(Y,z/D))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,N.fraction0,N.point0,M,U.success,E);return b&&N.announceExtrapolation(this._points,1,0,1/D,0),vt.createCurveFractionPointDistanceCurveSearchStatus(this,N.fraction0,N.point0,-N.distance0,N.distanceStatus(),E)}quickLength(){return this.curveLength()}quickUnitNormal(v){let M=Math.floor(this._points.length/3);if(M<1&&(M=1),(v=this._points.crossProductIndexIndexIndex(0,M,M+M))&&v.normalizeInPlace())return v}closestPoint(v,M,b){b=vt.create(this,b);const E=ee.resolveVariantCurveExtendParameterToCurveExtendMode(M,0),D=ee.resolveVariantCurveExtendParameterToCurveExtendMode(M,1),X=this._points.length;if(X>0){const M=X-1;if(b.setFP(1,this._points.getPoint3dAtUncheckedPointIndex(M),void 0),b.setDistanceTo(v),X>1){let z=0,R=0;for(let O=1;O<X;O++)z=v.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(O-1),this._points.getPoint3dAtUncheckedPointIndex(O)),z<0?(!E||O>1)&&(z=0):z>1&&(!D||O<M)&&(z=1),this._points.getPoint3dAtUncheckedPointIndex(O-1).interpolate(z,this._points.getPoint3dAtUncheckedPointIndex(O),b.pointQ),R=b.pointQ.distance(v),R<b.a&&b.setFP(this.segmentIndexAndLocalFractionToGlobalFraction(O-1,z),b.pointQ,void 0,R)}}return b}isInPlane(v){return this._points.isCloseToPlane(v,K.smallMetricDistance)}static pushVertexHit(v,M,b,E,D){const X=vt.createCurveFractionPoint(b,E,D);v.push(X),0===M?X.setIntervalRole(L.isolatedAtVertex):1===M?(v[v.length-2].setIntervalRole(L.intervalStart),X.setIntervalRole(L.intervalEnd)):(v[v.length-2].setIntervalRole(L.intervalInterior),X.setIntervalRole(L.intervalEnd))}appendPlaneIntersectionPoints(v,M){if(this._points.length<1)return 0;const b=M.length,E=this._points.length,D=1===E?1:E-1,X=ke._workPointA,z=ke._workPointB,R=ke._workPointC;this._points.getPoint3dAtUncheckedPointIndex(0,X);let O=0,Y=0,N=0,B=0;for(let V=0;V<this._points.length;V++,X.setFrom(z),N=O)if(this._points.getPoint3dAtUncheckedPointIndex(V,z),O=K.correctSmallMetricDistance(v.altitude(z)),0===O)ke.pushVertexHit(M,Y++,this,V/D,z);else if(N*O<0){B=N/(N-O),X.interpolate(B,z,R);const v=vt.createCurveFractionPoint(this,(V-1+B)/D,R);v.setIntervalRole(L.isolated),M.push(v),Y=0}return M.length-b}extendRange(v,M){this._points.extendRange(v,M)}isAlmostEqual(v){return v instanceof ke&&!!nt.isAlmostEqual(this._points,v._points)}appendStrokePoint(v,M){const b=this._points.length;let E=!0;const D=void 0!==M&&void 0!==this._fractions;b>0&&(D&&K.isSameCoordinate(M,this._fractions.back())&&(E=!1),v.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(b-1))&&(E=!1)),E&&(this._points.push(v),D&&this.addFraction(M))}removeDuplicatePoints(v=K.smallMetricDistance){const M=this._points.length;if(M<2)return;let b=1;for(let E=1;E<M;E++){const M=this._points.distanceIndexIndex(E,b-1);void 0!==M&&M>v&&(this._points.moveIndexToIndex(E,b),void 0!==this._fractions&&this._fractions.setAtUncheckedIndex(b,this._fractions.atUncheckedIndex(E)),this._derivatives&&this._derivatives.moveIndexToIndex(E,b),b++)}this._points.resize(b),this._fractions&&this._fractions.resize(b),this._derivatives&&this._derivatives.resize(b)}appendFractionToPoint(v,M){if(this._derivatives){const b=v.fractionToPointAndDerivative(M,ke._workRay);this._fractions&&this._fractions.push(M),this._points.push(b.origin),this._derivatives&&this._derivatives.push(b.direction)}else{const b=v.fractionToPoint(M,ke._workPointA);this._fractions&&this._fractions.push(M),this._points.push(b)}}clear(){this._points.clear(),this._fractions&&this._fractions.clear(),this._derivatives&&this._derivatives.clear()}static createForStrokes(v=0,M){const b=ke.create();return v>0&&b._points.ensureCapacity(v),M&&(M.needParams&&(b._fractions=new At(v),b._uvParams=new Te(v)),M.needNormals&&(b._derivatives=new nt(v),b._surfaceNormals=new nt(v))),b}appendFractionalStrokePoints(v,M,b=0,E=1,D=!0){let X=1,z=M-1;if(D&&(X=0,z=M),M>=1){const D=(E-b)/M;for(let M=X;M<=z;M++)this.appendFractionToPoint(v,b+M*D)}}appendInterpolatedStrokePoints(v,M,b,E){if(E&&this.appendStrokePoint(M,0),v>1){const E=1/v;for(let D=1;D<v;D++){const v=D*E;this.appendStrokePoint(M.interpolate(v,b),v)}}E&&this.appendStrokePoint(b,1)}emitStrokes(v,M){const b=this._points.length,E=ke._workPointA,D=ke._workPointB;if(b>0)if(M&&M.hasMaxEdgeLength){v.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));for(let X=1;X<b;X++){this._points.getPoint3dAtUncheckedPointIndex(X-1,E),this._points.getPoint3dAtUncheckedPointIndex(X,D);const b=M.applyMaxEdgeLength(1,E.distance(D));b>1&&v.appendInterpolatedStrokePoints(b,E,D,!1),v.appendStrokePoint(D)}}else for(let X=0;X<b;X++)v.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(X))}emitStrokableParts(v,M){const b=this._points.length;if(v.startCurvePrimitive(this),b>1){const E=1/(b-1);if(M&&M.hasMaxEdgeLength)for(let D=1;D<b;D++){const b=M.applyMaxEdgeLength(1,this._points.getPoint3dAtUncheckedPointIndex(D-1).distance(this._points.getPoint3dAtUncheckedPointIndex(D)));v.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(D-1),this._points.getPoint3dAtUncheckedPointIndex(D),b,(D-1)*E,D*E)}else for(let M=1;M<b;M++)v.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(M-1),this._points.getPoint3dAtUncheckedPointIndex(M),1,(M-1)*E,M*E)}v.endCurvePrimitive(this)}computeStrokeCountForOptions(v){const M=this._points.length;let b=M-1;if(v&&v.hasMaxEdgeLength){b=0;for(let E=1;E<M;E++)b+=v.applyMaxEdgeLength(1,this._points.distanceIndexIndex(E-1,E))}return b}computeAndAttachRecursiveStrokeCounts(v,M){const b=this._points.length,E=void 0!==v&&v.hasMaxEdgeLength,D=zt.createWithCurvePrimitiveAndOptionalParent(this,M,[]);for(let X=1;X<b;X++){const M=this._points.distanceIndexIndex(X-1,X),b=E?v.applyMaxEdgeLength(1,M):1;D.addToCountAndLength(b,M)}oe.installStrokeCountMap(this,D,M)}dispatchToGeometryHandler(v){return v.handleLineString3d(this)}announceClipIntervals(v,M){const b=this._points.length;if(b<2)return!1;let E=0,D=1;const r=(v,b)=>{M&&M(K.interpolate(E,v,D),K.interpolate(E,b,D),this)},X=ke._workPointA,z=ke._workPointB;this._points.getPoint3dAtUncheckedPointIndex(0,X);let R=!1;for(let O=1;O<b;O++,X.setFrom(z),E=D)this._points.getPoint3dAtUncheckedPointIndex(O,z),D=O/(b-1),v.announceClippedSegmentIntervals(0,1,X,z,r)&&(R=!0);return R}addResolvedPoint(v,M,b){const E=this._points.length;if(0!==E){if(1===E)return this._points.getPoint3dAtUncheckedPointIndex(0,ke._indexPoint),void b.push(ke._indexPoint);v<0&&(v=0),v>E-2&&(v=E-2,M+=1),this._points.interpolate(v,M,v+1,ke._indexPoint),b.push(ke._indexPoint)}}clonePartialCurve(v,M){if(M<v){const b=this.clonePartialCurve(M,v);return b&&b.reverseInPlace(),b}const b=this._points.length;if(b<2)return this.clone();let E,D;b>2&&this.isPhysicallyClosed&&(v<0&&(v=0),M>1&&(M=1));const X=this.globalFractionToSegmentIndexAndLocalFraction(v),z=this.globalFractionToSegmentIndexAndLocalFraction(M);E=v<0?1:0<=v&&v<=1?K.isSmallRelative(1-X.fraction)?X.index+2:X.index+1:b,D=M<0?-1:0<=M&&M<=1?K.isSmallRelative(z.fraction)?z.index-1:z.index:b-2;const R=ke.create();this.addResolvedPoint(X.index,X.fraction,R._points);for(let O=E;O<=D;O++)this._points.isIndexValid(O)&&(this._points.getPoint3dAtUncheckedPointIndex(O,ke._workPointA),R._points.push(ke._workPointA));return this.addResolvedPoint(z.index,z.fraction,R._points),R}getIndexedSegment(v){if(v>=0&&v+1<this._points.length)return we.create(this._points.getPoint3dAtCheckedPointIndex(v),this._points.getPoint3dAtCheckedPointIndex(v+1))}get isPhysicallyClosed(){return this._points.length>0&&K.isSmallMetricDistance(this._points.distanceIndexIndex(0,this._points.length-1))}addMappedStrokesToLineString3D(v,M){const b=M.numPoints(),E=void 0!==M._fractions,D=void 0!==M._derivatives,X=this._points,z=ke._workPointA,R=ke._workPointB,O=ke._workPointC,Y=X.length;if(v.primitive&&v.primitive===this&&v.componentData&&v.componentData.length+1===Y){X.getPoint3dAtUncheckedPointIndex(0,z);for(let b=0;b+1<Y;b++,z.setFromPoint3d(R)){X.getPoint3dAtUncheckedPointIndex(b+1,R);const Y=v.componentData[b],N=Y.numStroke,B=z.vectorTo(R);B.scale(N);for(let v=0;v<=N;v++){const b=v/N,X=Y.fractionToA(b);M.addPoint(z.interpolate(b,R,O)),E&&M._fractions.push(X),D&&M._derivatives.push(B)}}}return M.numPoints()-b}static createArrayOfLineString3d(v){const M=new at;lt.streamXYZ(v,M);const b=M.claimArrayOfGrowableXYZArray(),E=[];if(void 0!==b)for(const D of b)E.push(ke.createCapture(D));return E}collectCurvePrimitivesGo(v,M,b=!1){if(b){let M;for(let b=0;void 0!==(M=this.getIndexedSegment(b));b++)v.push(M)}else v.push(this)}constructOffsetXY(v){const M=Se.create(v),b=[];for(const E of this.collectCurvePrimitives(void 0,!0,!0)){const v=E.constructOffsetXY(M);void 0!==v&&(v instanceof oe?b.push(v):Array.isArray(v)&&v.forEach((v=>b.push(v))))}return b}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}}ke._workPointA=Q.create(),ke._workPointB=Q.create(),ke._workPointC=Q.create(),ke._workRay=Mt.createXAxis(),ke._indexPoint=Q.create();class Me{constructor(v,M,b){this.point0=v,this.distance0=0,this.targetDistance=Math.abs(b),this.fraction0=M}distanceStatus(){return K.isSameCoordinate(this.distance0,this.targetDistance)?U.success:U.stoppedAtBoundary}announcePoint(v,M){const b=this.point0.distance(v),E=this.distance0+b;if(E<this.targetDistance&&!K.isSameCoordinate(E,this.targetDistance))return this.point0.setFromPoint3d(v),this.distance0=E,this.fraction0=M,!1;const D=this.targetDistance-this.distance0,X=K.safeDivideFraction(D,b,0);return this.point0.interpolate(X,v,this.point0),this.fraction0=K.interpolate(this.fraction0,X,M),this.distance0=this.targetDistance,!0}announceExtrapolation(v,M,b,E,D){const X=this.targetDistance-this.distance0,z=v.distanceIndexIndex(M,b);if(!z)return!1;const R=K.conditionalDivideFraction(X,z);return void 0!==R&&(v.interpolate(b,-R,M,this.point0),this.distance0=this.targetDistance,this.fraction0=K.interpolate(D,-R,E),!0)}}class be extends Pe{constructor(){super(void 0)}doClone(v){if(v instanceof ke&&v.numPoints()>1){const M=v.packedPoints,b=M.length,E=[];for(let v=0;v+1<b;v++)E.push(we.createCapture(M.getPoint3dAtUncheckedPointIndex(v),M.getPoint3dAtUncheckedPointIndex(v+1)));return E}return v.clone()}static clone(v){const M=new be;return v.announceToCurveProcessor(M),M._result}}class Ee extends ve{constructor(){super(),this.numLineSegment=0,this.numLineString=0,this.numOther=0}static hasNonLinearPrimitives(v){const M=new Ee;return v.announceToCurveProcessor(M),M.numOther>0}announceCurvePrimitive(v,M){v instanceof we?this.numLineSegment++:v instanceof ke?this.numLineString++:this.numOther++}}class De extends ve{constructor(){super(),this.maxGap=0}static maxGap(v){const M=new De;return v.announceToCurveProcessor(M),M.maxGap}announceCurvePrimitive(v,M){if(this._stack.length>0){const b=this._stack[this._stack.length-1];if(b instanceof Ne){const E=b.cyclicCurvePrimitive(M+1);void 0!==v&&void 0!==E&&(this.maxGap=Math.max(this.maxGap,v.endPoint().distance(E.startPoint())))}}}}class Xe extends _e{constructor(){super(),this._sum=0}static sumLengths(v){const M=new Xe;return v.announceToCurveProcessor(M),M._sum}announceCurvePrimitive(v,M){this._sum+=v.curveLength()}}class Re extends _e{constructor(v){super(),this.numFail=0,this.numOK=0,this.transform=v}static tryTransformInPlace(v,M){const b=new Re(M);return v.announceToCurveProcessor(b),0===b.numFail}announceCurvePrimitive(v,M){v.tryTransformInPlace(this.transform)?this.numOK++:this.numFail++}}class ze extends Nt{constructor(){super(...arguments),this.geometryCategory="curveCollection",this.isInner=!1}sumLengths(){return Xe.sumLengths(this)}closestPoint(v){let M;if(void 0!==this.children)for(const b of this.children)if(b instanceof oe){const E=b.closestPoint(v,!1);M=vt.chooseSmallerA(M,E)}else if(b instanceof ze){const E=b.closestPoint(v);M=vt.chooseSmallerA(M,E)}return M}maxGap(){return De.maxGap(this)}checkForNonLinearPrimitives(){return Ee.hasNonLinearPrimitives(this)}tryTransformInPlace(v){return Re.tryTransformInPlace(this,v)}clone(){return Pe.clone(this)}cloneTransformed(v){return Pe.clone(this,v)}cloneWithExpandedLineStrings(){return be.clone(this)}collectCurvePrimitivesGo(v,M,b=!1){if(this.children)for(const E of this.children)(E instanceof oe||E instanceof ze)&&E.collectCurvePrimitivesGo(v,M,b)}collectCurvePrimitives(v,M=!1,b=!1){const E=void 0===v?[]:v;return this.collectCurvePrimitivesGo(E,M,b),E}get isAnyRegionType(){return 2===this.dgnBoundaryType()||4===this.dgnBoundaryType()||5===this.dgnBoundaryType()}isAnyRegion(){return this.isAnyRegionType}get isOpenPath(){return 1===this.dgnBoundaryType()}isPath(){return this.isOpenPath}get isClosedPath(){return 2===this.dgnBoundaryType()}isLoop(){return this.isClosedPath}extendRange(v,M){const b=this.children;if(b)for(const E of b)E.extendRange(v,M)}static createCurveLocationDetailOnAnyCurvePrimitive(v,M=.5){if(v){if(v instanceof oe)return vt.createCurveEvaluatedFraction(v,M);if(v instanceof ze&&void 0!==v.children)for(const b of v.children){const v=this.createCurveLocationDetailOnAnyCurvePrimitive(b,M);if(v)return v}}}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}}class Ne extends ze{constructor(){super(),this._curves=[]}get children(){return this._curves}cyclicCurvePrimitive(v,M=!0){const b=this.children.length;if(0!==b){if(v>=0&&v<b)return this.children[v];if(M){const M=K.modulo(v,b);return this.children[M]}}}getPackedStrokes(v){const M=this.cloneStroked(v);if(M instanceof Ne){const v=M.children;if(1===v.length){const M=v[0];if(M instanceof ke)return M.packedPoints}}}tryAddChild(v){return!!(v&&v instanceof oe)&&(this._curves.push(v),!0)}getChild(v){if(v<this._curves.length)return this._curves[v]}extendRange(v,M){for(const b of this._curves)b.extendRange(v,M)}reverseChildrenInPlace(){for(const v of this._curves)v.reverseInPlace();this._curves.reverse()}childIndex(v,M){for(let b=0;b<this._curves.length;b++)if(this._curves[b]===v)return b;if(M)for(let b=0;b<this._curves.length;b++){const M=this._curves[b];if(M instanceof pe&&M.proxyCurve===v)return b}}primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(v,M,b=!1,E){const D=this.cyclicCurvePrimitive(v,b);if(D)return vt.createCurveEvaluatedFractionPointAndDerivative(D,M,E)}}class Ye extends ze{isSameGeometryClass(v){return v instanceof Ye}constructor(){super(),this.curveCollectionType="bagOfCurves",this._children=[]}get children(){return this._children}static create(...v){const M=new Ye;for(const b of v)M.tryAddChild(b);return M}dgnBoundaryType(){return 0}announceToCurveProcessor(v,M=-1){return v.announceBagOfCurves(this,M)}cloneStroked(v){const M=new Ye;let b;for(b of this.children)if(b instanceof oe){const E=ke.create();b.emitStrokes(E,v),E&&M.children.push(E)}else if(b instanceof ze){const E=b.cloneStroked(v);E&&M.children.push(E)}return M}cloneEmptyPeer(){return new Ye}tryAddChild(v){return v&&this._children.push(v),!0}getChild(v){if(v<this._children.length)return this._children[v]}dispatchToGeometryHandler(v){return v.handleBagOfCurves(this)}}class Oe extends Ne{isSameGeometryClass(v){return v instanceof Oe}constructor(){super(),this.curveCollectionType="loop",this.isInner=!1}static create(...v){const M=new Oe;for(const b of v)M.children.push(b);return M}static createArray(v){const M=new Oe;for(const b of v)M.children.push(b);return M}static createPolygon(v){const M=ke.create(v);return M.addClosurePoint(),Oe.create(M)}cloneStroked(v){const M=ke.create();for(const b of this.children)b.emitStrokes(M,v);return M.removeDuplicatePoints(),M.isPhysicallyClosed&&(M.popPoint(),M.addClosurePoint()),Oe.create(M)}dgnBoundaryType(){return 2}announceToCurveProcessor(v,M=-1){return v.announceLoop(this,M)}cloneEmptyPeer(){return new Oe}dispatchToGeometryHandler(v){return v.handleLoop(this)}}class Be{constructor(v,M,b,E){this.loopA=v,this.curveA=M,this.loopB=b,this.curveB=E}setA(v,M){this.loopA=v,this.curveA=M}setB(v,M){this.loopB=v,this.curveB=M}}class Ve extends Ne{isSameGeometryClass(v){return v instanceof Ve}announceToCurveProcessor(v,M=-1){return v.announcePath(this,M)}constructor(){super(),this.curveCollectionType="path"}static create(...v){const M=new Ve;for(const b of v)b instanceof oe?M.children.push(b):Array.isArray(b)&&b.length>0&&b[0]instanceof Q&&M.children.push(ke.create(b));return M}static createArray(v){const M=new Ve;for(const b of v)M.children.push(b);return M}cloneStroked(v){const M=ke.create();for(const b of this.children)b.emitStrokes(M,v);return Ve.create(M)}dgnBoundaryType(){return 1}cloneEmptyPeer(){return new Ve}dispatchToGeometryHandler(v){return v.handlePath(this)}}class Le{handleCurveCollection(v){}handlePath(v){return this.handleCurveCollection(v)}handleLoop(v){return this.handleCurveCollection(v)}handleParityRegion(v){return this.handleCurveCollection(v)}handleUnionRegion(v){return this.handleCurveCollection(v)}handleBagOfCurves(v){return this.handleCurveCollection(v)}handleCurveChainWithDistanceIndex(v){return v.path instanceof Ve?this.handlePath(v.path):v.path instanceof Oe?this.handleLoop(v.path):this.handleCurveCollection(v.path)}}class Ue extends Le{handleLineSegment3d(v){}handleLineString3d(v){}handleArc3d(v){}handleCurveCollection(v){}handleCurveChainWithDistanceIndex(v){}handleBSplineCurve3d(v){}handleInterpolationCurve3d(v){}handleAkimaCurve3d(v){}handleBSplineCurve3dH(v){}handleBSplineSurface3d(v){}handleCoordinateXYZ(v){}handleBSplineSurface3dH(v){}handleIndexedPolyface(v){}handleTransitionSpiral(v){}handlePath(v){}handleLoop(v){}handleParityRegion(v){}handleUnionRegion(v){}handleBagOfCurves(v){}handleSphere(v){}handleCone(v){}handleBox(v){}handleTorusPipe(v){}handleLinearSweep(v){}handleRotationalSweep(v){}handleRuledSweep(v){}handlePointString3d(v){}handleBezierCurve3d(v){}handleBezierCurve3dH(v){}}class Ze extends Le{handleLineSegment3d(v){}handleLineString3d(v){}handleArc3d(v){}handleBSplineCurve3d(v){}handleInterpolationCurve3d(v){}handleAkimaCurve3d(v){}handleBSplineCurve3dH(v){}handleBSplineSurface3d(v){}handleCoordinateXYZ(v){}handleBSplineSurface3dH(v){}handleIndexedPolyface(v){}handleTransitionSpiral(v){}handleChildren(v){const M=v.children;if(M)for(const b of M)b.dispatchToGeometryHandler(this)}handleCurveCollection(v){return this.handleChildren(v)}handleSphere(v){}handleCone(v){}handleBox(v){}handleTorusPipe(v){}handleLinearSweep(v){}handleRotationalSweep(v){}handleRuledSweep(v){}handlePointString3d(v){}handleBezierCurve3d(v){}handleBezierCurve3dH(v){}}class qe extends Ze{constructor(v){super(),this.plane=v,this.range=ft.createNull(),this.resetRange()}resetRange(){this.range.setNull()}announcePoint(v){const M=this.plane.altitude(v);this.range.extendLow(M)&&(this.lowPoint=v.clone(this.lowPoint)),this.range.extendHigh(M)&&(this.highPoint=v.clone(this.highPoint))}announcePoints(v){for(let M=0;M<v.length;M++){const b=v.evaluateUncheckedIndexPlaneAltitude(M,this.plane);this.range.extendLow(b)&&(this.lowPoint=v.getPoint3dAtUncheckedPointIndex(M,this.lowPoint)),this.range.extendHigh(b)&&(this.highPoint=v.getPoint3dAtUncheckedPointIndex(M,this.highPoint))}}static createCapture(v){return new qe(v)}handleLineSegment3d(v){this.announcePoint(v.point0Ref),this.announcePoint(v.point1Ref)}handleLineString3d(v){this.announcePoints(v.packedPoints)}initStrokeOptions(){void 0===this._strokeOptions&&(this._strokeOptions=new Ie,this._strokeOptions.angleTol=W.createDegrees(1))}handleBSplineCurve3d(v){this.initStrokeOptions();const M=ke.create();v.emitStrokes(M,this._strokeOptions),this.handleLineString3d(M)}handleBSplineCurve3dH(v){this.initStrokeOptions();const M=ke.create();v.emitStrokes(M,this._strokeOptions),this.handleLineString3d(M)}handleArc3d(v){this._sineCosinePolynomial=v.getPlaneAltitudeSineCosinePolynomial(this.plane,this._sineCosinePolynomial);let M=this._sineCosinePolynomial.referenceMinMaxRadians();v.sweep.isRadiansInSweep(M)&&this.announcePoint(this._workPoint=v.radiansToPoint(M,this._workPoint)),M+=Math.PI,v.sweep.isRadiansInSweep(M)&&this.announcePoint(this._workPoint=v.radiansToPoint(M,this._workPoint)),this.announcePoint(this._workPoint=v.startPoint(this._workPoint)),this.announcePoint(this._workPoint=v.endPoint(this._workPoint))}static findExtremesInDirection(v,M){const b=M instanceof Mt?M.origin:Q.createZero(),E=M instanceof Mt?M.direction:M,D=yt.create(b,E);if(D){const M=new qe(D);if(v instanceof Nt)v.dispatchToGeometryHandler(M);else if(v instanceof nt)M.announcePoints(v);else for(const b of v)M.announcePoint(b);return M}}static findExtremePointsInDirection(v,M,b){const E=this.findExtremesInDirection(v,M);if(E&&E.highPoint&&E.lowPoint)return we.create(E.lowPoint,E.highPoint,b)}static findExtremeAltitudesInDirection(v,M,b){const E=this.findExtremesInDirection(v,M);if(E&&!E.range.isNull)return ft.createFrom(E.range,b)}static findExtremeFractionsAlongDirection(v,M,b){const E=this.findExtremeAltitudesInDirection(v,M,b);if(void 0!==E){const v=M instanceof $?M.magnitude():M.direction.magnitude(),b=K.conditionalDivideCoordinate(1,v);if(void 0!==b)return E.low*=b,E.high*=b,E}}}class We{constructor(v,M){this.x0=v,this.x1=M}set(v,M){this.x0=v,this.x1=M}shift(v){this.x0+=v,this.x1+=v}static create(v=0,M=1,b){return b?(b.set(v,M),b):new We(v,M)}setFrom(v){this.x0=v.x0,this.x1=v.x1}clone(){return new We(this.x0,this.x1)}get isIn01(){return K.isIn01(this.x0)&&K.isIn01(this.x1)}fractionToPoint(v){return K.interpolate(this.x0,v,this.x1)}signedDelta(){return this.x1-this.x0}absoluteDelta(){return Math.abs(this.x1-this.x0)}reverseInPlace(){const v=this.x0;this.x0=this.x1,this.x1=v}reverseIfNeededForDeltaSign(v=1){v*(this.x1-this.x0)<0&&this.reverseInPlace()}isAlmostEqual(v){return K.isSameCoordinate(this.x0,v.x0)&&K.isSameCoordinate(this.x1,v.x1)}get isExact01(){return 0===this.x0&&1===this.x1}get isExact01Reversed(){return 1===this.x0&&0===this.x1}clipBy01FunctionValuesPositive(v,M){const b=M-v,E=v+this.x0*b,D=v+this.x1*b,X=D-E;if(E>0){if(D>=0)return!0;const v=-E/X;return this.x1=this.x0+v*(this.x1-this.x0),!0}if(E<0){if(D<0)return!1;const v=-E/X;return this.x0=this.x0+v*(this.x1-this.x0),!0}return D>0}clampDirectedTo01(v=!0,M=!0,b=!1){let E=this.x0,D=this.x1;if(D>E){if(E<0&&v&&(E=0),D>1&&M&&(D=1),E>D||E===D&&!b)return!1}else if(E>1&&M&&(E=1),D<0&&v&&(D=0),E<D||E===D&&!b)return!1;return this.set(E,D),!0}}class Ge{constructor(v,M){this._blockSize=v,this._order=Math.floor(M.length/v),this._packedData=M,this._basis=new Vt(this._order)}clonePolygon(v){const M=this._packedData.length;if(!v||v.length!==M)return this._packedData.slice();for(let b=0;b<M;b++)v[b]=this._packedData[b];return v}get order(){return this._order}get packedData(){return this._packedData}static create(v){if(!(v.length<1)){if(v[0]instanceof Q){const M=new Float64Array(3*v.length);let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y,M[b++]=E.z;return new Ge(3,M)}if(v[0]instanceof Dt){const M=new Float64Array(4*v.length);let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y,M[b++]=E.z,M[b++]=E.w;return new Ge(4,M)}if(v[0]instanceof H){const M=new Float64Array(2*v.length);let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y;return new Ge(2,M)}}}evaluate(v,M){return this._basis.sumBasisFunctions(v,this._packedData,this._blockSize,M)}evaluateDerivative(v,M){return this._basis.sumBasisFunctionDerivatives(v,this._packedData,this._blockSize,M)}getPolygonPoint(v,M){if((!M||M.length<this._blockSize)&&(M=new Float64Array(this._blockSize)),v>=0&&v<this._order){const b=this._blockSize*v;for(let v=0;v<this._blockSize;v++)M[v]=this._packedData[b+v];return M}}setPolygonPoint(v,M){if(v>=0&&v<this._order){const b=this._blockSize*v;for(let v=0;v<this._blockSize;v++)this._packedData[b+v]=M[v]}}loadSpanPoles(v,M){let b=M*this._blockSize;for(let E=0;E<this._packedData.length;E++)this._packedData[E]=v[b++]}loadSpanPolesWithWeight(v,M,b,E){let D=0;const X=this._order;let z=b*M;for(let R=0;R<X;R++){for(let b=0;b<M;b++)this._packedData[D++]=v[z++];this._packedData[D++]=E}}unpackToJsonArrays(){return de.unpackNumbersToNestedArrays(this._packedData,this._blockSize)}isAlmostEqual(v){if(v instanceof Ge){if(this._blockSize!==v._blockSize)return!1;if(this._order!==v._order)return!1;if(this._packedData.length!==v._packedData.length)return!1;for(let M=0;M<this._packedData.length;M++)if(!K.isSameCoordinate(this._packedData[M],v._packedData[M]))return!1;return!0}return!1}reverseInPlace(){const v=this._blockSize;let M,b,E;for(M=0,b=(this._order-1)*v;M<b;M+=v,b-=v)for(let D=0;D<v;D++)E=this._packedData[M+D],this._packedData[M+D]=this._packedData[b+D],this._packedData[b+D]=E}interpolatePoleInPlace(v,M,b){let E=v*this._blockSize,D=b*this._blockSize;const X=this._packedData;for(let z=0;z<this._blockSize;z++,E++,D++)X[E]+=M*(X[D]-X[E])}saturateInPlace(v,M){const b=v.degree,E=M+b-1,D=E+1;if(M<0||M>=v.numSpans)return!1;const X=v.knots,z=X[E],R=X[D];if(this.setInterval(z,R),R<=z+fe.knotTolerance)return!1;for(let O=b-1;O>0;O--){let v=E-O;if(X[v]<z){let M=D;for(let b=0;b<O;b++,v++,M++){const E=X[v],D=(z-E)/(X[M]-E);this.interpolatePoleInPlace(b,D,b+1)}}}for(let O=b-1;O>0;O--){let v=D+O;if(X[v]>R)for(let M=0;M<O;M++,v--){const E=X[v],D=(R-E)/(z-E);this.interpolatePoleInPlace(b-M,D,b-M-1)}}return!0}static saturate1dInPlace(v,M,b){const E=M.degree,D=b+E-1,X=D+1;if(b<0||b>=M.numSpans)return!1;const z=M.knots,R=z[D],O=z[X];if(O<=R+fe.knotTolerance)return!1;for(let Y=E-1;Y>0;Y--){let M=D-Y;if(z[M]<R){let b=X;for(let E=0;E<Y;E++,M++,b++){const D=z[M],X=(R-D)/(z[b]-D);v[E]=v[E]+X*(v[E+1]-v[E])}}}for(let Y=E-1;Y>0;Y--){let M,b=X+Y;if(z[b]>O)for(let D=0;D<Y;D++,b--){const X=z[b],Y=(O-X)/(R-X);M=E-D,v[M]+=Y*(v[M-1]-v[M])}}return!0}subdivideInPlaceKeepLeft(v){if(K.isAlmostEqualNumber(v,1))return!0;if(K.isAlmostEqualNumber(v,0))return!1;const M=1-v,b=this.order;for(let E=1;E<b;E++)for(let v=b-1;v>=E;v--)this.interpolatePoleInPlace(v,M,v-1);return!0}subdivideInPlaceKeepRight(v){if(K.isAlmostEqualNumber(v,0))return!0;if(K.isAlmostEqualNumber(v,1))return!1;const M=this.order;for(let b=1;b<M;b++)for(let E=0;E+b<M;E++)this.interpolatePoleInPlace(E,v,E+1);return!0}subdivideToIntervalInPlace(v,M){return!K.isAlmostEqualNumber(v,M)&&(M<v?(this.subdivideToIntervalInPlace(M,v),this.reverseInPlace(),!0):(this.subdivideInPlaceKeepLeft(M),this.subdivideInPlaceKeepRight(v/M),!0))}setInterval(v,M){this.interval=We.create(v,M,this.interval)}fractionToParentFraction(v){return this.interval?this.interval.fractionToPoint(v):v}}class He extends oe{constructor(v,M){super(),this.curvePrimitiveType="bezierCurve",this._polygon=new Ge(v,M),this._workPoint0=Q.create(),this._workPoint1=Q.create(),this._workData0=new Float64Array(v),this._workData1=new Float64Array(v)}reverseInPlace(){this._polygon.reverseInPlace()}saturateInPlace(v,M){const b=this._polygon.saturateInPlace(v,M);return b&&this.setInterval(v.spanFractionToFraction(M,0),v.spanFractionToFraction(M,1)),b}get degree(){return this._polygon.order-1}get order(){return this._polygon.order}get numPoles(){return this._polygon.order}setInterval(v,M){this._polygon.setInterval(v,M)}fractionToParentFraction(v){return this._polygon.fractionToParentFraction(v)}emitStrokes(v,M){const b=this.computeStrokeCountForOptions(M),E=1/b;for(let D=0;D<=b;D++){const M=D*E;this.fractionToPoint(M,this._workPoint0),v.appendStrokePoint(this._workPoint0)}}emitStrokableParts(v,M){const b=this.computeStrokeCountForOptions(M);v.announceIntervalForUniformStepStrokes(this,b,0,1)}copyPolesAsJsonArray(){return this._polygon.unpackToJsonArrays()}isInPlane(v){let M=this._workPoint0;for(let b=0;;b++){if(M=this.getPolePoint3d(b,M),!M)return!0;if(!v.isPointInPlane(M))break}return!1}polygonLength(){if(!this.getPolePoint3d(0,this._workPoint0))return 0;let v=0,M=0;for(;this.getPolePoint3d(++v,this._workPoint1);)M+=this._workPoint0.distance(this._workPoint1),this._workPoint0.setFrom(this._workPoint1);return M}startPoint(){return this.getPolePoint3d(0)}endPoint(){return this.getPolePoint3d(this.order-1)}quickLength(){return this.polygonLength()}allocateAndZeroBezierWorkData(v,M,b){v>0&&(void 0!==this._workBezier&&this._workBezier.order===v?this._workBezier.zero():this._workBezier=new Vt(v)),M>0&&(void 0!==this._workCoffsA&&this._workCoffsA.length===M?this._workCoffsA.fill(0):this._workCoffsA=new Float64Array(M)),b>0&&(void 0!==this._workCoffsB&&this._workCoffsB.length===b?this._workCoffsB.fill(0):this._workCoffsB=new Float64Array(b))}computeStrokeCountForOptions(v){this.getPolePoint3d(0,this._workPoint0),this.getPolePoint3d(1,this._workPoint1);let M=1;if(this._workPoint0&&this._workPoint1){let b,E,D,X=this._workPoint1.x-this._workPoint0.x,z=this._workPoint1.y-this._workPoint0.y,R=this._workPoint1.z-this._workPoint0.z,O=0,Y=K.hypotenuseXYZ(X,z,R);this._workPoint1.setFromPoint3d(this._workPoint0);let N,B=Y,V=Y,L=0;for(let v=2;this.getPolePoint3d(v,this._workPoint1);v++)b=this._workPoint1.x-this._workPoint0.x,E=this._workPoint1.y-this._workPoint0.y,D=this._workPoint1.z-this._workPoint0.z,N=W.radiansBetweenVectorsXYZ(X,z,R,b,E,D),O+=N,L=K.maxAbsXY(N,L),Y=K.hypotenuseXYZ(b,E,D),B+=Y,V=K.maxXY(V,Y),X=b,z=E,R=D,this._workPoint0.setFrom(this._workPoint1);const U=V*this.degree,Sr=Math.sqrt(U*B);let Cr=L*(this.degree-1);this.degree<3&&(Cr*=3);const kr=Math.sqrt(Cr*O),Fr=this.degree;M=Ie.applyAngleTol(v,Ie.applyMaxEdgeLength(v,Fr,Sr),kr,.1),v&&(M=v.applyChordTolToLengthAndRadians(M,B,Cr))}return M}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}constructOffsetXY(v){const M=Se.create(v),b=new ye(this,M.leftOffsetDistance);return this.emitStrokableParts(b,M.strokeOptions),b.claimResult()}clonePartialCurve(v,M){const b=this.clone();return b._polygon.subdivideToIntervalInPlace(v,M),b}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}}class Je extends He{isSameGeometryClass(v){return v instanceof Je}tryTransformInPlace(v){const M=this._workData0;for(let b=0;b<this._polygon.order;b++)this._polygon.getPolygonPoint(b,M),v.multiplyXYZToFloat64Array(M[0],M[1],M[2],M),this._polygon.setPolygonPoint(b,M);return!0}getPolePoint3d(v,M){const b=this._polygon.getPolygonPoint(v,this._workData0);if(b)return Q.create(b[0],b[1],b[2],M)}getPolePoint4d(v,M){const b=this._polygon.getPolygonPoint(v,this._workData0);if(b)return Dt.create(b[0],b[1],b[2],1,M)}constructor(v){super(3,v),this._workRay0=Mt.createXAxis(),this._workRay1=Mt.createXAxis()}copyPointsAsLineString(){const v=ke.create();for(let M=0;M<this._polygon.order;M++)v.addPoint(this.getPolePoint3d(M));return v}static create(v){if(v.length<1)return;const M=new Float64Array(3*v.length);if(v[0]instanceof Q){let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y,M[b++]=E.z;return new Je(M)}if(v[0]instanceof H){let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y,M[b++]=0;return new Je(M)}}static createOrder(v){const M=new Float64Array(3*v);return new Je(M)}loadSpanPoles(v,M){this._polygon.loadSpanPoles(v,M)}clone(){return new Je(this._polygon.clonePolygon())}fractionToPoint(v,M){return this._polygon.evaluate(v,this._workData0),Q.create(this._workData0[0],this._workData0[1],this._workData0[2],M)}fractionToPointAndDerivative(v,M){return this._polygon.evaluate(v,this._workData0),this._polygon.evaluateDerivative(v,this._workData1),Mt.createXYZUVW(this._workData0[0],this._workData0[1],this._workData0[2],this._workData1[0],this._workData1[1],this._workData1[2],M)}fractionToPointAnd2Derivatives(v,M){const b=1/2e-8;M||(M=bt.createXYPlane());const E=this.fractionToPointAndDerivative(v,this._workRay0);M.origin.setFrom(E.origin),M.vectorU.setFrom(E.direction);const D=this.fractionToPointAndDerivative(v-1e-8,this._workRay0),X=this.fractionToPointAndDerivative(v+1e-8,this._workRay1);return $.createAdd2Scaled(D.direction,-b,X.direction,b,M.vectorV),M}isAlmostEqual(v){return v instanceof Je&&this._polygon.isAlmostEqual(v._polygon)}dispatchToGeometryHandler(v){return v.handleBezierCurve3d(this)}extendRange(v,M){const b=this.order;if(M){this.allocateAndZeroBezierWorkData(b-1,b,0);const E=this._workBezier,D=this._workCoffsA;this.getPolePoint3d(0,this._workPoint0),v.extendTransformedPoint(M,this._workPoint0),this.getPolePoint3d(b-1,this._workPoint0),v.extendTransformedPoint(M,this._workPoint0);const X=this._polygon.packedData;for(let z=0;z<3;z++){for(let v=0,E=0;v<b;v++,E+=3)D[v]=M.multiplyComponentXYZ(z,X[E],X[E+1],X[E+2]);Bt.univariateDifference(D,E.coffs);const R=E.roots(0,!0);if(R&&R.length>0)for(const b of R)this.fractionToPoint(b,this._workPoint0),v.extendTransformedPoint(M,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(b-1,0,0);const M=this._workBezier;this.getPolePoint3d(0,this._workPoint0),v.extend(this._workPoint0),this.getPolePoint3d(b-1,this._workPoint0),v.extend(this._workPoint0);for(let E=0;E<3;E++){Bt.componentDifference(M.coffs,this._polygon.packedData,3,b,E);const D=M.roots(0,!0);if(D)for(const M of D)this.fractionToPoint(M,this._workPoint0),v.extend(this._workPoint0)}}}}class Ke extends He{isSameGeometryClass(v){return v instanceof Ke}tryTransformInPlace(v){const M=this._workData0;for(let b=0;b<this._polygon.order;b++)this._polygon.getPolygonPoint(b,M),v.multiplyXYZWToFloat64Array(M[0],M[1],M[2],M[3],M),this._polygon.setPolygonPoint(b,M);return!0}tryMultiplyMatrix4dInPlace(v){v.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData)}getPolePoint4d(v,M){const b=this._polygon.getPolygonPoint(v,this._workData0);if(b)return Dt.create(b[0],b[1],b[2],b[3],M)}getPolePoint3d(v,M){const b=this._polygon.getPolygonPoint(v,this._workData0);if(b)return Q.createFromPackedXYZW(b,0,M)}isUnitWeight(v){void 0===v&&(v=K.smallAngleRadians);const M=1-v,b=1+v,E=this._polygon.packedData,D=E.length;let X;for(let z=3;z<D;z+=4)if(X=E[z],X<M||X>b)return!1;return!0}constructor(v){super(4,v),this._workRay0=Mt.createXAxis(),this._workRay1=Mt.createXAxis()}static create(v){if(v.length<1)return;const M=new Float64Array(4*v.length);if(v[0]instanceof Q){let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y,M[b++]=E.z,M[b++]=1;return new Ke(M)}if(v[0]instanceof Dt){let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y,M[b++]=E.z,M[b++]=E.w;return new Ke(M)}if(v[0]instanceof H){let b=0;for(const E of v)M[b++]=E.x,M[b++]=E.y,M[b++]=0,M[b++]=1;return new Ke(M)}}static createOrder(v){const M=new Float64Array(4*v);return new Ke(M)}loadSpan3dPolesWithWeight(v,M,b){this._polygon.loadSpanPolesWithWeight(v,3,M,b)}loadSpan4dPoles(v,M){this._polygon.loadSpanPoles(v,M)}clone(){return new Ke(this._polygon.clonePolygon())}fractionToPoint(v,M){return this._polygon.evaluate(v,this._workData0),(M=Q.createFromPackedXYZW(this._workData0,0,M))||Q.createZero()}fractionToPoint4d(v,M){return this._polygon.evaluate(v,this._workData0),(M=Dt.createFromPacked(this._workData0,0,M))||Dt.createZero()}fractionToPointAndDerivative(v,M){return this._polygon.evaluate(v,this._workData0),this._polygon.evaluateDerivative(v,this._workData1),(M=Mt.createWeightedDerivative(this._workData0,this._workData1,M))||Mt.createXAxis()}fractionToPointAnd2Derivatives(v,M){const b=1/2e-8;M||(M=bt.createXYPlane());const E=this.fractionToPointAndDerivative(v,this._workRay0);M.origin.setFrom(E.origin),M.vectorU.setFrom(E.direction);const D=this.fractionToPointAndDerivative(v-1e-8,this._workRay0),X=this.fractionToPointAndDerivative(v+1e-8,this._workRay1);return $.createAdd2Scaled(D.direction,-b,X.direction,b,M.vectorV),M}isAlmostEqual(v){return v instanceof Ke&&this._polygon.isAlmostEqual(v._polygon)}dispatchToGeometryHandler(v){return v.handleBezierCurve3dH(this)}poleProductsXYZW(v,M,b,E,D){const X=this.numPoles,z=this._polygon.packedData;for(let R=0,O=0;R<X;R++,O+=4)v[R]=M*z[O]+b*z[O+1]+E*z[O+2]+D*z[O+3]}updateClosestPointByTruePerpendicular(v,M,b=!1,E=!1){let D,X=0;if(this.isUnitWeight()){const M=2*this.order-2;this.allocateAndZeroBezierWorkData(M,0,0);const b=this._workBezier;Bt.accumulateScaledShiftedComponentTimesComponentDelta(b.coffs,this._polygon.packedData,4,this.order,1,0,-v.x,0),Bt.accumulateScaledShiftedComponentTimesComponentDelta(b.coffs,this._polygon.packedData,4,this.order,1,1,-v.y,1),Bt.accumulateScaledShiftedComponentTimesComponentDelta(b.coffs,this._polygon.packedData,4,this.order,1,2,-v.z,2),D=b.roots(0,!0)}else{const M=this.order,b=2*this.order-2,E=M+b-1;this.allocateAndZeroBezierWorkData(E,M,b);const X=this._workBezier,z=this._workCoffsA,R=this._workCoffsB,O=this._polygon.packedData;for(let D=0;D<3;D++){for(let v=0;v<z.length;v++)z[v]=0;for(let v=0;v<R.length;v++)R[v]=0;Bt.scaledComponentSum(z,O,4,M,3,v.at(D),D,-1),Bt.accumulateScaledShiftedComponentTimesComponentDelta(R,O,4,M,1,3,0,D),Bt.accumulateScaledShiftedComponentTimesComponentDelta(R,O,4,M,-1,D,0,3),Bt.accumulateProduct(X.coffs,z,R)}D=X.roots(0,!0)}if(D)for(const z of D){const b=this.fractionToPoint(z),E=b.distance(v);X+=M.updateIfCloserCurveFractionPointDistance(this,z,b,E)?1:0}return b&&(X+=this.updateDetailAtFraction(M,0,v)?1:0),E&&(X+=this.updateDetailAtFraction(M,1,v)?1:0),X>0}updateDetailAtFraction(v,M,b){const E=this.fractionToPoint(M),D=E.distance(b);return v.updateIfCloserCurveFractionPointDistance(this,M,E,D)}extendRange(v,M){const b=this.order;if(M){this.allocateAndZeroBezierWorkData(2*b-2,b,b);const E=this._workCoffsA,D=this._workCoffsB,X=this._workBezier;this.getPolePoint3d(0,this._workPoint0),v.extendTransformedPoint(M,this._workPoint0),this.getPolePoint3d(b-1,this._workPoint0),v.extendTransformedPoint(M,this._workPoint0);const z=this._polygon.packedData;let R;for(let O=0;O<3;O++){X.zero();for(let v=0,X=0;v<b;v++,X+=4)R=z[X+3],E[v]=M.multiplyComponentXYZW(O,z[X],z[X+1],z[X+2],R),D[v]=R;Bt.accumulateProductWithDifferences(X.coffs,E,D,1),Bt.accumulateProductWithDifferences(X.coffs,D,E,-1);const Y=X.roots(0,!0);if(Y&&Y.length>0)for(const b of Y)this.fractionToPoint(b,this._workPoint0),v.extendTransformedPoint(M,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(2*b-2,0,0);const M=this._workBezier,E=this._polygon.packedData;this.getPolePoint3d(0,this._workPoint0),v.extend(this._workPoint0),this.getPolePoint3d(b-1,this._workPoint0),v.extend(this._workPoint0);for(let D=0;D<3;D++){M.zero(),Bt.accumulateScaledShiftedComponentTimesComponentDelta(M.coffs,E,4,b,1,D,0,3),Bt.accumulateScaledShiftedComponentTimesComponentDelta(M.coffs,E,4,b,-1,3,0,D);const X=M.roots(0,!0);if(X)for(const M of X)this.fractionToPoint(M,this._workPoint0),v.extend(this._workPoint0)}}}}class je{get degree(){return this.knots.degree}get order(){return this.knots.degree+1}get numSpan(){return this.numPoles-this.knots.degree}get numPoles(){return this.packedData.length/this.poleLength}getPoint3dPole(v,M){return Q.createFromPacked(this.packedData,v,M)}constructor(v,M,b,E){this.knots=E,this.packedData=new Float64Array(v*M),this.poleLength=M,this.basisBuffer=new Float64Array(b),this.poleBuffer=new Float64Array(M),this.basisBuffer1=new Float64Array(b),this.basisBuffer2=new Float64Array(b),this.poleBuffer1=new Float64Array(M),this.poleBuffer2=new Float64Array(M)}static create(v,M,b,E){return new je(v,M,b,E)}spanFractionToKnot(v,M){return this.knots.spanFractionToKnot(v,M)}evaluateBasisFunctionsInSpan(v,M,b,E,D){v<0&&(v=0),v>=this.numSpan&&(v=this.numSpan-1);const X=v+this.degree-1,z=this.knots.baseKnotFractionToKnot(X,M);return E?this.knots.evaluateBasisFunctions1(X,z,b,E,D):this.knots.evaluateBasisFunctions(X,z,b)}evaluateBuffersInSpan(v,M){this.evaluateBasisFunctionsInSpan(v,M,this.basisBuffer),this.sumPoleBufferForSpan(v)}evaluateBuffersInSpan1(v,M){this.evaluateBasisFunctionsInSpan(v,M,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(v),this.sumPoleBuffer1ForSpan(v)}sumPoleBufferForSpan(v){this.poleBuffer.fill(0);let M=v*this.poleLength;for(const b of this.basisBuffer)for(let v=0;v<this.poleLength;v++)this.poleBuffer[v]+=b*this.packedData[M++]}sumPoleBuffer1ForSpan(v){this.poleBuffer1.fill(0);let M=v*this.poleLength;for(const b of this.basisBuffer1)for(let v=0;v<this.poleLength;v++)this.poleBuffer1[v]+=b*this.packedData[M++]}sumPoleBuffer2ForSpan(v){this.poleBuffer2.fill(0);let M=v*this.poleLength;for(const b of this.basisBuffer2)for(let v=0;v<this.poleLength;v++)this.poleBuffer2[v]+=b*this.packedData[M++]}evaluateBuffersAtKnot(v,M=0){const b=this.knots.knotToLeftKnotIndex(v);M<1?(this.knots.evaluateBasisFunctions(b,v,this.basisBuffer),this.sumPoleBufferForSpan(b-this.degree+1)):1===M?(this.knots.evaluateBasisFunctions1(b,v,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(b-this.degree+1),this.sumPoleBuffer1ForSpan(b-this.degree+1)):(this.knots.evaluateBasisFunctions1(b,v,this.basisBuffer,this.basisBuffer1,this.basisBuffer2),this.sumPoleBufferForSpan(b-this.degree+1),this.sumPoleBuffer1ForSpan(b-this.degree+1),this.sumPoleBuffer2ForSpan(b-this.degree+1))}reverseInPlace(){const v=this.poleLength,M=this.packedData;for(let b=0,E=v*(this.numPoles-1);b<E;b+=v,E-=v){let D=0;for(let X=0;X<v;X++)D=M[b+X],M[b+X]=M[E+X],M[E+X]=D}this.knots.reflectKnots()}testCloseablePolygon(v){return this.testClosablePolygon(v)}testClosablePolygon(v){void 0===v&&(v=this.knots.wrappable);let M=0;if(v===kr.OpenByAddingControlPoints)M=this.degree;else{if(v!==kr.OpenByRemovingKnots)return!1;M=1}const b=this.poleLength,E=(this.numPoles-M)*b,D=M*b;for(let X=0;X<D;X++)if(!K.isSameCoordinate(this.packedData[X],this.packedData[X+E]))return!1;return!0}addKnot(v,M){if(v<this.knots.leftKnot||v>this.knots.rightKnot)return!1;let b=this.knots.knotToLeftKnotIndex(v);if(Math.abs(v-this.knots.knots[b])<fe.knotTolerance)v=this.knots.knots[b];else if(Math.abs(v-this.knots.knots[b+1])<fe.knotTolerance){if(b+=this.knots.getKnotMultiplicityAtIndex(b+1),b>this.knots.rightKnotIndex)return!0;v=this.knots.knots[b]}const E=Math.min(M,this.degree)-this.knots.getKnotMultiplicity(v);if(E<=0)return!0;let D=this.knots.knots.length;const X=new Float64Array(D+E);for(let Y=0;Y<D;++Y)X[Y]=this.knots.knots[Y];let z=this.numPoles;const R=new Float64Array(this.packedData.length+E*this.poleLength);for(let Y=0;Y<this.packedData.length;++Y)R[Y]=this.packedData[Y];const O=new Float64Array(this.degree*this.poleLength);for(let Y=0;Y<E;++Y){let M=0;const E=b-this.degree+2;for(let b=E;b<E+this.degree;++b){const E=(v-X[b-1])/(X[b+this.degree-1]-X[b-1]);for(let v=b*this.poleLength;v<(b+1)*this.poleLength;++v)O[M++]=K.interpolate(R[v-this.poleLength],E,R[v])}R.copyWithin((E+this.degree)*this.poleLength,(E+this.degree-1)*this.poleLength,z*this.poleLength);let Y=E*this.poleLength;for(const v of O)R[Y++]=v;X.copyWithin(b+2,b+1,D),X[b+1]=v,++b,++D,++z}return this.knots.setKnotsCapture(X),this.packedData=R,!0}}class Qe extends oe{set definitionData(v){this._definitionData=v}get definitionData(){return this._definitionData}constructor(v,M,b,E){super(),this.curvePrimitiveType="bsplineCurve",this._bcurve=je.create(M,v,b,E)}get degree(){return this._bcurve.degree}get order(){return this._bcurve.order}get numSpan(){return this._bcurve.numSpan}get numPoles(){return this._bcurve.numPoles}get polesRef(){return this._bcurve.packedData}get knotsRef(){return this._bcurve.knots.knots}get poleDimension(){return this._bcurve.poleLength}copyKnots(v){return this._bcurve.knots.copyKnots(v)}getWrappable(){return this._bcurve.knots.wrappable}setWrappable(v){this._bcurve.knots.wrappable=v}get isClosableCurve(){const v=this._bcurve.knots.wrappable;return v===kr.None?kr.None:this._bcurve.knots.testClosable(v)&&this._bcurve.testClosablePolygon(v)?v:kr.None}fractionToPoint(v,M){return this.knotToPoint(this._bcurve.knots.fractionToKnot(v),M)}fractionToPointAndDerivative(v,M){const b=this._bcurve.knots.fractionToKnot(v);return(M=this.knotToPointAndDerivative(b,M)).direction.scaleInPlace(this._bcurve.knots.knotLength01),M}fractionToPointAnd2Derivatives(v,M){const b=this._bcurve.knots.fractionToKnot(v);M=this.knotToPointAnd2Derivatives(b,M);const E=this._bcurve.knots.knotLength01;return M.vectorU.scaleInPlace(E),M.vectorV.scaleInPlace(E*E),M}startPoint(){return this.evaluatePointInSpan(0,0)}endPoint(){return this.evaluatePointInSpan(this.numSpan-1,1)}reverseInPlace(){this._bcurve.reverseInPlace()}collectBezierSpans(v){const M=[],b=this.numSpan;for(let E=0;E<b;E++)if(this._bcurve.knots.isIndexOfRealSpan(E)){const b=this.getSaturatedBezierSpan3dOr3dH(E,v);b&&M.push(b)}return M}poleIndexToDataIndex(v){if(v>=0&&v<this.numPoles)return v*this._bcurve.poleLength}closestPoint(v,M){const b=this.fractionToPoint(0),E=vt.createCurveFractionPointDistance(this,0,b,b.distance(v));let D;const X=this.numSpan;for(let z=0;z<X;z++)this._bcurve.knots.isIndexOfRealSpan(z)&&(D=this.getSaturatedBezierSpan3dOr3dH(z,!0,D),D&&D.updateClosestPointByTruePerpendicular(v,E,!1,!0)&&(E.curve=this,E.fraction=D.fractionToParentFraction(E.fraction)));return E}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}clonePartialCurve(v,M){const b=this.clone(),E=b._bcurve.knots.knots.length;let D=b._bcurve.knots.fractionToKnot(v),X=b._bcurve.knots.fractionToKnot(M);if(b._bcurve.addKnot(D,b.degree),b._bcurve.addKnot(X,b.degree),E===b._bcurve.knots.knots.length)return b;if(D>X){const v=D;D=X,X=v}const z=b._bcurve.knots.knotToLeftKnotIndex(D)-b.degree+1,R=z*b._bcurve.poleLength,O=b._bcurve.knots.knotToLeftKnotIndex(X);let Y=O-b._bcurve.knots.getKnotMultiplicityAtIndex(O)+1;b._bcurve.knots.knots[O]<X&&(Y=O+1);const N=(Y+1)*b._bcurve.poleLength,B=Y+b.degree;return b._bcurve.knots.setKnotsCapture(b._bcurve.knots.knots.slice(z,B)),b._bcurve.packedData=b._bcurve.packedData.slice(R,N),b.setWrappable(kr.None),b}appendPlaneIntersectionPoints(v,M){const b=this.numPoles,E=this.order,D=new Float64Array(b),X=this.numSpan,z=Dt.create(),R=ft.createNull();for(let B=0;B<b;B++)D[B]=v.weightedAltitude(this.getPolePoint4d(B,z)),R.extendX(D[B]);let O,Y=0,N=-1e3;if(R.containsX(0))for(let B=0;B<X;B++)if(this._bcurve.knots.isIndexOfRealSpan(B)&&(R.setNull(),R.extendArraySubset(D,B,E),R.containsX(0))){O=Vt.createArraySubset(D,B,E,O),Ge.saturate1dInPlace(O.coffs,this._bcurve.knots,B);const v=O.roots(0,!0);if(v)for(const b of v){Y++;const v=this._bcurve.knots.spanFractionToFraction(B,b);if(!K.isAlmostEqualNumber(v,N)){const b=vt.createCurveEvaluatedFraction(this,v);b.intervalRole=L.isolated,M.push(b),N=v}}}return Y}constructOffsetXY(v){const M=Se.create(v),b=new ye(this,M.leftOffsetDistance);return this.emitStrokableParts(b,M.strokeOptions),b.claimResult()}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}}class $e extends Qe{initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=Je.createOrder(this.order)),this._workBezier}isSameGeometryClass(v){return v instanceof $e}tryTransformInPlace(v){return de.multiplyInPlace(v,this._bcurve.packedData),!0}getPolePoint3d(v,M){const b=this.poleIndexToDataIndex(v);if(void 0!==b){const v=this._bcurve.packedData;return Q.create(v[b],v[b+1],v[b+2],M)}}getPolePoint4d(v,M){const b=this.poleIndexToDataIndex(v);if(void 0!==b){const v=this._bcurve.packedData;return Dt.create(v[b],v[b+1],v[b+2],1,M)}}spanFractionToKnot(v,M){return this._bcurve.spanFractionToKnot(v,M)}constructor(v,M,b){super(3,v,M,b)}copyPoints(){return de.unpackNumbersToNestedArrays(this._bcurve.packedData,3)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}copyKnots(v){return this._bcurve.knots.copyKnots(v)}static createUniformKnots(v,M){const b=v instanceof Float64Array?v.length/3:v.length;if(M<2||b<M)return;const E=fe.createUniformClamped(b,M-1,0,1),D=new $e(b,M,E);if(v instanceof Float64Array)for(let X=0;X<3*b;X++)D._bcurve.packedData[X]=v[X];else if(v instanceof nt)D._bcurve.packedData=v.float64Data().slice(0,3*b);else{let M=0;for(const b of v)D._bcurve.packedData[M++]=b.x,D._bcurve.packedData[M++]=b.y,D._bcurve.packedData[M++]=b.z}return D}static createPeriodicUniformKnots(v,M){if(M<2)return;let b=v instanceof Float64Array?v.length/3:v.length;if(b<2)return;const E=Q.createZero(),D=Q.createZero();let X=!1;do{v instanceof Float64Array?(E.set(v[0],v[1],v[2]),D.set(v[3*b-3],v[3*b-2],v[3*b-1])):v instanceof nt?(v.getPoint3dAtUncheckedPointIndex(0,E),v.getPoint3dAtUncheckedPointIndex(b-1,D)):(E.setFromPoint3d(v[0]),D.setFromPoint3d(v[b-1])),(X=E.isAlmostEqual(D))&&--b}while(X&&b>1);if(b<M)return;const z=M-1,R=b,O=fe.createUniformWrapped(R,z,0,1);O.wrappable=kr.OpenByAddingControlPoints;const Y=new $e(b+z,M,O);if(v instanceof Float64Array){let M=0;for(let E=0;E<3*b;E++)Y._bcurve.packedData[M++]=v[E];for(let b=0;b<3*z;b++)Y._bcurve.packedData[M++]=v[b]}else if(v instanceof nt){let M=0;for(let E=0;E<3*b;E++)Y._bcurve.packedData[M++]=v.float64Data()[E];for(let b=0;b<3*z;b++)Y._bcurve.packedData[M++]=v.float64Data()[b]}else{let M=0;for(let E=0;E<b;E++)Y._bcurve.packedData[M++]=v[E].x,Y._bcurve.packedData[M++]=v[E].y,Y._bcurve.packedData[M++]=v[E].z;for(let b=0;b<z;b++)Y._bcurve.packedData[M++]=v[b].x,Y._bcurve.packedData[M++]=v[b].y,Y._bcurve.packedData[M++]=v[b].z}return Y}static createFromInterpolationCurve3dOptions(v){return ge.createThroughPointsC2Cubic(v)}static createFromAkimaCurve3dOptions(v){return ge.createThroughPoints(v.fitPoints,4)}static create(v,M,b){if(b<2)return;let E=v.length;if(v instanceof Float64Array&&(E=Math.floor(E/3)),E<b)return;const D=M.length,X=E+b===D;if(!X&&E+b!==D+2)return;const z=fe.create(M,b-1,X),R=new $e(E,b,z);let O=0;if(v instanceof Float64Array)for(const Y of v)R._bcurve.packedData[O++]=Y;else if(v[0]instanceof Q)for(const Y of v)R._bcurve.packedData[O++]=Y.x,R._bcurve.packedData[O++]=Y.y,R._bcurve.packedData[O++]=Y.z;else{if(!Array.isArray(v[0])||3!==v[0].length)return;for(const M of v)for(const v of M)R._bcurve.packedData[O++]=v}return R}clone(){const v=this._bcurve.knots.clone(),M=new $e(this.numPoles,this.order,v);return M._bcurve.packedData=this._bcurve.packedData.slice(),M}evaluatePointInSpan(v,M){return this._bcurve.evaluateBuffersInSpan(v,M),Q.createFrom(this._bcurve.poleBuffer)}evaluatePointAndDerivativeInSpan(v,M){return this._bcurve.evaluateBuffersInSpan1(v,M),Mt.createCapture(Q.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPoint(v,M){return this._bcurve.evaluateBuffersAtKnot(v),Q.createFrom(this._bcurve.poleBuffer,M)}knotToPointAndDerivative(v,M){return this._bcurve.evaluateBuffersAtKnot(v,1),M?(M.origin.setFrom(this._bcurve.poleBuffer),M.direction.setFrom(this._bcurve.poleBuffer1),M):Mt.createCapture(Q.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPointAnd2Derivatives(v,M){return this._bcurve.evaluateBuffersAtKnot(v,2),bt.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0],this._bcurve.poleBuffer[1],this._bcurve.poleBuffer[2],this._bcurve.poleBuffer1[0],this._bcurve.poleBuffer1[1],this._bcurve.poleBuffer1[2],this._bcurve.poleBuffer2[0],this._bcurve.poleBuffer2[1],this._bcurve.poleBuffer2[2],M)}isAlmostEqual(v){return v instanceof $e&&this._bcurve.knots.isAlmostEqual(v._bcurve.knots)&&de.isAlmostEqual(this._bcurve.packedData,v._bcurve.packedData)}isInPlane(v){return de.isCloseToPlane(this._bcurve.packedData,v)}quickLength(){return de.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(v,M){const b=void 0!==v.announceBezierCurve,E=this.initializeWorkBezier(),D=this.numSpan;let X;for(let z=0;z<D;z++){const D=this.getSaturatedBezierSpan3dOr3dH(z,!1,E);D&&(X=D.computeStrokeCountForOptions(M),b?v.announceBezierCurve(D,X,this,z,this._bcurve.knots.spanFractionToFraction(z,0),this._bcurve.knots.spanFractionToFraction(z,1)):v.announceIntervalForUniformStepStrokes(this,X,this._bcurve.knots.spanFractionToFraction(z,0),this._bcurve.knots.spanFractionToFraction(z,1)))}}computeStrokeCountForOptions(v){const M=this.initializeWorkBezier(),b=this.numSpan;let E=0;for(let D=0;D<b;D++){const b=this.getSaturatedBezierSpan3d(D,M);b&&(E+=b.computeStrokeCountForOptions(v))}return E}computeAndAttachRecursiveStrokeCounts(v,M){const b=this.initializeWorkBezier(),E=this.numSpan,D=zt.createWithCurvePrimitiveAndOptionalParent(this,M,[]);for(let X=0;X<E;X++)if(this.getSaturatedBezierSpan3d(X,b)){const M=b.curveLength(),E=b.computeStrokeCountForOptions(v);D.addToCountAndLength(E,M)}oe.installStrokeCountMap(this,D,M)}emitStrokes(v,M){const b=this.initializeWorkBezier(),E=this.numSpan;for(let D=0;D<E;D++){const E=this.getSaturatedBezierSpan3d(D,b);E&&E.emitStrokes(v,M)}}get isClosable(){return this.isClosableCurve}getSaturatedBezierSpan3dOr3dH(v,M,b){return M?this.getSaturatedBezierSpan3dH(v,b):this.getSaturatedBezierSpan3d(v,b)}getSaturatedBezierSpan3d(v,M){if(v<0||v>=this.numSpan)return;const b=this.order;void 0!==M&&M instanceof Je&&M.order===b||(M=Je.createOrder(b));const E=M;return E.loadSpanPoles(this._bcurve.packedData,v),E.saturateInPlace(this._bcurve.knots,v)?M:void 0}getSaturatedBezierSpan3dH(v,M){if(v<0||v>=this.numSpan)return;const b=this.order;void 0!==M&&M instanceof Ke&&M.order===b||(M=Ke.createOrder(b));const E=M;return E.loadSpan3dPolesWithWeight(this._bcurve.packedData,v,1),E.saturateInPlace(this._bcurve.knots,v)?E:void 0}dispatchToGeometryHandler(v){return v.handleBSplineCurve3d(this)}extendRange(v,M){const b=this._bcurve.packedData,E=b.length-2;if(M)for(let D=0;D<E;D+=3)v.extendTransformedXYZ(M,b[D],b[D+1],b[D+2]);else for(let D=0;D<E;D+=3)v.extendXYZ(b[D],b[D+1],b[D+2])}}class ti extends oe{isSameGeometryClass(v){return v instanceof ti}get center(){return this._center.clone()}get vector0(){return this._matrix.columnX()}get vector90(){return this._matrix.columnY()}get perpendicularVector(){return this._matrix.columnZ()}matrixClone(){return this._matrix.clone()}get matrixRef(){return this._matrix}get sweep(){return this._sweep}set sweep(v){this._sweep.setFrom(v)}get isExtensibleFractionSpace(){return!0}constructor(v,M,b){super(),this.curvePrimitiveType="arc",this._center=v,this._matrix=M,this._sweep=b}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}setRefs(v,M,b){this._center=v,this._matrix=M,this._sweep=b}set(v,M,b){this.setRefs(v.clone(),M.clone(),b?b.clone():It.create360())}setFrom(v){this._center.setFrom(v._center),this._matrix.setFrom(v._matrix),this._sweep.setFrom(v._sweep)}clone(){return new ti(this._center.clone(),this._matrix.clone(),this._sweep.clone())}static createRefs(v,M,b,E){return E?(E.setRefs(v,M,b),E):new ti(v,M,b)}static createScaledXYColumns(v,M,b,E,D,X){const z=M.columnX(),R=M.columnY();return ti.create(v,z.scale(b,z),R.scale(E,R),D,X)}static createCenterNormalRadius(v,M,b,E){const D=xt.createRigidHeadsUp(M);return ti.createScaledXYColumns(v,D,b,b,void 0,E)}static create(v,M,b,E,D){const X=M.unitCrossProductWithDefault(b,0,0,0),z=xt.createColumns(M,b,X);return ti.createRefs(void 0!==v?v.clone():Q.create(0,0,0),z,E?E.clone():It.create360(),D)}cloneAtZ(v){return void 0===v&&(v=this._center.z),ti.createXYZXYZXYZ(this._center.x,this._center.y,this._center.z,this._matrix.coffs[0],this._matrix.coffs[3],0,this._matrix.coffs[1],this._matrix.coffs[4],0,this._sweep)}static createXYZXYZXYZ(v,M,b,E,D,X,z,R,O,Y,N){return ti.create(Q.create(v,M,b),$.create(E,D,X),$.create(z,R,O),Y,N)}quickEccentricity(){const v=this._matrix.columnXMagnitude(),M=this._matrix.columnYMagnitude(),b=this._matrix.columnXYCrossProductMagnitude(),E=K.maxXY(v,M);return b/(E*E)}static createCircularStartMiddleEnd(v,M,b,E){const D=$.createStartEnd(v,M),X=$.createStartEnd(v,b),z=D.magnitudeSquared(),R=X.magnitudeSquared(),O=D.sizedCrossProduct(X,Math.sqrt(Math.sqrt(z*R)));if(O){const M=Ft.linearSystem3d(O.x,O.y,O.z,D.x,D.y,D.z,X.x,X.y,X.z,0,.5*z,.5*R);if(M){const D=Q.create(v.x,v.y,v.z).plus(M),X=$.createStartEnd(D,v),z=$.createRotateVectorAroundVector(X,O,W.createDegrees(90));if(z){const v=$.createStartEnd(D,b),M=X.signedAngleTo(v,O);return M.radians<0&&M.addMultipleOf2PiInPlace(1),ti.create(D,X,z,It.createStartEndRadians(0,M.radians),E)}}}return ke.create(v,M,b)}getFractionToDistanceScale(){const v=this.circularRadius();if(void 0!==v)return Math.abs(v*this._sweep.sweepRadians)}fractionToPoint(v,M){const b=this._sweep.fractionToRadians(v);return this._matrix.originPlusMatrixTimesXY(this._center,Math.cos(b),Math.sin(b),M)}fractionAndRadialFractionToPoint(v,M,b){const E=this._sweep.fractionToRadians(v);return this._matrix.originPlusMatrixTimesXY(this._center,M*Math.cos(E),M*Math.sin(E),b)}fractionToPointAndDerivative(v,M){return(M=this.radiansToPointAndDerivative(this._sweep.fractionToRadians(v),M)).direction.scaleInPlace(this._sweep.sweepRadians),M}fractionToPointAnd2Derivatives(v,M){const b=this._sweep.fractionToRadians(v);M||(M=bt.createXYPlane());const E=Math.cos(b),D=Math.sin(b);this._matrix.originPlusMatrixTimesXY(this._center,E,D,M.origin);const X=this._sweep.sweepRadians;this._matrix.multiplyXY(-X*D,X*E,M.vectorU);const z=X*X;return this._matrix.multiplyXY(-z*E,-z*D,M.vectorV),M}radiansToPointAndDerivative(v,M){M=M||Mt.createZero();const b=Math.cos(v),E=Math.sin(v);return this._matrix.originPlusMatrixTimesXY(this._center,b,E,M.origin),this._matrix.multiplyXY(-E,b,M.direction),M}radiansToPoint(v,M){M=M||Q.create();const b=Math.cos(v),E=Math.sin(v);return this._matrix.originPlusMatrixTimesXY(this._center,b,E,M),M}radiansToRotatedBasis(v,M){M=M||bt.createXYPlane();const b=Math.cos(v),E=Math.sin(v);return M.origin.setFromPoint3d(this.center),this._matrix.multiplyXY(b,E,M.vectorU),this._matrix.multiplyXY(-E,b,M.vectorV),M}angleToPointAndDerivative(v,M){M=M||Mt.createZero();const b=v.cos(),E=v.sin();return this._matrix.originPlusMatrixTimesXY(this._center,b,E,M.origin),this._matrix.multiplyXY(-E,b,M.direction),M}startPoint(v){return this.fractionToPoint(0,v)}endPoint(v){return this.fractionToPoint(1,v)}curveLength(){return this.curveLengthBetweenFractions(0,1)}curveLengthBetweenFractions(v,M){const b=this.getFractionToDistanceScale();if(void 0!==b)return b*Math.abs(M-v);let E=v,D=M;v>M&&(E=M,D=v);const X=(D-E)*this._sweep.sweepDegrees;let z=this.quickEccentricity();z<1e-5&&(z=1e-5);let R=Math.ceil(X/(z*ti.quadratureIntervalAngleDegrees));return R>400&&(R=400),R<1&&(R=1),super.curveLengthWithFixedIntervalCountQuadrature(E,D,R,ti.quadratureGuassCount)}quickLength(){const v=Math.abs(this._sweep.sweepRadians);let M=Math.ceil(4*v/Math.PI);M<1&&(M=1),M<4?M+=3:M<6&&(M+=2);const b=ti._workPointA,E=ti._workPointB;let D=0;this.fractionToPoint(0,b);for(let z=1;z<=M;z++)this.fractionToPoint(z/M,E),D+=b.distance(E),b.setFromPoint3d(E);const X=v/M;return D*(X/(2*Math.sin(.5*X)))}moveSignedDistanceFromFraction(v,M,b,E){if(!this.isCircular)return super.moveSignedDistanceFromFractionGeneric(v,M,b,E);const D=this.curveLength(),X=K.conditionalDivideFraction(M,D);return void 0===X?vt.createCurveFractionPointDistanceCurveSearchStatus(this,v,this.fractionToPoint(v),0,U.error):vt.createConditionalMoveSignedDistance(b,this,v,v+X,M,E)}allPerpendicularAngles(v,M=!0,b=!1){const E=[],D=v.vectorTo(this.center),X=this._matrix.columnXMagnitudeSquared(),z=this._matrix.columnXDotColumnY(),R=this._matrix.columnYMagnitudeSquared();return Tt.solveUnitCircleImplicitQuadricIntersection(z,R-X,-z,this._matrix.dotColumnY(D),-this._matrix.dotColumnX(D),0,E),b&&(E.push(this.sweep.startRadians),E.push(this.sweep.endRadians)),E}closestPoint(v,M,b){b=vt.create(this,b);const E=this.allPerpendicularAngles(v,!0,!0);let D=ee.resolveVariantCurveExtendParameterToCurveExtendMode(M,0),X=ee.resolveVariantCurveExtendParameterToCurveExtendMode(M,1);this._sweep.isFullCircle&&(D=Cr.None,X=Cr.None),D!==Cr.None&&X!==Cr.None&&(E.push(this._sweep.startRadians),E.push(this._sweep.endRadians));const z=Mt.createZero();if(0===E.length)b.setFR(0,this.radiansToPointAndDerivative(this._sweep.startRadians,z)),b.a=v.distance(b.point);else{let D=Number.MAX_VALUE,X=0;for(const R of E){const E=ee.resolveRadiansToSweepFraction(M,R,this.sweep);void 0!==E&&(this.fractionToPointAndDerivative(E,z),X=v.distance(z.origin),X<D&&(D=X,b.setFR(E,z),b.a=X))}}return b}reverseInPlace(){this._sweep.reverseInPlace()}tryTransformInPlace(v){return this._center=v.multiplyPoint3d(this._center,this._center),this._matrix=v.matrix.multiplyMatrixMatrix(this._matrix,this._matrix),this.setVector0Vector90(this._matrix.columnX(),this._matrix.columnY()),!0}isInPlane(v){const M=v.getNormalRef();return K.isSmallMetricDistance(v.altitude(this._center))&&K.isSmallMetricDistance(this._matrix.dotColumnX(M))&&K.isSmallMetricDistance(this._matrix.dotColumnY(M))}get isCircular(){const v=this._matrix.columnXMagnitudeSquared(),M=this._matrix.columnYMagnitudeSquared(),b=this._matrix.columnXDotColumnY();return W.isPerpendicularDotSet(v,M,b)&&K.isSameCoordinateSquared(v,M)}circularRadiusXY(){const v=this._matrix.at(0,0),M=this._matrix.at(1,0),b=this._matrix.at(0,1),E=this._matrix.at(1,1),D=K.dotProductXYXY(v,M,v,M),X=K.dotProductXYXY(b,E,b,E),z=K.dotProductXYXY(v,M,b,E);if(W.isPerpendicularDotSet(D,X,z)&&K.isSameCoordinateSquared(D,X))return K.hypotenuseXY(v,M)}circularRadius(){return this.isCircular?this._matrix.columnXMagnitude():void 0}maxVectorLength(){return Math.max(this._matrix.columnXMagnitude(),this._matrix.columnYMagnitude())}appendPlaneIntersectionPoints(v,M){const b=v.altitude(this._center),E=this._matrix.coffs,D=v.velocityXYZ(E[0],E[3],E[6]),X=v.velocityXYZ(E[1],E[4],E[7]),z=K.solveTrigForm(b,D,X);let R=0;if(void 0!==z){let v;for(v of(R=z.length,z)){const b=Math.atan2(v.y,v.x),E=this._sweep.radiansToPositivePeriodicFraction(b),D=vt.createCurveFractionPoint(this,E,this.fractionToPoint(E));D.intervalRole=L.isolated,(W.isAlmostEqualRadiansAllowPeriodShift(b,this._sweep.startRadians)||W.isAlmostEqualRadiansAllowPeriodShift(b,this._sweep.endRadians))&&(D.intervalRole=L.isolatedAtVertex),M.push(D)}}return R}extendRange(v,M){this.extendRangeInSweep(v,this._sweep,M)}extendRangeInSweep(v,M,b){const E=new kt(0,0,0),D=this._center.clone(ti._workPointA),X=this._matrix.columnX(ti._workVectorU),z=this._matrix.columnY(ti._workVectorV);b&&(b.multiplyPoint3d(D,D),b.multiplyVector(X,X),b.multiplyVector(z,z));const R=ti._workPointB,O=ti._workPointC,Y=ft.createNull();for(let N=0;N<3;N++)E.set(D.at(N),X.at(N),z.at(N)),E.rangeInSweep(M,Y),R.setAt(N,Y.low),O.setAt(N,Y.high);v.extend(R),v.extend(O)}rangeBetweenFractions(v,M,b){const E=It.createStartEndRadians(this.sweep.fractionToRadians(v),this.sweep.fractionToRadians(M)),D=ut.create();return this.extendRangeInSweep(D,E,b),D}getPlaneAltitudeSineCosinePolynomial(v,M){return M||(M=new kt(0,0,0)),M.set(v.altitude(this._center),v.velocityXYZ(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[6]),v.velocityXYZ(this._matrix.coffs[1],this._matrix.coffs[4],this._matrix.coffs[7])),M}static createUnitCircle(){return ti.createRefs(Q.create(0,0,0),xt.createIdentity(),It.create360())}static createXY(v,M,b=It.create360()){return new ti(v.clone(),xt.createScale(M,M,1),b)}static createXYEllipse(v,M,b,E=It.create360()){return new ti(v.clone(),xt.createScale(M,b,1),E)}setVector0Vector90(v,M){this._matrix.setColumns(v,M,v.unitCrossProductWithDefault(M,0,0,0))}toScaledMatrix3d(){const v=W.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(),this._matrix.columnYMagnitudeSquared(),this._matrix.columnXDotColumnY(),!0),M=this._matrix.multiplyXY(v.c,v.s),b=this._matrix.multiplyXY(-v.s,v.c);return{axes:xt.createRigidFromColumns(M,b,z.XYZ)||xt.createIdentity(),center:this._center,r0:M.magnitude(),r90:b.magnitude(),sweep:this.sweep.cloneMinusRadians(v.radians)}}toVectors(){return{center:this.center,vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedVectors(v){return v?{center:v.multiplyPoint3d(this._center),vector0:v.multiplyVector(this._matrix.columnX()),vector90:v.multiplyVector(this._matrix.columnY()),sweep:this.sweep}:{center:this._center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedPoint4d(v){return{center:v.multiplyPoint3d(this._center,1),vector0:v.multiplyPoint3d(this._matrix.columnX(),0),vector90:v.multiplyPoint3d(this._matrix.columnY(),0),sweep:this.sweep}}setFromJSON(v){if(v&&v.center&&v.vector0&&v.vector90&&v.sweep){this._center.setFromJSON(v.center);const M=$.create(),b=$.create();M.setFromJSON(v.vector0),b.setFromJSON(v.vector90),this.setVector0Vector90(M,b),this._sweep.setFromJSON(v.sweep)}else this._center.set(0,0,0),this._matrix.setFrom(xt.identity),this._sweep.setStartEndRadians()}toJSON(){return{center:this._center.toJSON(),sweep:this._sweep.toJSON(),vector0:this._matrix.columnX().toJSON(),vector90:this._matrix.columnY().toJSON()}}isAlmostEqual(v){if(v instanceof ti){const M=v;return this._center.isAlmostEqual(M._center)&&this._matrix.isAlmostEqual(M._matrix)&&this._sweep.isAlmostEqualAllowPeriodShift(M._sweep)}return!1}emitStrokes(v,M){const b=this.computeStrokeCountForOptions(M);v.appendFractionalStrokePoints(this,b,0,1,!0)}emitStrokableParts(v,M){const b=this.computeStrokeCountForOptions(M);v.startCurvePrimitive(this),v.announceIntervalForUniformStepStrokes(this,b,0,1),v.endCurvePrimitive(this)}computeStrokeCountForOptions(v){let M;if(v){const b=this.maxVectorLength();M=v.applyTolerancesToArc(b,this._sweep.sweepRadians)}else M=Ie.applyAngleTol(void 0,1,this._sweep.sweepRadians);return M}dispatchToGeometryHandler(v){return v.handleArc3d(this)}clonePartialCurve(v,M){if(M<v){const b=this.clonePartialCurve(M,v);return b.reverseInPlace(),b}const b=this.clone();return b.sweep.setStartEndRadians(this.sweep.fractionToRadians(v),this.sweep.fractionToRadians(M)),b}cloneInRotatedBasis(v){const M=v.cos(),b=v.sin(),E=this._matrix.multiplyXY(M,b),D=this._matrix.multiplyXY(-b,M),X=It.createStartEndRadians(this._sweep.startRadians-v.radians,this._sweep.endRadians-v.radians);return ti.create(this._center.clone(),E,D,X)}announceClipIntervals(v,M){return v.announceClippedArcIntervals(this,M)}otherArcAsLocalVectors(v){const M=this._matrix.multiplyInverseXYZAsPoint3d(v.center.x-this.center.x,v.center.y-this.center.y,v.center.z-this.center.z),b=this._matrix.multiplyInverse(v.vector0),E=this._matrix.multiplyInverse(v.vector90);if(M&&b&&E)return{center:M,vector0:b,vector90:E,sweep:this.sweep.clone()}}static createFilletArc(v,M,b,E){const D=$.createStartEnd(M,v),X=$.createStartEnd(M,b),z=D.magnitude(),R=X.magnitude();if(D.normalizeInPlace()&&X.normalizeInPlace()){const v=D.plus(X);if(v.normalizeInPlace()){const b=X.minus(D),O=b.magnitude(),Y=.5*O;if(!K.isSmallAngleRadians(Y)){const D=Y/Math.sqrt(1-Y*Y),X=Math.acos(Y),N=E/Y,B=E/D,V=B/z,L=B/R,U=M.plusScaled(v,N);return v.scaleInPlace(-E),b.scaleInPlace(E/O),{arc:ti.create(U,v,b,It.createStartEndRadians(-X,X)),fraction10:V,fraction12:L,point:M.clone()}}}}return{fraction10:0,fraction12:0,point:M.clone()}}scaleAboutCenterInPlace(v){this._matrix.scaleColumnsInPlace(v,v,1)}areaToChordXY(v,M){let b=K.crossProductXYXY(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[1],this._matrix.coffs[4]);const E=this._sweep.fractionToRadians(v),D=.5*(this._sweep.fractionToRadians(M)-E);return D<0&&(b=-b),(D-Math.cos(D)*Math.sin(D))*b}constructOffsetXY(v){const M=Se.create(v);if(this.isCircular||M.preserveEllipticalArcs){const v=this.cloneAtZ(),b=v.sweep.sweepRadians*v.matrixRef.coffs[8]>=0?1:-1,E=v.matrixRef.columnXMagnitude(),D=E-b*M.leftOffsetDistance,X=this.isCircular?E:v.matrixRef.columnYMagnitude(),z=this.isCircular?D:X-b*M.leftOffsetDistance;if(!K.isSmallMetricDistance(D)&&E*D>0&&(this.isCircular||!K.isSmallMetricDistance(z)&&X*z>0)){const M=D/E,b=this.isCircular?M:z/X,R=v.matrixClone();return R.scaleColumnsInPlace(M,b,1),ti.createRefs(v.center.clone(),R,v.sweep.clone())}return}const b=new ye(this,M.leftOffsetDistance);return this.emitStrokableParts(b,M.strokeOptions),b.claimResult()}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}}ti._workPointA=Q.create(),ti._workPointB=Q.create(),ti._workPointC=Q.create(),ti._workVectorU=$.create(),ti._workVectorV=$.create(),ti.quadratureGuassCount=5,ti.quadratureIntervalAngleDegrees=10;class ei{areStronglyIndependentVectors(v,M,b=K.smallAngleRadians){return void 0!==v&&void 0!==M&&v.smallerUnorientedRadiansTo(M)>b}clear(){this._origin=void 0,this._vector0=void 0,this._vector1=void 0,this._vector2=void 0}constructor(){this.clear()}getValidatedFrame(v=!1,M){if(this._origin&&this._vector0&&this._vector1){const i=(v,M)=>ei._workMatrix=xt.createRigidFromColumns(v,M,z.XYZ,ei._workMatrix);if(v){if(this._vector2){const v=i(this._vector0,this._vector1);if(v)return this._vector0.tripleProduct(this._vector1,this._vector2)<0&&v.scaleColumns(1,1,-1),pt.createOriginAndMatrix(this._origin,v,M);const b=this._vector2;this._vector1=this._vector2=void 0,this.announceVector(b)}}else{const v=i(this._vector0,this._vector1);if(v)return pt.createOriginAndMatrix(this._origin,v,M);this._vector1=this._vector2=void 0}}}applyDefaultUpVector(v){v&&this._vector0&&!this._vector1&&!v.isParallelTo(this._vector0)&&(this._vector1=v.crossProduct(this._vector0))}get hasOrigin(){return void 0!==this._origin}savedVectorCount(){return this._vector0?this._vector1?this._vector2?3:2:1:0}announcePoint(v){return this._origin?this._origin.isAlmostEqual(v)?this.savedVectorCount():this.announceVector(this._origin.vectorTo(v)):(this._origin=v.clone(),this.savedVectorCount())}announceVector(v){if(v.isAlmostZero)return this.savedVectorCount();if(!this._vector0)return this._vector0=v.clone(this._vector0),1;if(!this._vector1)return this.areStronglyIndependentVectors(v,this._vector0,1e-5)?(this._vector1=v.clone(this._vector1),2):1;if(!this._vector2){const M=this._vector0.unitCrossProduct(this._vector1);return M&&!K.isSameCoordinate(0,M.dotProduct(v))?(this._vector2=v.clone(this._vector2),3):2}return 3}announce(v){if(!(this.savedVectorCount()>1)&&void 0!==v)if(v instanceof Q)this.announcePoint(v);else if(v instanceof $)this.announceVector(v);else if(Array.isArray(v))for(const M of v){if(this.savedVectorCount()>1)break;this.announce(M)}else if(v instanceof oe)if(v instanceof we)this.announcePoint(v.startPoint()),this.announcePoint(v.endPoint());else if(v instanceof ti){const M=v.fractionToPointAndDerivative(0);this.announcePoint(M.origin),this.announceVector(M.direction),this.announceVector(v.matrixRef.columnZCrossVector(M.direction))}else if(v instanceof ke){for(const M of v.points)if(this.announcePoint(M),this.savedVectorCount()>1)break}else if(v instanceof $e){const M=Q.create();for(let b=0;this.savedVectorCount()<2&&v.getPolePoint3d(b,M)instanceof Q;b++)this.announcePoint(M)}else if(v instanceof xe){const M=Q.create();for(let b=0;this.savedVectorCount()<2&&b<v.options.fitPoints.length;b++)M.setFrom(v.options.fitPoints[b]),this.announcePoint(M)}else{const M=v.fractionToFrenetFrame(0);void 0!==M&&(this.announcePoint(M.getOrigin()),this.announceVector(M.matrix.getColumn(0)),this.announceVector(M.matrix.getColumn(1)))}else if(v instanceof ze){if(v.children)for(const M of v.children)if(this.announce(M),this.savedVectorCount()>1)break}else if(v instanceof nt){const M=Q.create();for(let b=0;this.savedVectorCount()<2&&v.getPoint3dAtCheckedPointIndex(b,M)instanceof Q;b++)this.announcePoint(M)}}static createRightHandedFrame(v,...M){let b=M.length>0&&M[M.length-1]instanceof pt?M.pop():void 0;const E=new ei;for(const D of M)if(E.announce(D),E.applyDefaultUpVector(v),b=E.getValidatedFrame(!1,b))return v&&b.matrix.dotColumnZ(v)<0&&b.matrix.scaleColumnsInPlace(1,-1,-1),b;const n=(v,M)=>v.fractionToFrenetFrame(0,M);for(const D of M){if(D instanceof oe)return n(D,b);if(D instanceof ze){const v=D.collectCurvePrimitives();for(const M of v)if(b=n(M,b))return b}}}static createRightHandedLocalToWorld(...v){return this.createRightHandedFrame(void 0,v)}static createFrameToDistantPoints(v,M){if(v.length>2){const b=v[0],E=ei._workVector0??$.create();de.indexOfMostDistantPoint(v,v[0],E);const D=ei._workVector1??$.create();de.indexOfPointWithMaxCrossProductMagnitude(v,b,E,D);const X=ei._workMatrix=xt.createRigidFromColumns(E,D,z.XYZ,ei._workMatrix);if(X)return pt.createOriginAndMatrix(b,X,M)}}static createFrameWithCCWPolygon(v,M){if(v.length>2){const b=vr.centroidAreaNormal(v);if(b)return b.toRigidZFrame(M)}}static createLocalToWorldTransformInRange(v,M=Y.NonUniformRangeContainment,b=0,E=0,D=0,X=1,z){if(v.isNull)return pt.createIdentity(z);let R=1,O=1,N=1;M===Y.LongestRangeDirection?R=O=N=K.correctSmallMetricDistance(v.maxLength(),X):M===Y.NonUniformRangeContainment&&(R=K.correctSmallMetricDistance(v.xLength(),X)*K.maxAbsDiff(b,0,1),O=K.correctSmallMetricDistance(v.yLength(),X)*K.maxAbsDiff(E,0,1),N=K.correctSmallMetricDistance(v.zLength(),X)*K.maxAbsDiff(D,0,1));const B=ei._workPoint=v.fractionToPoint(b,E,D,ei._workPoint),V=ei._workMatrix=xt.createScale(R,O,N,ei._workMatrix);return pt.createOriginAndMatrix(B,V,z)}}class ii extends ze{isSameGeometryClass(v){return v instanceof ii}get children(){return this._children}constructor(){super(),this.curveCollectionType="parityRegion",this._children=[]}addLoops(v){if(void 0===v);else if(v instanceof Oe)this.children.push(v);else if(Array.isArray(v))for(const M of v)M instanceof Oe?this.children.push(M):Array.isArray(M)&&this.addLoops(M)}static createLoops(v){if(v instanceof Oe)return v;const M=new ii;return M.addLoops(v),M}static create(...v){const M=new ii;for(const b of v)M.children.push(b);return M}dgnBoundaryType(){return 4}announceToCurveProcessor(v,M=-1){return v.announceParityRegion(this,M)}clone(){const v=new ii;let M;for(M of this.children){const b=M.clone();b instanceof Oe&&v.children.push(b)}return v}cloneStroked(v){const M=new ii;let b;for(b of this.children){const E=b.cloneStroked(v);E&&M.children.push(E)}return M}cloneEmptyPeer(){return new ii}tryAddChild(v){return!!(v&&v instanceof Oe)&&(this._children.push(v),!0)}getChild(v){if(v<this._children.length)return this._children[v]}dispatchToGeometryHandler(v){return v.handleParityRegion(this)}}class si{constructor(v,M,b){this._toleranceSquared=b*b,this._source=v,this._dest=M}acceptPointByIndex(v){const M=this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(v));M&&this._dest.push(M)}indexOfMaxCrossProduct(v,M){let b,E,D=0;for(let X=v;X<=M;X++){const v=this._source.cyclicIndex(X),M=this._source.cyclicIndex(X+1),z=this._source.cyclicIndex(X+2);this._source.crossProductIndexIndexIndex(v,M,z,si._vectorQ),b=si._vectorQ.magnitudeSquared(),b>D&&(D=b,E=X)}return E}indexOfMaxDeviation(v,M){const b=this._source.cyclicIndex(v),E=this._source.cyclicIndex(M);let D,X,z,R,O,Y=this._toleranceSquared;this._source.vectorIndexIndex(b,E,si._vector01);const N=si._vector01.magnitudeSquared();for(let B=v+1;B<M;B++)O=this._source.cyclicIndex(B),this._source.vectorIndexIndex(b,O,si._vectorQ),X=si._vector01.dotProduct(si._vectorQ),X<=0?z=si._vectorQ.magnitudeSquared():X>N?(this._source.vectorIndexIndex(E,O,si._vectorQ),z=si._vectorQ.magnitudeSquared()):(R=X/N,z=si._vectorQ.magnitudeSquared()-N*R*R),z>Y&&(Y=z,D=B);return D}recursiveCompressByChordErrorGo(v,M){if(M===v+1)return void this.acceptPointByIndex(M);const b=this.indexOfMaxDeviation(v,M);void 0===b?this.acceptPointByIndex(M):(this.recursiveCompressByChordErrorGo(v,b),this.recursiveCompressByChordErrorGo(b,M))}static compressPoint3dArrayByChordError(v,M){const b=new ae(v),E=new ae([]);return this.compressCollectionByChordError(b,E,M),E.data}static compressCollectionByChordError(v,M,b){M.clear();const E=v.length;if(1===E)return void M.push(v.getPoint3dAtCheckedPointIndex(0));const D=new si(v,M,b);let X=0,z=E-1;if(E>2&&v.distanceIndexIndex(0,E-1)<=b){const v=D.indexOfMaxCrossProduct(0,E-1);void 0!==v&&(X=v+1,z=X+E)}D.acceptPointByIndex(X),D.recursiveCompressByChordErrorGo(X,z)}static compressInPlaceByShortEdgeLength(v,M){const b=v.length;if(b<2)return;let E=0,D=b-1;for(;D>0&&v.distanceIndexIndex(D-1,b-1)<M;)D--;if(0===D)return void(v.length=1);D<b-1&&v.moveIndexToIndex(b-1,D);let X=E+1;for(;X<=D;)v.distanceIndexIndex(E,X)>=M&&(v.moveIndexToIndex(X,E+1),E++),X++;v.length=E+1}static compressInPlaceBySmallTriangleArea(v,M){const b=v.length;if(b<3)return;let E=0;const D=$.create();for(let X=1;X+1<b;X++)v.crossProductIndexIndexIndex(E,X,X+1,D),.5*D.magnitude()>M&&v.moveIndexToIndex(X,++E);v.moveIndexToIndex(b-1,++E),v.length=E+1}static compressInPlaceByPerpendicularDistance(v,M,b=1.0001){const E=v.length;if(E<3)return;let D=0;const X=si._vector01,z=si._vectorQ;let R;const O=M*M;let Y,N=1;for(;N+1<E;N++){v.vectorIndexIndex(D,N+1,X),v.vectorIndexIndex(D,N,z),Y=X.magnitudeSquared();const M=K.conditionalDivideFraction(z.dotProduct(X),Y);void 0!==M&&M>=0&&M<=b&&(R=si._vectorQ.magnitudeSquared()-Y*M*M,R<=O)?(v.moveIndexToIndex(N+1,++D),N+=1):v.moveIndexToIndex(N,++D)}N<E&&v.moveIndexToIndex(N,++D),v.length=D+1}static compressColinearWrapInPlace(v,M){const b=v.length-1;if(b>=3&&v[0].distance(v[b])<M){const E=b-1,D=0,X=1,z=$.createStartEnd(v[E],v[X]),R=$.createStartEnd(v[E],v[D]),O=z.dotProduct(z),Y=z.dotProduct(R),N=K.conditionalDivideFraction(Y,O);if(void 0!==N&&N>0&&N<1){const b=R.magnitudeSquared()-N*N*O;Math.sqrt(Math.abs(b))<M&&(v[0]=v[E],v.pop())}}}}si._vector01=$.create(),si._vectorQ=$.create();class ni{get quantitySum(){return this.sums.atIJ(3,3)}signFactor(v){return v*this.quantitySum>0?1:-1}setOriginIfNeeded(v){this.needOrigin&&(this.origin.setFromPoint3d(v),this.needOrigin=!1)}setOriginFromGrowableXYZArrayIfNeeded(v){this.needOrigin&&v.length>0&&(v.getPoint3dAtCheckedPointIndex(0,this.origin),this.needOrigin=!1)}setOriginXYZIfNeeded(v,M,b){this.needOrigin&&(this.origin.set(v,M,b),this.needOrigin=!1)}constructor(){this._point0=Q.create(),this._point1=Q.create(),this.origin=Q.createZero(),this.sums=Xt.createZero(),this.localToWorldMap=pt.createIdentity(),this.radiusOfGyration=$.create(),this.needOrigin=!1,this.absoluteQuantity=.1,this.absoluteQuantity=void 0}static create(v,M=!1){const b=new ni;return b.needOrigin=M,v&&(b.origin.setFromPoint3d(v),b.needOrigin=!1),b}static momentTensorFromInertiaProducts(v){const M=v.sumDiagonal(),b=xt.createScale(M,M,M);return b.addScaledInPlace(v,-1),b}static sortColumnsForIncreasingMoments(v,M){const b=[v.indexedColumnWithWeight(0,M.x),v.indexedColumnWithWeight(1,M.y),v.indexedColumnWithWeight(2,M.z)].sort(((v,M)=>v.w<M.w?-1:v.w>M.w?1:0));v.setColumnsPoint4dXYZ(b[0],b[1],b[2]),v.determinant()<0&&v.scaleColumnsInPlace(-1,-1,-1),v.at(0,0)<0&&v.scaleColumnsInPlace(-1,-1,1),v.at(2,2)<0&&v.scaleColumnsInPlace(1,-1,-1),M.set(b[0].w,b[1].w,b[2].w)}static pointsToPrincipalAxes(v){const M=new ni;return 0===v.length?M:(M.clearSums(v[0]),M.accumulatePointMomentsFromOrigin(v),this.inertiaProductsToPrincipalAxes(M.origin,M.sums))}static inertiaProductsToPrincipalAxes(v,M){const b=new ni;if(b.sums.setFrom(M),b.origin.setFrom(v),!b.shiftOriginAndSumsToCentroidOfSums())return;const E=b.sums.matrixPart(),D=b.sums.weight();D<0&&E.scaleColumnsInPlace(-1,-1,-1);const X=ni.momentTensorFromInertiaProducts(E),z=$.create(),R=xt.createZero();return X.fastSymmetricEigenvalues(R,z),z.x<0?void 0:(ni.sortColumnsForIncreasingMoments(R,z),D<0&&R.scaleColumnsInPlace(1,-1,-1),b.localToWorldMap=pt.createOriginAndMatrix(b.origin,R),b.radiusOfGyration.set(Math.sqrt(Math.abs(z.x)),Math.sqrt(Math.abs(z.y)),Math.sqrt(Math.abs(z.z))),b.radiusOfGyration.scaleInPlace(1/Math.sqrt(Math.abs(D))),b.absoluteQuantity=Math.abs(D),b)}static areEquivalentPrincipalAxes(v,M){if(v&&M&&K.isSameCoordinate(v.quantitySum,M.quantitySum)&&v.localToWorldMap.getOrigin().isAlmostEqual(M.localToWorldMap.getOrigin())&&v.radiusOfGyration.isAlmostEqual(M.radiusOfGyration)){if(K.isSameCoordinate(v.radiusOfGyration.x,v.radiusOfGyration.y)){if(K.isSameCoordinate(v.radiusOfGyration.x,v.radiusOfGyration.z))return!0;const b=v.localToWorldMap.matrix.columnZ(),E=M.localToWorldMap.matrix.columnZ();return!!b.isParallelTo(E,!0)}const b=$.create(),E=$.create();for(let D=0;D<3;D++)if(v.localToWorldMap.matrix.getColumn(D,b),M.localToWorldMap.matrix.getColumn(D,E),!b.isParallelTo(E,!0))return!1;return!0}return!1}clearSums(v){this.sums.setZero(),v?this.origin.setFrom(v):this.origin.setZero()}accumulatePointMomentsFromOrigin(v){for(const M of v)this.sums.addMomentsInPlace(M.x-this.origin.x,M.y-this.origin.y,M.z-this.origin.z,1)}shiftOriginAndSumsToCentroidOfSums(){const v=this.sums.columnW().realPoint();return!!v&&(this.shiftOriginAndSumsByXYZ(v.x,v.y,v.z),!0)}shiftOriginAndSumsByXYZ(v,M,b){this.origin.addXYZInPlace(v,M,b),this.sums.multiplyTranslationSandwichInPlace(-v,-M,-b)}shiftOriginAndSumsToNewOrigin(v){this.shiftOriginAndSumsByXYZ(v.x-this.origin.x,v.y-this.origin.y,v.z-this.origin.z)}accumulateTriangleMomentsXY(v,M,b){this.setOriginXYZIfNeeded(M.x,M.y,0);const E=this.origin.x,D=this.origin.y,X=ni._vectorA=void 0!==v?Dt.create(v.x-E,v.y-D,0,1,ni._vectorA):Dt.create(this.origin.x,this.origin.y,0,1,ni._vectorA),z=ni._vectorB=Dt.create(M.x-E,M.y-D,0,1,ni._vectorB),R=ni._vectorC=Dt.create(b.x-E,b.y-D,0,1,ni._vectorC),O=K.crossProductXYXY(z.x-X.x,z.y-X.y,R.x-X.x,R.y-X.y);if(0!==O){const v=O/12,M=O/24;this.sums.addScaledOuterProductInPlace(X,X,v),this.sums.addScaledOuterProductInPlace(X,z,M),this.sums.addScaledOuterProductInPlace(X,R,M),this.sums.addScaledOuterProductInPlace(z,X,M),this.sums.addScaledOuterProductInPlace(z,z,v),this.sums.addScaledOuterProductInPlace(z,R,M),this.sums.addScaledOuterProductInPlace(R,X,M),this.sums.addScaledOuterProductInPlace(R,z,M),this.sums.addScaledOuterProductInPlace(R,R,v)}}accumulateScaledOuterProduct(v,M){this.setOriginXYZIfNeeded(v.x,v.y,0);const b=ni._vectorA=Dt.create(v.x-this.origin.x,v.y-this.origin.y,v.z-this.origin.z,1,ni._vectorA);this.sums.addScaledOuterProductInPlace(b,b,M)}accumulateLineMomentsXYZ(v,M){this.setOriginXYZIfNeeded(v.x,v.y,v.z);const b=this.origin.x,E=this.origin.y,D=this.origin.z,X=ni._vectorA=Dt.create(v.x-b,v.y-E,v.z-D,1,ni._vectorA),z=ni._vectorB=Dt.create(M.x-b,M.y-E,M.z-D,1,ni._vectorB),R=v.distance(M),O=R/3,Y=R/6;this.sums.addScaledOuterProductInPlace(X,X,O),this.sums.addScaledOuterProductInPlace(X,z,Y),this.sums.addScaledOuterProductInPlace(z,X,Y),this.sums.addScaledOuterProductInPlace(z,z,O)}accumulateTriangleToLineStringMomentsXY(v,M){const b=M.length;if(b>1){M.getPoint3dAtUncheckedPointIndex(0,this._point0);for(let E=1;E<b;E++)M.getPoint3dAtUncheckedPointIndex(E,this._point1),this.accumulateTriangleMomentsXY(v,this._point0,this._point1),this._point0.setFromPoint3d(this._point1)}}accumulateXYProductsInCentroidalFrame(v,M,b,E,D,X,z){const R=Xt.createRowValues(v,M,0,0,M,b,0,0,0,0,0,0,0,0,0,E),O=K.crossProductXYXY(X.x,z.x,X.y,z.y),Y=Xt.createRowValues(X.x,z.x,0,D.x-this.origin.x,X.y,z.y,0,D.y-this.origin.y,0,0,0,0,0,0,0,1),N=Y.multiplyMatrixMatrix(R).multiplyMatrixMatrixTranspose(Y);this.sums.addScaledInPlace(N,O)}accumulateProducts(v,M){this.setOriginIfNeeded(v.origin),this.sums.addTranslationSandwichInPlace(v.sums,this.origin.x-v.origin.x,this.origin.y-v.origin.y,this.origin.z-v.origin.z,M)}accumulateProductsFromOrigin(v,M,b){this.setOriginIfNeeded(v),this.sums.addTranslationSandwichInPlace(M,this.origin.x-v.x,this.origin.y-v.y,this.origin.z-v.z,b)}toJSON(){return{origin:this.origin,sums:this.sums.toJSON(),radiusOfGyration:this.radiusOfGyration.toJSON(),localToWorld:this.localToWorldMap.toJSON()}}}class ri extends Ue{constructor(v,M,b){super(),this._geometry1=b,this._fraction=M}handleLineSegment3d(v){if(this._geometry1 instanceof we){const M=this._geometry1;return we.create(v.startPoint().interpolate(this._fraction,M.startPoint()),v.endPoint().interpolate(this._fraction,M.endPoint()))}}handleLineString3d(v){if(this._geometry1 instanceof ke){const M=this._geometry1;if(v.numPoints()===M.numPoints()){const b=v.numPoints(),E=ke.create(),D=Q.create(),X=Q.create(),z=Q.create(),R=this._fraction;for(let O=0;O<b;O++)v.pointAt(O,X),M.pointAt(O,z),X.interpolate(R,z,D),E.addPoint(D);if(v.fractions&&M.fractions)for(let O=0;O<b;O++)E.addFraction(K.interpolate(v.fractions.atUncheckedIndex(O),R,M.fractions.atUncheckedIndex(O)));if(v.strokeData&&M.strokeData&&(E.strokeData=v.strokeData.clone()),v.packedDerivatives&&M.packedDerivatives){const D=$.create(),X=$.create();for(let z=0;z<b;z++)v.packedDerivatives.getVector3dAtCheckedVectorIndex(z,D),M.packedDerivatives.getVector3dAtCheckedVectorIndex(z,X),E.addDerivative(D.interpolate(R,X))}return E}}}handleArc3d(v){if(this._geometry1 instanceof ti){const M=this._geometry1;return ti.create(v.center.interpolate(this._fraction,M.center),v.vector0.interpolate(this._fraction,M.vector0),v.vector90.interpolate(this._fraction,M.vector90),v.sweep.interpolate(this._fraction,M.sweep))}}static interpolateBetween(v,M,b){const E=new ri(v,M,b);return v.dispatchToGeometryHandler(E)}}class oi{static edgeLengthRange(v){const M=ft.createNull();for(let b=1;b<v.length;b++)M.extendX(v[b-1].distance(v[b]));return M}static compressByChordError(v,M){return si.compressPoint3dArrayByChordError(v,M)}static compressShortEdges(v,M){const b=nt.create(v);return si.compressInPlaceByShortEdgeLength(b,M),b.getPoint3dArray()}static compressSmallTriangles(v,M){const b=nt.create(v);return si.compressInPlaceBySmallTriangleArea(b,M),b.getPoint3dArray()}static compressByPerpendicularDistance(v,M,b=2){const E=nt.create(v);let D=E.length;for(let X=0;X<b;X++){si.compressInPlaceByPerpendicularDistance(E,M);const v=E.length;if(v===D)break;D=v}return E.getPoint3dArray()}static squaredDistanceToInterpolatedPoint(v,M,b,E){const D=1-b,X=v.x-(D*M.x+b*E.x),z=v.y-(D*M.y+b*E.y),R=v.z-(D*M.z+b*E.z);return X*X+z*z+R*R}static isDanglerConfiguration(v,M,b,E,D){if(M<0||M>=v.length)return!1;const X=v[M],z=X.distanceSquared(E);if(z<=D)return!0;if(b<0||b>=v.length)return!1;const R=v[b],O=X.dotVectorsToTargets(R,E);if(O<=0)return!1;const Y=X.distanceSquared(R);let N;if(z>=Y){const v=O/z;N=this.squaredDistanceToInterpolatedPoint(R,X,v,E)}else{const v=O/Y;N=this.squaredDistanceToInterpolatedPoint(E,X,v,R)}return N<D}static compressDanglers(v,M=!1,b=K.smallMetricDistance){let E=v.length;const D=b*b;if(M)for(;E>1&&v[E-1].distanceSquared(v[0])<=D;)E--;const X=[];X.push(v[0].clone());for(let z=1;z<E;z++){const M=v[z];for(;this.isDanglerConfiguration(X,X.length-1,X.length-2,M,D);)X.pop();X.push(M.clone())}if(M){let v=0,M=X.length-1;for(;M>v+2;)if(this.isDanglerConfiguration(X,v,v+1,X[M],D))v++;else{if(!this.isDanglerConfiguration(X,M,M-1,X[v],D))break;M--}M+1<X.length&&(X.length=M+1),v>0&&X.splice(0,v)}return X}static addClosurePoint(v){if(0===v.length)return;const M=v[0];if(Array.isArray(M)){for(const M of v)Array.isArray(M)&&this.addClosurePoint(M);return}const b=v[v.length-1];M instanceof Q&&b instanceof Q&&!M.isAlmostEqual(b)&&v.push(M.clone())}static removeClosurePoint(v){if(0===v.length)return;const M=v[0];if(Array.isArray(M)){for(const M of v)Array.isArray(M)&&this.removeClosurePoint(M);return}const b=v[v.length-1];M instanceof Q&&b instanceof Q&&M.isAlmostEqual(b)&&v.pop()}static createBisectorPlanesForDistinctPoints(v,M=!1){const b=oi.compressShortEdges(v,2*K.smallMetricDistance);if(b.length<2)return;const E=[],D=b[0],X=b[1],z=$.createNormalizedStartEnd(D,X),R=yt.create(D,z),O=yt.createXYPlane();E.push(R.clone());for(let N=1;N+1<b.length;N++)if($.createNormalizedStartEnd(b[N],b[N+1],z),void 0!==yt.create(b[N],z,O)){const v=R.getNormalRef().interpolate(.5,O.getNormalRef()),M=yt.create(b[N],v);void 0!==M&&E.push(M),R.setFrom(O)}E.push(yt.create(b[b.length-1],R.getNormalRef()));const Y=E.length-1;if(Y>0&&M){const v=E[0],M=E[Y];if(K.isSamePoint3d(v.getOriginRef(),M.getOriginRef())){const b=v.getNormalRef().plus(M.getNormalRef()),D=yt.create(v.getOriginRef(),b);void 0!==D&&(E[0]=D,E[Y]=yt.create(M.getOriginRef(),b))}}return E.length>1?E:void 0}}class ai extends Nt{constructor(v){super(),this.geometryCategory="solid",this._capped=v}get capped(){return this._capped}set capped(v){this._capped=v}}class ci extends ai{constructor(v,M,b,E){super(E),this.solidPrimitiveType="cone",this._localToWorld=v,this._radiusA=M,this._radiusB=b,this._maxRadius=Math.max(this._radiusA,this._radiusB)}clone(){return new ci(this._localToWorld.clone(),this._radiusA,this._radiusB,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(v){return!v.matrix.isSingular()&&(v.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(v){const M=this.clone();return v.multiplyTransformTransform(M._localToWorld,M._localToWorld),M}static createAxisPoints(v,M,b,E,D){const X=v.vectorTo(M),z=X.magnitude();if(K.isSmallMetricDistance(z))return;if((b=K.correctSmallMetricDistance(b))*(E=K.correctSmallMetricDistance(E))<0)return;if(b+E===0)return;const R=xt.createRigidHeadsUp(X);R.scaleColumns(1,1,z,R);const O=pt.createOriginAndMatrix(v,R);return new ci(O,b,E,D)}static createBaseAndTarget(v,M,b,E,D,X,z){D=Math.abs(K.correctSmallMetricDistance(D)),X=Math.abs(K.correctSmallMetricDistance(X));const R=v.vectorTo(M),O=pt.createOriginAndMatrixColumns(v,b,E,R);return new ci(O,D,X,z)}getCenterA(){return this._localToWorld.multiplyXYZ(0,0,0)}getCenterB(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getRadiusA(){return this._radiusA}getRadiusB(){return this._radiusB}getMaxRadius(){return this._maxRadius}vFractionToRadius(v){return K.interpolate(this._radiusA,v,this._radiusB)}isSameGeometryClass(v){return v instanceof ci}isAlmostEqual(v){return v instanceof ci&&this.capped===v.capped&&!!this._localToWorld.isAlmostEqualAllowZRotation(v._localToWorld)&&K.isSameCoordinate(this._radiusA,v._radiusA)&&K.isSameCoordinate(this._radiusB,v._radiusB)}dispatchToGeometryHandler(v){return v.handleCone(this)}strokeConstantVSection(v,M,b){let E=16;void 0!==M?E=M:void 0!==b&&(E=b.defaultCircleStrokes),E=K.clampToStartEnd(E,4,64);const D=this.vFractionToRadius(v),X=ke.createForStrokes(M,b),z=2*Math.PI,R=z/E;let O=0;const Y=X.fractions,N=X.packedDerivatives,B=X.packedUVParams,V=X.packedSurfaceNormals,L=Q.create(),U=$.create(),Sr=$.create(),Cr=$.create(),kr=this._localToWorld;let Fr,Xr,zr,Rr;for(let Or=0;Or<=E;Or++)O=2*Or<=E?Or*R:(Or-E)*R,zr=Math.cos(O),Rr=Math.sin(O),Fr=D*zr,Xr=D*Rr,kr.multiplyXYZ(Fr,Xr,v,L),X.addPoint(L),Y&&Y.push(Or/E),N&&(kr.matrix.multiplyXYZ(-Xr*z,Fr*z,0,U),N.push(U)),V&&(kr.matrix.multiplyXYZ(-Rr,zr,0,U),kr.matrix.multiplyXYZ(0,0,1,Sr),U.unitCrossProduct(Sr,Cr),V.push(Cr)),B&&B.pushXY(Or/E,v);return X}constantVSection(v){const M=this.vFractionToRadius(v),b=this._localToWorld,E=b.multiplyXYZ(0,0,v),D=b.matrix.multiplyXYZ(M,0,0),X=b.matrix.multiplyXYZ(0,M,0);return Oe.create(ti.create(E,D,X))}extendRange(v,M){const b=this.constantVSection(0),E=this.constantVSection(1);b.extendRange(v,M),E.extendRange(v,M)}uvFractionToPoint(v,M,b){const E=v*Math.PI*2,D=K.interpolate(this._radiusA,M,this._radiusB),X=Math.cos(E),z=Math.sin(E);return this._localToWorld.multiplyXYZ(D*X,D*z,M,b)}uvFractionToPointAndTangents(v,M,b){const E=v*Math.PI*2,D=K.interpolate(this._radiusA,M,this._radiusB),X=this._radiusB-this._radiusA,z=Math.cos(E),R=Math.sin(E),O=2*Math.PI;return bt.createOriginAndVectors(this._localToWorld.multiplyXYZ(D*z,D*R,M),this._localToWorld.multiplyVectorXYZ(-D*R*O,D*z*O,0),this._localToWorld.multiplyVectorXYZ(X*z,X*R,1),b)}get isClosedVolume(){return this.capped}maxIsoParametricDistance(){const v=this._localToWorld.matrix.columnX(),M=this._localToWorld.matrix.columnY(),b=this._localToWorld.matrix.columnZ(),E=v.unitCrossProduct(M),D=E.dotProduct(b),X=b.plusScaled(E,D).magnitudeXY();return J.create(2*Math.PI*Math.max(this._radiusA,this._radiusB),K.hypotenuseXY(Math.abs(this._radiusB-this._radiusA)+X,D))}}class hi{constructor(v,M=8,b){this._data=new Float64Array(M*v),this._inUse=0,this._blockSize=v>0?v:1,this._growthFactor=void 0!==b&&b>=1?b:1.5}copyData(v,M,b){let E=void 0!==b?b*this.numPerBlock:0;if(E<0&&(E=0),E>=this._data.length)return{count:0,offset:0};let D=void 0!==M?M*this.numPerBlock:v.length;return D>0&&(D>v.length&&(D=v.length),E+D>this._data.length&&(D=this._data.length-E),D%this.numPerBlock!=0&&(D-=D%this.numPerBlock)),D<=0?{count:0,offset:0}:(D===v.length?this._data.set(v,E):v instanceof Float64Array?this._data.set(v.subarray(0,D),E):this._data.set(v.slice(0,D),E),{count:D/this.numPerBlock,offset:E/this.numPerBlock})}clone(){const v=new hi(this.numPerBlock,this.numBlocks,this._growthFactor);return v.copyData(this._data,this.numBlocks),v._inUse=this.numBlocks,v}get length(){return this._inUse}get numBlocks(){return this._inUse}get numPerBlock(){return this._blockSize}getWithinBlock(v,M){return this._data[v*this._blockSize+M]}clear(){this._inUse=0}blockCapacity(){return this._data.length/this._blockSize}ensureBlockCapacity(v,M=!0){if(v>this.blockCapacity()){M&&(v*=this._growthFactor);const b=this._data;this._data=new Float64Array(v*this._blockSize),this.copyData(b,this._inUse)}}addBlock(v){const M=this.newBlockIndex();let b=v.length;b>this._blockSize&&(b=this._blockSize);for(let E=0;E<b;E++)this._data[M+E]=v[E]}newBlockIndex(){const v=this._blockSize*this._inUse;v+1>this._data.length&&this.ensureBlockCapacity(1+this._inUse),this._inUse++;for(let M=v;M<v+this._blockSize;M++)this._data[M]=0;return v}popBlock(){this._inUse>0&&this._inUse--}blockIndexToDoubleIndex(v){return this._blockSize*v}checkedComponent(v,M){if(!(v>=this._inUse||v<0||M<0||M>=this._blockSize))return this._data[this._blockSize*v+M]}component(v,M){return this._data[this._blockSize*v+M]}static compareLexicalBlock(v,M,b,E){let D=0,X=0;for(let z=0;z<M;z++){if(D=v[b+z],X=v[E+z],D>X)return 1;if(D<X)return-1}return b-E}sortIndicesLexical(v=((v,M,b,E)=>hi.compareLexicalBlock(v,M,b,E))){const M=this._inUse,b=new Uint32Array(M),E=this._data,D=this._blockSize;for(let X=0;X<M;X++)b[X]=X;return b.sort(((M,b)=>v(E,D,M*D,b*D))),b}distanceBetweenBlocks(v,M){let b=0,E=this.blockIndexToDoubleIndex(v),D=this.blockIndexToDoubleIndex(M),X=0;const z=this._data;for(let R=0;R<this._blockSize;R++)X=z[E++]-z[D++],b+=X*X;return Math.sqrt(b)}distanceBetweenSubBlocks(v,M,b,E){let D=0;const X=this.blockIndexToDoubleIndex(v),z=this.blockIndexToDoubleIndex(M);let R=0;const O=this._data;for(let Y=b;Y<E;Y++)R=O[X+Y]-O[z+Y],D+=R*R;return Math.sqrt(D)}}class li extends hi{static sortVectorComponent(v){let M=1;for(let b=1;b<v;b++)M*=li._vectorFactor;return M}constructor(v,M,b){super(1+v+M,b),this._numExtraDataPerPoint=M,this._numCoordinatePerPoint=v}addBlock(v){const M=this.newBlockIndex()+1,b=Math.min(this.numPerBlock-1,v.length);for(let E=0;E<b;E++)this._data[M+E]=v[E]}addDirect(v,M,b,E,D){const X=this.newBlockIndex();this._data[X+1]=v,void 0!==M&&(this._data[X+2]=M),void 0!==b&&(this._data[X+3]=b),void 0!==E&&(this._data[X+4]=E),void 0!==D&&(this._data[X+5]=D)}addPoint2d(v,M,b,E){const D=this.newBlockIndex();this._data[D+1]=v.x,this._data[D+2]=v.y,void 0!==M&&(this._data[D+3]=M),void 0!==b&&(this._data[D+4]=b),void 0!==E&&(this._data[D+5]=E)}addPoint3d(v,M,b,E){const D=this.newBlockIndex();this._data[D+1]=v.x,this._data[D+2]=v.y,this._data[D+3]=v.z,void 0!==M&&(this._data[D+4]=M),void 0!==b&&(this._data[D+5]=b),void 0!==E&&(this._data[D+6]=E)}getPoint2d(v,M){const b=this.blockIndexToDoubleIndex(v);return H.create(this._data[b+1],this._data[b+2],M)}getPoint3d(v,M){const b=this.blockIndexToDoubleIndex(v);return Q.create(this._data[b+1],this._data[b+2],this._data[b+3],M)}getExtraData(v,M){const b=this.blockIndexToDoubleIndex(v);return this._data[b+1+this._numCoordinatePerPoint+M]}getData(v,M){const b=this.blockIndexToDoubleIndex(v);return this._data[b+M]}setExtraData(v,M,b){const E=this.blockIndexToDoubleIndex(v);this._data[E+1+this._numCoordinatePerPoint+M]=b}static isClusterTerminator(v){return v===li.clusterTerminator}clusterIndicesLexical(v=K.smallMetricDistance){this.setupPrimaryClusterSort();const M=this.sortIndicesLexical(),b=new Uint32Array(2*M.length);let E=0;const D=this.numBlocks;let X=0,z=0,R=0,O=0,Y=0;const N=1+this._numCoordinatePerPoint;for(O=0;O<D;O++)if(X=M[O],!li.isClusterTerminator(X)){for(b[E++]=X,R=this.component(X,0)+v,M[O]=li.clusterTerminator,Y=O+1;Y<D;Y++)if(z=M[Y],z!==li.clusterTerminator){if(this.component(z,0)>=R)break;this.distanceBetweenSubBlocks(X,z,1,N)<v&&(b[E++]=z,M[Y]=li.clusterTerminator)}b[E++]=li.clusterTerminator}return b.slice(0,E)}setupPrimaryClusterSort(){const v=this.numBlocks,M=this._numCoordinatePerPoint,b=new Float64Array(M);b[0]=1;for(let z=1;z<M;z++)b[z]=b[z-1]*li._vectorFactor;let E=0,D=0;const X=this._data;for(let z=0;z<v;z++){E=this.blockIndexToDoubleIndex(z),D=0;for(let v=0;v<M;v++)D+=b[v]*X[E+1+v];X[E]=D}}toJSON(){const v=[];for(let M=0;M<this.numBlocks;M++){let b=this.blockIndexToDoubleIndex(M);const E=[M,this._data[b++]],D=[];for(let v=0;v<this._numCoordinatePerPoint;v++)D.push(this._data[b++]);E.push(D);for(let v=0;v<this._numExtraDataPerPoint;v++)E.push(this._data[b++]);v.push(E)}return v}createIndexBlockToClusterIndex(v){const M=this.numBlocks,b=new Uint32Array(M);b.fill(li.clusterTerminator);let E=0;for(const D of v)D>=M?E++:b[D]=E;return b}createIndexBlockToClusterStart(v){const M=v.length,b=this.numBlocks,E=new Uint32Array(b),D=li.clusterTerminator;E.fill(D);let X=0;for(let z=0;z<M;z++){const M=v[z];M>b?X=z+1:E[M]=X}return E}countClusters(v){let M=0;const b=li.clusterTerminator;for(const E of v)E===b&&M++;return M}createIndexClusterToClusterStart(v){let M=this.countClusters(v);const b=new Uint32Array(M),E=li.clusterTerminator;b.fill(E);const D=v.length;let X=0;for(let z=0;z<D;z++)v[z]===E?X=z+1:z===X&&(b[M++]=X);return b}sortSubsetsBySingleKey(v,M){const b=1+M;let E,D,X,z=0;const R=v.length;for(let O=0;O<R;O++)if(v[O]===li.clusterTerminator){for(let M=z;M+1<O;M++){D=this.getWithinBlock(v[M],b);for(let z=M+1;z<O;z++)X=this.getWithinBlock(v[z],b),X<D&&(E=v[M],v[M]=v[z],v[z]=E,D=X)}z=O+1}}static clusterPoint3dArray(v,M=K.smallMetricDistance){const b=new li(3,0,v.length);v.forEach((v=>{b.addDirect(v.x,v.y,v.z)}));const E=b.clusterIndicesLexical(M),D=new ui(v.length);let X=0,z=0;return E.forEach((M=>{li.isClusterTerminator(M)?(X++,z=0):(0===z&&D.packedPoints.push(v[M].clone()),D.oldToNew[M]=X,z++)})),D}static clusterNumberArray(v,M=K.smallMetricDistance){const b=new li(1,0,v.length);v.forEach((v=>{b.addDirect(v)}));const E=b.clusterIndicesLexical(M),D=new gi(v.length);let X=0,z=0;return E.forEach((M=>{li.isClusterTerminator(M)?(X++,z=0):(0===z&&D.packedNumbers.push(v[M]),D.oldToNew[M]=X,z++)})),D}static clusterGrowablePoint2dArray(v,M=K.smallMetricDistance){const b=new li(2,0,v.length),E=H.create(),D=v.length;for(let N=0;N<D;N++)v.getPoint2dAtUncheckedPointIndex(N,E),b.addDirect(E.x,E.y);const X=b.clusterIndicesLexical(M),z=b.countClusters(X),R=new fi(v.length,z);let O=0,Y=0;return X.forEach((M=>{li.isClusterTerminator(M)?(O++,Y=0):(0===Y&&R.growablePackedPoints.pushFromGrowableXYArray(v,M),R.oldToNew[M]=O,Y++)})),R}static clusterGrowablePoint3dArray(v,M=K.smallMetricDistance){const b=new li(3,0,v.length),E=Q.create(),D=v.length;for(let N=0;N<D;N++)v.getPoint3dAtUncheckedPointIndex(N,E),b.addDirect(E.x,E.y,E.z);const X=b.clusterIndicesLexical(M),z=new ui(v.length),R=b.countClusters(X);z.growablePackedPoints=new nt(R);let O=0,Y=0;return X.forEach((M=>{li.isClusterTerminator(M)?(O++,Y=0):(0===Y&&z.growablePackedPoints.pushFromGrowableXYZArray(v,M),z.oldToNew[M]=O,Y++)})),z}}function di(v,M){let b=0;return v.forEach(((v,E,D)=>{v<M.length?D[E]=M[v]:b++})),0===b}li._vectorFactor=.8732,li.clusterTerminator=4294967295;class ui{constructor(v){this.packedPoints=[],this.oldToNew=new Uint32Array(v);for(let M=0;M<v;M++)this.oldToNew[M]=ui.invalidIndex}updateIndices(v){return di(v,this.oldToNew)}}ui.invalidIndex=4294967295;class fi{constructor(v,M){this.growablePackedPoints=new Te(M),this.oldToNew=new Uint32Array(v);for(let b=0;b<v;b++)this.oldToNew[b]=fi.invalidIndex}updateIndices(v){return di(v,this.oldToNew)}}fi.invalidIndex=4294967295;class gi{constructor(v){this.packedNumbers=[],this.oldToNew=new Uint32Array(v);for(let M=0;M<v;M++)this.oldToNew[M]=ui.invalidIndex}updateIndices(v){return di(v,this.oldToNew)}}gi.invalidIndex=4294967295,function(v){v[v.Scalar=0]="Scalar",v[v.Distance=1]="Distance",v[v.Vector=2]="Vector",v[v.Normal=3]="Normal"}(Fr||(Fr={}));class pi{constructor(v,M){if(this.input=v,M instanceof Float64Array){this.values=[];for(const v of M)this.values.push(v)}else this.values=M}copyValues(v,M,b,E){for(let D=0;D<E;D++)this.values[M*E+D]=v.values[b*E+D]}clone(){return new pi(this.input,this.values.slice())}isAlmostEqual(v,M){const b=M||1e-8;return Math.abs(this.input-v.input)<b&&he.isAlmostEqual(this.values,v.values,b)}}class mi{constructor(v,M,b,E){this.data=v,this.dataType=M,this.name=b,this.inputName=E}clone(){const v=[];for(const M of this.data)v.push(M.clone());return new mi(v,this.dataType,this.name,this.inputName)}isAlmostEqual(v,M){if(this.dataType!==v.dataType||this.name!==v.name||this.inputName!==v.inputName||this.data.length!==v.data.length)return!1;for(let b=0;b<this.data.length;b++)if(!this.data[b].isAlmostEqual(v.data[b],M))return!1;return!0}get isScalar(){return this.dataType===Fr.Distance||this.dataType===Fr.Scalar}get entriesPerValue(){return this.isScalar?1:3}get valueCount(){return 0===this.data.length?0:this.data[0].values.length/this.entriesPerValue}get scalarRange(){if(!this.isScalar)return;const v=ft.createNull();for(const M of this.data)v.extendArray(M.values);return v}computeDisplacementRange(v=1,M){if(M=ut.createNull(M),Fr.Vector===this.dataType)for(const b of this.data){const E=b.values;for(let b=0;b<E.length;b+=3)M.extendXYZ(E[b]*v,E[b+1]*v,E[b+2]*v)}return M}}class xi{constructor(v,M){this.channels=v,this.indices=M}clone(){const v=this.channels.map((v=>v.clone()));return new xi(v,this.indices.slice())}isAlmostEqual(v,M){if(!he.isExactEqual(this.indices,v.indices)||this.channels.length!==v.channels.length)return!1;for(let b=0;b<this.channels.length;b++)if(!this.channels[b].isAlmostEqual(v.channels[b],M))return!1;return!0}static isAlmostEqual(v,M,b){return v===M||!(!v||!M)&&v.isAlmostEqual(M,b)}createForVisitor(){const v=[];for(const M of this.channels){const b=[];for(const v of M.data)b.push(new pi(v.input,[]));v.push(new mi(b,M.dataType,M.name,M.inputName))}return new xi(v,[])}tryTransformInPlace(v){let M;const b=v.matrix,E=b.determinant(),D=Math.pow(Math.abs(E),1/3)*(E>=0?1:-1);for(const X of this.channels)for(const v of X.data)switch(X.dataType){case Fr.Scalar:continue;case Fr.Distance:for(let M=0;M<v.values.length;M++)v.values[M]*=D;break;case Fr.Normal:if(M=M??b.inverse(),!M)return!1;yi(v.values,(v=>M.multiplyTransposeVectorInPlace(v)));break;case Fr.Vector:yi(v.values,(v=>b.multiplyVectorInPlace(v)))}return!0}}function yi(v,M){const b=new Q;for(let E=0;E<v.length;E+=3)b.set(v[E],v[E+1],v[E+2]),M(b),v[E]=b.x,v[E+1]=b.y,v[E+2]=b.z}!function(v){let M,b,E;!function(v){v[v.SubdivisionSurface=-1e3]="SubdivisionSurface"}(M=v.TaggedNumericTagType||(v.TaggedNumericTagType={})),function(v){v[v.ChooseBasedOnFacets=0]="ChooseBasedOnFacets",v[v.CatmullClark=1]="CatmullClark",v[v.Loop=2]="Loop",v[v.DooSabin=3]="DooSabin"}(b=v.SubdivisionMethod||(v.SubdivisionMethod={})),function(v){v[v.FixedDepth=-100]="FixedDepth",v[v.AbsoluteTolerance=-101]="AbsoluteTolerance",v[v.FractionOfRangeBoxTolerance=-102]="FractionOfRangeBoxTolerance"}(E=v.SubdivisionControlCode||(v.SubdivisionControlCode={}))}(Xr||(Xr={}));class _i{constructor(v=0,M=0,b,E){this.tagA=v,this.tagB=M,b&&(this.intData=b),E&&(this.doubleData=E)}pushIntPair(v,M){this.intData||(this.intData=[]),this.intData.push(v),this.intData.push(M)}pushIndexedDouble(v,M){this.intData||(this.intData=[]),this.doubleData||(this.doubleData=[]),this.intData.push(v),this.intData.push(this.doubleData.length),this.doubleData.push(M)}tagToInt(v,M,b,E){if(this.intData)for(let D=0;D+1<this.intData.length;D+=2)if(this.intData[D]===v)return Math.min(Math.max(this.intData[D+1],M),b);return E}tagToIndexedDouble(v,M,b,E){if(this.intData)for(let D=0;D+1<this.intData.length;D+=2)if(this.intData[D]===v)return K.clamp(this.getDoubleData(this.intData[D+1],E),M,b);return E}getDoubleData(v,M){return this.doubleData&&0<=v&&v<this.doubleData.length?this.doubleData[v]:M}isAlmostEqual(v){return void 0!==v&&this.tagA===v.tagA&&this.tagB===v.tagB&&K.exactEqualNumberArrays(this.intData,v.intData)&&K.almostEqualArrays(this.doubleData,v.doubleData,((v,M)=>K.isAlmostEqualNumber(v,M)))}static areAlmostEqual(v,M){return void 0===v&&void 0===M||void 0!==v&&void 0!==M&&v.isAlmostEqual(M)}clone(v){return v||(v=new _i(this.tagA,this.tagB)),this.intData&&(v.intData=this.intData.slice()),this.doubleData&&(v.doubleData=this.doubleData.slice()),v}}class vi{get twoSided(){return this._twoSided}set twoSided(v){this._twoSided=v}setTaggedNumericData(v){this.taggedNumericData=v}get expectedClosure(){return this._expectedClosure}set expectedClosure(v){this._expectedClosure=v}constructor(v=!1,M=!1,b=!1,E=!1){this.face=[],this.point=new nt,this.pointIndex=[],this.edgeVisible=[],v&&(this.normal=new nt,this.normalIndex=[]),M&&(this.param=new Te,this.paramIndex=[]),b&&(this.color=[],this.colorIndex=[]),this._twoSided=E,this._expectedClosure=0}clone(){const v=new vi;return v.point=this.point.clone(),v.pointIndex=this.pointIndex.slice(),v.edgeVisible=this.edgeVisible.slice(),v.face=this.face.slice(),v.twoSided=this.twoSided,v.expectedClosure=this.expectedClosure,this.normal&&(v.normal=this.normal.clone()),this.param&&(v.param=this.param.clone()),this.color&&(v.color=this.color.slice()),this.normalIndex&&(v.normalIndex=this.normalIndex.slice()),this.paramIndex&&(v.paramIndex=this.paramIndex.slice()),this.colorIndex&&(v.colorIndex=this.colorIndex.slice()),this.auxData&&(v.auxData=this.auxData.clone()),this.taggedNumericData&&(v.taggedNumericData=this.taggedNumericData.clone()),v}isAlmostEqual(v){return!!(nt.isAlmostEqual(this.point,v.point)&&he.isExactEqual(this.pointIndex,v.pointIndex)&&nt.isAlmostEqual(this.normal,v.normal)&&he.isExactEqual(this.normalIndex,v.normalIndex)&&Te.isAlmostEqual(this.param,v.param)&&he.isExactEqual(this.paramIndex,v.paramIndex)&&he.isExactEqual(this.color,v.color)&&he.isExactEqual(this.colorIndex,v.colorIndex)&&he.isExactEqual(this.edgeVisible,v.edgeVisible)&&xi.isAlmostEqual(this.auxData,v.auxData)&&this.twoSided===v.twoSided&&this.expectedClosure===v.expectedClosure&&_i.areAlmostEqual(this.taggedNumericData,v.taggedNumericData))}get requireNormals(){return void 0!==this.normal}get pointCount(){return this.point.length}get normalCount(){return this.normal?this.normal.length:0}get paramCount(){return this.param?this.param.length:0}get colorCount(){return this.color?this.color.length:0}get indexCount(){return this.pointIndex.length}get faceCount(){return this.face.length}getPoint(v,M){return this.point.getPoint3dAtCheckedPointIndex(v,M)}getNormal(v){return this.normal?this.normal.getVector3dAtCheckedVectorIndex(v):void 0}getParam(v){return this.param?this.param.getPoint2dAtCheckedPointIndex(v):void 0}getColor(v){return this.color?this.color[v]:0}getEdgeVisible(v){return this.edgeVisible[v]}copyPointTo(v,M){this.point.getPoint3dAtUncheckedPointIndex(v,M)}copyNormalTo(v,M){this.normal&&this.normal.getVector3dAtCheckedVectorIndex(v,M)}copyParamTo(v,M){this.param&&this.param.getPoint2dAtCheckedPointIndex(v,M)}isAlmostEqualParamIndexUV(v,M,b){return void 0!==this.param&&v>=0&&v<this.param.length&&K.isSameCoordinate(M,this.param.getXAtUncheckedPointIndex(v))&&K.isSameCoordinate(b,this.param.getYAtUncheckedPointIndex(v))}gatherIndexedData(v,M,b,E){const D=b-M,X=D+E;this.resizeAllDataArrays(X);for(let z=0;z<D;z++)this.point.transferFromGrowableXYZArray(z,v.point,v.pointIndex[M+z]);for(let z=0;z<E;z++)this.point.transferFromGrowableXYZArray(D+z,this.point,z);for(let z=0;z<D;z++)this.pointIndex[z]=v.pointIndex[M+z];for(let z=0;z<E;z++)this.pointIndex[D+z]=this.pointIndex[z];for(let z=0;z<D;z++)this.edgeVisible[z]=v.edgeVisible[M+z];for(let z=0;z<E;z++)this.edgeVisible[D+z]=this.edgeVisible[z];if(this.normal&&this.normalIndex&&v.normal&&v.normalIndex){for(let b=0;b<D;b++)this.normal.transferFromGrowableXYZArray(b,v.normal,v.normalIndex[M+b]);for(let v=0;v<E;v++)this.normal.transferFromGrowableXYZArray(D+v,this.normal,v);for(let b=0;b<D;b++)this.normalIndex[b]=v.normalIndex[M+b];for(let v=0;v<E;v++)this.normalIndex[D+v]=this.normalIndex[v]}if(this.param&&this.paramIndex&&v.param&&v.paramIndex){for(let b=0;b<D;b++)this.param.transferFromGrowableXYArray(b,v.param,v.paramIndex[M+b]);for(let v=0;v<E;v++)this.param.transferFromGrowableXYArray(D+v,this.param,v);for(let b=0;b<D;b++)this.paramIndex[b]=v.paramIndex[M+b];for(let v=0;v<E;v++)this.paramIndex[D+v]=this.paramIndex[v]}if(this.color&&this.colorIndex&&v.color&&v.colorIndex){for(let b=0;b<D;b++)this.color[b]=v.color[v.colorIndex[M+b]];for(let v=0;v<E;v++)this.color[D+v]=this.color[v];for(let b=0;b<D;b++)this.colorIndex[b]=v.colorIndex[M+b];for(let v=0;v<E;v++)this.colorIndex[D+v]=this.colorIndex[v]}if(this.auxData&&v.auxData&&this.auxData.channels.length===v.auxData.channels.length){for(let b=0;b<this.auxData.channels.length;b++){const X=this.auxData.channels[b],z=v.auxData.channels[b],R=X.entriesPerValue;if(X.data.length===z.data.length)for(let b=0;b<X.data.length;b++){const O=X.data[b],Y=z.data[b];for(let b=0;b<D;b++)O.copyValues(Y,b,v.auxData.indices[M+b],R);for(let M=0;M<E;M++)O.copyValues(O,v.auxData.indices[D+M],M,R)}}for(let b=0;b<D;b++)this.auxData.indices[b]=v.auxData.indices[M+b];for(let v=0;v<E;v++)this.auxData.indices[D+v]=this.auxData.indices[v]}}static trimArray(v,M){v&&M<v.length&&(v.length=M)}trimAllIndexArrays(v){if(vi.trimArray(this.pointIndex,v),vi.trimArray(this.paramIndex,v),vi.trimArray(this.normalIndex,v),vi.trimArray(this.colorIndex,v),vi.trimArray(this.edgeVisible,v),this.auxData){vi.trimArray(this.auxData.indices,v);for(const M of this.auxData.channels)for(const b of M.data)vi.trimArray(b.values,M.entriesPerValue*v)}}resizeAllDataArrays(v){if(v>this.point.length){for(;this.point.length<v;)this.point.push(Q.create());for(;this.pointIndex.length<v;)this.pointIndex.push(-1);for(;this.edgeVisible.length<v;)this.edgeVisible.push(!1);if(this.normal)for(;this.normal.length<v;)this.normal.push($.create());if(this.param)for(;this.param.length<v;)this.param.push(H.create());if(this.color)for(;this.color.length<v;)this.color.push(0);if(this.auxData)for(const M of this.auxData.channels)for(const b of M.data)for(;b.values.length<v*M.entriesPerValue;)b.values.push(0)}else if(v<this.point.length&&(this.point.resize(v),this.edgeVisible.length=v,this.pointIndex.length=v,this.normal&&this.normal.resize(v),this.param&&this.param.resize(v),this.color&&(this.color.length=v),this.auxData))for(const M of this.auxData.channels)for(const b of M.data)b.values.length=v*M.entriesPerValue}range(v,M){return(v=v||ut.createNull()).extendArray(this.point,M),v}reverseIndices(v){v&&vi.isValidFacetStartIndexArray(v)&&(vi.reverseIndices(v,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&vi.reverseIndices(v,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&vi.reverseIndices(v,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&vi.reverseIndices(v,this.colorIndex,!0),vi.reverseIndices(v,this.edgeVisible,!1))}reverseIndicesSingleFacet(v,M){vi.reverseIndicesSingleFacet(v,M,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&vi.reverseIndicesSingleFacet(v,M,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&vi.reverseIndicesSingleFacet(v,M,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&vi.reverseIndicesSingleFacet(v,M,this.colorIndex,!0),vi.reverseIndicesSingleFacet(v,M,this.edgeVisible,!1)}reverseNormals(){this.normal&&this.normal.scaleInPlace(-1)}tryTransformInPlace(v){return this.point.multiplyTransformInPlace(v),this.normal&&!v.matrix.isIdentity&&this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(v.matrix),void 0===this.auxData||this.auxData.tryTransformInPlace(v)}compress(v=K.smallMetricDistance){const M=li.clusterGrowablePoint3dArray(this.point,v);if(this.point=M.growablePackedPoints,M.updateIndices(this.pointIndex),this.normalIndex&&this.normal){const v=li.clusterGrowablePoint3dArray(this.normal);this.normal=v.growablePackedPoints,v.updateIndices(this.normalIndex)}if(this.paramIndex&&this.param){const v=li.clusterGrowablePoint2dArray(this.param);this.param=v.growablePackedPoints,v.updateIndices(this.paramIndex)}if(this.colorIndex&&this.color){const v=li.clusterNumberArray(this.color);this.color=v.packedNumbers,v.updateIndices(this.colorIndex)}}static isValidFacetStartIndexArray(v){if(0===v.length)return!1;for(let M=0;M+1<v.length;M++)if(v[M]>=v[M+1])return!1;return!0}static reverseIndices(v,M,b){if(!M||0===M.length)return!0;if(M.length>0&&v[v.length-1]===M.length){for(let E=0;E+1<v.length;E++){let D=v[E],X=v[E+1];if(b)for(;X>D+2;){X--,D++;const v=M[D];M[D]=M[X],M[X]=v}else for(;X>D+1;){X--;const v=M[D];M[D]=M[X],M[X]=v,D++}}return!0}return!1}static reverseIndicesSingleFacet(v,M,b,E){if(!b||0===b.length)return!0;if(b.length>0&&M[M.length-1]===b.length&&v>=0&&v+1<M.length){let D=M[v],X=M[v+1];if(E)for(;X>D+2;){X--,D++;const v=b[D];b[D]=b[X],b[X]=v}else for(;X>D+1;){X--;const v=b[D];b[D]=b[X],b[X]=v,D++}return!0}return!1}}vi.planarityLocalRelTol=1e-13;class Pi extends vi{constructor(v,M){super(v.data.normalCount>0,v.data.paramCount>0,v.data.colorCount>0,v.twoSided),this._polyface=v,this._numWrap=M,v.data.auxData&&(this.auxData=v.data.auxData.createForVisitor()),this.reset(),this._numEdges=0,this._nextFacetIndex=0,this._currentFacetIndex=-1}clientPolyface(){return this._polyface}setNumWrap(v){this._numWrap=v}get numEdgesThisFacet(){return this._numEdges}static create(v,M){return new Pi(v,M)}moveToReadIndex(v){return!!this._polyface.isValidFacetIndex(v)&&(this._currentFacetIndex=v,this._nextFacetIndex=v+1,this._numEdges=this._polyface.numEdgeInFacet(v),this.resizeAllDataArrays(this._numEdges+this._numWrap),this.gatherIndexedData(this._polyface.data,this._polyface.facetIndex0(this._currentFacetIndex),this._polyface.facetIndex1(this._currentFacetIndex),this._numWrap),!0)}moveToNextFacet(){return this._nextFacetIndex!==this._currentFacetIndex?this.moveToReadIndex(this._nextFacetIndex):(this._nextFacetIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextFacetIndex=0}tryGetDistanceParameter(v,M){if(v>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const b=this._polyface.tryGetFaceData(this._currentFacetIndex);return b?b.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(v),this.param.getYAtUncheckedPointIndex(v),M):void 0}tryGetNormalizedParameter(v,M){if(v>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const b=this._polyface.tryGetFaceData(this._currentFacetIndex);return b?b.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(v),this.param.getYAtUncheckedPointIndex(v),M):void 0}currentReadIndex(){return this._currentFacetIndex}clientPointIndex(v){return this.pointIndex[v]}clientParamIndex(v){return this.paramIndex?this.paramIndex[v]:-1}clientNormalIndex(v){return this.normalIndex?this.normalIndex[v]:-1}clientColorIndex(v){return this.colorIndex?this.colorIndex[v]:-1}clientAuxIndex(v){return this.auxData?this.auxData.indices[v]:-1}clearArrays(){void 0!==this.point&&(this.point.length=0),void 0!==this.param&&(this.param.length=0),void 0!==this.normal&&(this.normal.length=0),void 0!==this.color&&(this.color.length=0)}pushDataFrom(v,M){this.point.pushFromGrowableXYZArray(v.point,M),this.color&&v.color&&M<v.color.length&&this.color.push(v.color[M]),this.param&&v.param&&M<v.param.length&&this.param.pushFromGrowableXYArray(v.param,M),this.normal&&v.normal&&M<v.normal.length&&this.normal.pushFromGrowableXYZArray(v.normal,M)}pushInterpolatedDataFrom(v,M,b,E){this.point.pushInterpolatedFromGrowableXYZArray(v.point,M,b,E),this.color&&v.color&&M<v.color.length&&E<v.color.length&&this.color.push(function(v,M,b){return Ii(v,M=K.clamp(M,0,1),b,0)|Ii(v,M,b,8)|Ii(v,M,b,16)|Ii(v,M,b,24)}(v.color[M],b,v.color[E])),this.param&&v.param&&M<v.param.length&&E<v.param.length&&this.param.pushInterpolatedFromGrowableXYArray(v.param,M,b,E),this.normal&&v.normal&&M<v.normal.length&&E<v.normal.length&&this.normal.pushInterpolatedFromGrowableXYZArray(v.normal,M,b,E)}}function Ii(v,M,b,E){return v=v>>>E&255,b=b>>>E&255,(255&Math.floor(v+M*(b-v)))<<E}class Ai extends Pi{constructor(v,M,b){super(v,b),this._parentFacetIndices=M.slice(),this._nextActiveIndex=0}static createSubsetVisitor(v,M,b){return new Ai(v,M,b)}moveToReadIndex(v){return v>=0&&v<=this._parentFacetIndices.length&&(this._nextActiveIndex=v,super.moveToReadIndex(this._parentFacetIndices[v++]))}moveToNextFacet(){return!!(this._nextActiveIndex<this._parentFacetIndices.length&&this.moveToReadIndex(this._nextActiveIndex))&&(this._nextActiveIndex++,!0)}reset(){this._nextActiveIndex=0}parentFacetIndex(v){if(v>=0&&v<=this._nextActiveIndex)return this._parentFacetIndices[v]}}class Si{get paramDistanceRange(){return this._paramDistanceRange}get paramRange(){return this._paramRange}constructor(v,M){this._paramDistanceRange=v,this._paramRange=M}static createNull(){return new Si(gt.createNull(),gt.createNull())}clone(v){return v?(this._paramDistanceRange.clone(v._paramDistanceRange),this._paramRange.clone(v._paramRange),v):new Si(this._paramDistanceRange.clone(),this._paramRange.clone())}setNull(){this._paramDistanceRange.setNull(),this._paramRange.setNull()}convertParamXYToDistance(v,M,b){b=b||H.create();const E=this._paramRange.high.minus(this._paramRange.low);return b.x=0===E.x?v:this._paramDistanceRange.low.x+(v-this._paramRange.low.x)*(this._paramDistanceRange.high.x-this._paramDistanceRange.low.x)/E.x,b.y=0===E.y?M:this.paramDistanceRange.low.y+(M-this._paramRange.low.y)*(this._paramDistanceRange.high.y-this._paramDistanceRange.low.y)/E.y,b}convertParamXYToNormalized(v,M,b){b=b||H.create();const E=this._paramRange.high.minus(this._paramRange.low);return b.x=0===E.x?v:(v-this._paramRange.low.x)/E.x,b.y=0===E.y?M:(M-this._paramRange.low.y)/E.y,b}convertParamToDistance(v,M){return this.convertParamXYToDistance(v.x,v.y,M)}convertParamToNormalized(v,M){return this.convertParamXYToNormalized(v.x,v.y,M)}scaleDistances(v){this._paramDistanceRange.low.x*=v,this._paramDistanceRange.low.y*=v,this._paramDistanceRange.high.x*=v,this._paramDistanceRange.high.y*=v}setParamDistanceRangeFromNewFaceData(v,M,b){const E=H.create(),D=H.create();this.setNull();let X=0;const z=Pi.create(v,0);if(!z.moveToReadIndex(M)||b<=M)return!1;do{const v=z.numEdgesThisFacet,M=z.point,b=[],R=z.param,O=[];if(!R)return!1;R.extendRange(this._paramRange);const Y=J.create(),N=J.create();for(let z=0;z<v;z++){if(b[2]=z,O[2]=z,z>1){R.vectorIndexIndex(O[1],O[0],Y),R.vectorIndexIndex(O[1],O[2],N);const v=M.getPoint3dAtUncheckedPointIndex(b[0]).minus(M.getPoint3dAtUncheckedPointIndex(b[1])),z=M.getPoint3dAtUncheckedPointIndex(b[1]).minus(M.getPoint3dAtUncheckedPointIndex(b[2])),B=Math.abs(Y.x*N.y-N.x*Y.y);if(B){const M=Q.createFrom(v);M.scaleInPlace(N.y),M.addScaledInPlace(z,-Y.y);const b=Q.createFrom(z);b.scaleInPlace(Y.x),b.addScaledInPlace(v,-N.x);const R=H.create(M.magnitude()/B,b.magnitude()/B);E.x+=R.x,E.y+=R.y,D.x+=R.x*R.x,D.y+=R.y*R.y,X++}}O[0]=O[1],O[1]=O[2],b[0]=b[1],b[1]=b[2]}}while(z.moveToNextFacet()&&z.currentReadIndex()<b);if(0!==X){const v=H.create(E.x/X,E.y/X),M=H.create(Math.sqrt(Math.abs(D.x/X-v.x*v.x)),Math.sqrt(Math.abs(D.y/X-v.y*v.y)));this._paramDistanceRange.low.set(0,0),this._paramDistanceRange.high.set((v.x+M.x)*(this._paramRange.high.x-this._paramRange.low.x),(v.y+M.y)*(this._paramRange.high.y-this._paramRange.low.y))}return!0}}class wi extends Nt{constructor(v){super(),this.geometryCategory="polyface",this.data=v}get twoSided(){return this.data.twoSided}set twoSided(v){this.data.twoSided=v}get expectedClosure(){return this.data.expectedClosure}set expectedClosure(v){this.data.expectedClosure=v}static areIndicesValid(v,M,b,E,D){if(void 0===v&&void 0===E)return!0;if(!v||!E)return!1;if(M<0||M>=v.length)return!1;if(b<M||b>v.length)return!1;for(let X=M;X<b;X++)if(v[X]<0||v[X]>=D)return!1;return!0}get facetCount(){}}class Ci extends wi{isSameGeometryClass(v){return v instanceof Ci}isAlmostEqual(v){return v instanceof Ci&&this.data.isAlmostEqual(v.data)&&he.isExactEqual(this._facetStart,v._facetStart)&&he.isExactEqual(this._facetToFaceData,v._facetToFaceData)}get isEmpty(){return 0===this.data.pointCount||0===this.data.pointIndex.length}tryTransformInPlace(v){return!!this.data.tryTransformInPlace(v)&&(v.matrix.determinant()<0&&(this.reverseIndices(),this.reverseNormals()),!0)}reverseSingleFacet(v){this.data.reverseIndicesSingleFacet(v,this._facetStart)}clone(){return new Ci(this.data.clone(),this._facetStart.slice(),this._facetToFaceData.slice())}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}reverseIndices(){this.data.reverseIndices(this._facetStart)}reverseNormals(){this.data.reverseNormals()}tryGetFaceData(v){const M=this._facetToFaceData[v];if(!(M>=this.data.face.length))return this.data.face[M]}constructor(v,M,b){super(v),M?this._facetStart=M.slice():(this._facetStart=[],this._facetStart.push(0)),this._facetToFaceData=b?b.slice():[]}addIndexedPolyface(v,M,b){const E=v.facetCount,D=this.data.point.length,X=Q.create();for(let z=0;z<v.data.point.length;z++)v.data.point.getPoint3dAtUncheckedPointIndex(z,X),b?(b.multiplyPoint3d(X,X),this.addPoint(X)):this.addPoint(X);for(let z=0;z<E;z++){const b=v._facetStart[z],E=v._facetStart[z+1];if(M)for(let M=E;M-- >b;)this.addPointIndex(D+v.data.pointIndex[M],v.data.edgeVisible[M>b?M-1:E-1]);else for(let M=b;M<E;M++)this.addPointIndex(D+v.data.pointIndex[M],v.data.edgeVisible[M]);this.terminateFacet(!1)}if(void 0!==this.data.param&&void 0!==v.data.param&&void 0!==v.data.paramIndex){const b=this.data.param.length;this.data.param.pushFromGrowableXYArray(v.data.param);for(let D=0;D<E;D++){const E=v._facetStart[D],X=v._facetStart[D+1];if(M)for(let M=X;M-- >E;)this.addParamIndex(b+v.data.paramIndex[M]);else for(let M=E;M<X;M++)this.addParamIndex(b+v.data.paramIndex[M])}}if(void 0!==this.data.normal&&void 0!==v.data.normal&&void 0!==v.data.normalIndex){const D=this.data.normal.length;for(let E=0;E<v.data.normal.length;E++){const D=v.data.normal.getVector3dAtCheckedVectorIndex(E);b&&b.multiplyVector(D,D),M&&D.scaleInPlace(-1),this.addNormal(D)}for(let b=0;b<E;b++){const E=v._facetStart[b],X=v._facetStart[b+1];if(M)for(let M=X;M-- >E;)this.addNormalIndex(D+v.data.normalIndex[M]);else for(let M=E;M<X;M++)this.addNormalIndex(D+v.data.normalIndex[M])}}if(void 0!==this.data.color&&void 0!==v.data.color&&void 0!==v.data.colorIndex){const b=this.data.color.length;for(const M of v.data.color)this.addColor(M);for(let D=0;D<E;D++){const E=v._facetStart[D],X=v._facetStart[D+1];if(M)for(let M=X;M-- >E;)this.addColorIndex(b+v.data.colorIndex[M]);else for(let M=E;M<X;M++)this.addColorIndex(b+v.data.colorIndex[M])}}if(0!==v.data.face.length){const M=this.data.face.length;for(const b of v.data.face){const v=b.clone();this.data.face.push(v)}for(const b of v._facetToFaceData)this._facetToFaceData.push(M+b)}}get zeroTerminatedIndexCount(){return this.data.pointIndex.length+this._facetStart.length-1}static create(v=!1,M=!1,b=!1,E=!1){return new Ci(new vi(v,M,b,E))}addPoint(v,M){if(void 0!==M){const b=this.data.point.distanceIndexToPoint(M,v);if(void 0!==b&&K.isSmallMetricDistance(b))return M}return this.data.point.pushXYZ(v.x,v.y,v.z),this.data.point.length-1}addPointXYZ(v,M,b){return this.data.point.pushXYZ(v,M,b),this.data.point.length-1}addParam(v){return this.data.param||(this.data.param=new Te),this.data.param.push(v),this.data.param.length-1}addParamUV(v,M,b,E){return this.data.param||(this.data.param=new Te),void 0!==b&&this.data.isAlmostEqualParamIndexUV(b,v,M)?b:void 0!==E&&this.data.isAlmostEqualParamIndexUV(E,v,M)?E:(this.data.param.pushXY(v,M),this.data.param.length-1)}addNormal(v,M,b){if(void 0!==this.data.normal){let E;if(void 0!==M&&(E=this.data.normal.distanceIndexToPoint(M,v),void 0!==E&&K.isSmallMetricDistance(E)))return M;if(void 0!==b&&(E=this.data.normal.distanceIndexToPoint(b,v),void 0!==E&&K.isSmallMetricDistance(E)))return b;if(void 0!==M||void 0!==b){const M=this.data.normal.length-1;if(E=this.data.normal.distanceIndexToPoint(M,v),void 0!==E&&K.isSmallMetricDistance(E))return M}}return this.addNormalXYZ(v.x,v.y,v.z)}addNormalXYZ(v,M,b){return this.data.normal||(this.data.normal=new nt),this.data.normal.pushXYZ(v,M,b),this.data.normal.length-1}addColor(v){return this.data.color||(this.data.color=[]),this.data.color.push(v),this.data.color.length-1}addPointIndex(v,M=!0){this.data.pointIndex.push(v),this.data.edgeVisible.push(M)}addNormalIndex(v){this.data.normalIndex||(this.data.normalIndex=[]),this.data.normalIndex.push(v)}addParamIndex(v){this.data.paramIndex||(this.data.paramIndex=[]),this.data.paramIndex.push(v)}addColorIndex(v){this.data.colorIndex||(this.data.colorIndex=[]),this.data.colorIndex.push(v)}cleanupOpenFacet(){this.data.trimAllIndexArrays(this.data.pointIndex.length)}terminateFacet(v=!0){const M=this._facetStart.length-1,b=this._facetStart[M],E=this.data.pointIndex.length;if(v){const v=[];if(E<b+2&&v.push("Less than 3 indices in open facet"),this.data.normalIndex&&this.data.normalIndex.length!==E&&v.push("normalIndex count must match pointIndex count"),this.data.paramIndex&&this.data.paramIndex.length!==E&&v.push("paramIndex count must equal pointIndex count"),this.data.colorIndex&&this.data.colorIndex.length!==E&&v.push("colorIndex count must equal pointIndex count"),this.data.edgeVisible.length!==E&&v.push("visibleIndex count must equal pointIndex count"),wi.areIndicesValid(this.data.normalIndex,b,E,this.data.normal,this.data.normal?this.data.normal.length:0)||v.push("invalid normal indices in open facet"),v.length>0)return this.cleanupOpenFacet(),v}this._facetStart.push(E)}get facetCount(){return this._facetStart.length-1}get faceCount(){return this.data.faceCount}get pointCount(){return this.data.pointCount}get colorCount(){return this.data.colorCount}get paramCount(){return this.data.paramCount}get normalCount(){return this.data.normalCount}numEdgeInFacet(v){return this.isValidFacetIndex(v)?this._facetStart[v+1]-this._facetStart[v]:0}isValidFacetIndex(v){return v>=0&&v+1<this._facetStart.length}facetIndex0(v){return this._facetStart[v]}facetIndex1(v){return this._facetStart[v+1]}createVisitor(v=0){return Pi.create(this,v)}range(v,M){return this.data.range(M,v)}extendRange(v,M){this.data.range(v,M)}getFaceDataByFacetIndex(v){return this.data.face[this._facetToFaceData[v]]}setNewFaceData(v=0){const M=this._facetToFaceData.length;if(M>=this._facetStart.length)return!1;0===v&&(v=this._facetStart.length);const b=Si.createNull(),E=Pi.create(this,0);if(!E.moveToReadIndex(M))return!1;const D=void 0!==this.data.param,X=b.paramRange.isNull&&D;do{X&&void 0!==E.param&&E.param.extendRange(b.paramRange)}while(E.moveToNextFacet()&&E.currentReadIndex()<v);D&&0!==this.data.param.length&&b.paramDistanceRange.isNull&&b.setParamDistanceRangeFromNewFaceData(this,M,v),this.data.face.push(b);const z=this.data.face.length-1;for(let R=this._facetToFaceData.length;R<v;R++)this._facetToFaceData.push(0===this._facetStart[R]?0:z);return!0}dispatchToGeometryHandler(v){return v.handleIndexedPolyface(this)}}class Ti{constructor(v,M,b,E,D,X){this.childFraction0=v,this.childFraction1=M,this.chainDistance0=b,this.chainDistance1=E,this.childCurve=D,this.range=X,this.a=0}containsChainDistance(v){return v>=this.chainDistance0&&v<=this.chainDistance1}quickMinDistanceToChildCurve(v){if(this.range)return this.range.distanceToPoint(v);const M=this.childCurve.closestPoint(v,!1);return M?M.a:0}static collectSortedQuickMinDistances(v,M){const b=[];for(const E of v)E.a=E.quickMinDistanceToChildCurve(M),b.push(E);return b.sort(((v,M)=>v.a-M.a)),b}containsChildCurveAndChildFraction(v,M){return this.childCurve===v&&M>=this.childFraction0&&M<=this.childFraction1}chainDistanceToInterpolatedChildFraction(v){return K.inverseInterpolate(this.childFraction0,this.chainDistance0,this.childFraction1,this.chainDistance1,v,this.childFraction0)}chainDistanceToAccurateChildFraction(v,M){return this.childCurve.moveSignedDistanceFromFraction(this.childFraction0,v-this.chainDistance0,M??!1).fraction}fractionScaleFactor(v){return v*(this.childFraction1-this.childFraction0)/(this.chainDistance1-this.chainDistance0)}reverseFractionsAndDistances(v){const M=this.childFraction0,b=this.childFraction1,E=this.chainDistance0,D=this.chainDistance1;this.childFraction0=1-b,this.childFraction1=1-M,this.chainDistance0=v-D,this.chainDistance1=v-E}childFractionTChainDistance(v){return this.childFractionToChainDistance(v)}childFractionToChainDistance(v){let M=this.childCurve.curveLengthBetweenFractions(this.childFraction0,v);return v<this.childFraction0&&(M=-M),this.chainDistance0+M}}class Fi{constructor(){this._accumulatedDistance=0,this._fragments=[]}startParentCurvePrimitive(v){}startCurvePrimitive(v){}endParentCurvePrimitive(v){}endCurvePrimitive(v){}announcePointTangent(v,M,b){}announceSegmentInterval(v,M,b,E,D,X){const z=M.clone(),R=b.clone();let O=this._accumulatedDistance;if(E<=1)this._accumulatedDistance+=M.distance(b),this._fragments.push(new Ti(D,X,O,this._accumulatedDistance,v,ut.create(z,R)));else{let Y;for(let N=1,B=D;N<=E;N++,B=Y)Y=K.interpolate(D,N/E,X),M.interpolate(Y,b,R),O=this._accumulatedDistance,this._accumulatedDistance+=Math.abs(Y-B)*M.distance(b),this._fragments.push(new Ti(B,Y,O,this._accumulatedDistance,v,ut.create(z,R))),z.setFrom(R)}}announceIntervalForUniformStepStrokes(v,M,b,E){let D,X,z;for(let R=1,O=b;R<=M;R++,O=D){D=K.interpolate(b,R/M,E),X=v.curveLengthBetweenFractions(O,D),z=this._accumulatedDistance,this._accumulatedDistance+=X;const Y=v.rangeBetweenFractions(O,D);this._fragments.push(new Ti(O,D,z,this._accumulatedDistance,v,Y))}}needPrimaryGeometryForStrokes(){return!0}static createPathFragmentIndex(v,M){const b=new Fi;for(const E of v.children)E.emitStrokableParts(b,M);return b._fragments}}class ki extends oe{isSameGeometryClass(v){return v instanceof ki}constructor(v,M){super(),this.curvePrimitiveType="curveChainWithDistanceIndex",this._path=v,this._fragments=M,this._totalLength=M.length>0?M[M.length-1].chainDistance1:0}cloneTransformed(v){const M=this._path.clone();if(M instanceof Ne&&M.tryTransformInPlace(v))return ki.createCapture(M)}get path(){return this._path}get fragments(){return this._fragments}clone(){const v=this._path.clone();return ki.createCapture(v)}clonePartialCurve(v,M){if(v===M)return;let b=v,E=M;const D=v>M;D&&(b=M,E=v);const X=b*this._totalLength,z=E*this._totalLength,R=this.chainDistanceToFragment(X,!0);if(void 0===R)return;const O=this.chainDistanceToFragment(z,!0);if(void 0===O)return;const Y=this._path.childIndex(R.childCurve,!0);if(void 0===Y)return;const N=this._path.childIndex(O.childCurve,!0);if(void 0===N)return;const B=R.chainDistanceToAccurateChildFraction(X,!0),V=O.chainDistanceToAccurateChildFraction(z,!0),L=Ve.create(),g=(v,M,b,E)=>{if(M===b)return!1;let D;return 0===M&&1===b?(D=v.clone(),E&&D.reverseInPlace()):D=E?v.clonePartialCurve(b,M):v.clonePartialCurve(M,b),!!D&&(L.children.push(D),!0)};if(R.childCurve===O.childCurve)return g(R.childCurve,B,V,D)?ki.createCapture(L):void 0;g(this._path.children[Y],B,1,D);for(let U=Y+1;U<N;U++)g(this._path.children[U],0,1,D);return g(this._path.children[N],0,V,D),D&&L.children.reverse(),ki.createCapture(L)}isInPlane(v){for(const M of this._path.children)if(!M.isInPlane(v))return!1;return!0}startPoint(v){const M=this._path.cyclicCurvePrimitive(0);return M?M.startPoint(v):Q.createZero(v)}endPoint(v){const M=this._path.cyclicCurvePrimitive(-1);return M?M.endPoint(v):Q.createZero(v)}emitStrokes(v,M){for(const b of this._path.children)b.emitStrokes(v,M)}emitStrokableParts(v,M){for(const b of this._path.children)b.emitStrokableParts(v,M)}computeStrokeCountForOptions(v){let M=0;for(const b of this._path.children)M+=b.computeStrokeCountForOptions(v);return M}collectCurvePrimitivesGo(v,M=!1,b=!1){if(M)for(const E of this._path.children)E.collectCurvePrimitivesGo(v,M,b);else v.push(this)}computeAndAttachRecursiveStrokeCounts(v,M){const b=zt.createWithCurvePrimitiveAndOptionalParent(this,M);for(const E of this._path.children)E.computeAndAttachRecursiveStrokeCounts(v,b);oe.installStrokeCountMap(this,b,M)}dispatchToGeometryHandler(v){return v.handleCurveChainWithDistanceIndex(this)}extendRange(v,M){this._path.extendRange(v,M)}curveLengthBetweenFractions(v,M){return Math.abs(M-v)*this._totalLength}static flattenNestedChains(v){if(-1===v.children.findIndex((v=>v instanceof ki)))return v;const M=v.clone(),b=M.children.flatMap((v=>v instanceof ki?v.path.children:[v]));return M.children.splice(0,1/0,...b),M}static createCapture(v,M){v=this.flattenNestedChains(v);const b=Fi.createPathFragmentIndex(v,M);return new ki(v,b)}chainDistanceToFragment(v,M=!1){const b=this.chainDistanceToFragmentIndex(v,M);if(void 0!==b)return this._fragments[b]}chainDistanceToFragmentIndex(v,M=!1){const b=this._fragments.length,E=this._fragments;if(b>0){if(v<0)return M?0:void 0;if(v>this._totalLength)return M?b-1:void 0;for(let M=0;M<b;M++)if(E[M].containsChainDistance(v))return M}}chainDistanceToChainFraction(v){return v/this._totalLength}curveAndChildFractionToFragment(v,M){const b=this._fragments.length,E=this._fragments;if(b>0){if(M<0)return E[0];if(M>1)return E[b-1];for(const b of E)if(b.containsChildCurveAndChildFraction(v,M))return b}}curveLength(){return this._totalLength}quickLength(){return this._totalLength}fractionToPoint(v,M){const b=v*this._totalLength,E=this.chainDistanceToFragment(b,!0);if(E){const v=E.chainDistanceToAccurateChildFraction(b,!0);return E.childCurve.fractionToPoint(v,M)}return e(!1),this._fragments[0].childCurve.fractionToPoint(0,M)}fractionToPointAndDerivative(v,M){const b=v*this._totalLength,E=this.chainDistanceToFragment(b,!0),D=E.chainDistanceToAccurateChildFraction(b,!0);M=E.childCurve.fractionToPointAndDerivative(D,M);const X=this._totalLength/M.direction.magnitude();return M.direction.scaleInPlace(X),M}fractionToPointAndUnitTangent(v,M){const b=v*this._totalLength,E=this.chainDistanceToFragment(b,!0),D=E.chainDistanceToAccurateChildFraction(b,!0);return(M=E.childCurve.fractionToPointAndDerivative(D,M)).direction.normalizeInPlace(),M}fractionToPointAnd2Derivatives(v,M){const b=v*this._totalLength,E=this.chainDistanceToFragment(b,!0),D=E.chainDistanceToAccurateChildFraction(b,!0);if(!(M=E.childCurve.fractionToPointAnd2Derivatives(D,M)))return;const X=M.vectorU.magnitude(),z=X*X,R=M.vectorU.dotProduct(M.vectorV);M.vectorV.addScaledInPlace(M.vectorU,-R/z);const O=this._totalLength/X;return M.vectorU.scaleInPlace(O),M.vectorV.scaleInPlace(O*O),M}tryTransformInPlace(v){let M=0;for(const b of this._path.children)b.tryTransformInPlace(v)||M++;return 0===M}reverseInPlace(){this._path.reverseChildrenInPlace();for(const v of this._fragments)v.reverseFractionsAndDistances(this._totalLength);this._fragments.reverse()}isAlmostEqual(v){return v instanceof ki&&K.isSameCoordinate(this._totalLength,v._totalLength)&&this._path.isAlmostEqual(v._path)}moveSignedDistanceFromFraction(v,M,b,E){const D=v*this._totalLength+M,X=this.chainDistanceToFragment(D,!0),z=X.childCurve.moveSignedDistanceFromFraction(X.childFraction0,D-X.chainDistance0,b,E),R=v+M/this._totalLength,O=vt.createConditionalMoveSignedDistance(b,this,v,R,M,E);return O.childDetail=z,O}static getClosestPointTestCounts(v=!0){const M={numCalls:this._numCalls,numTested:this._numTested,numAssigned:this._numAssigned,numCandidate:this._numCandidate};return v&&(this._numTested=this._numAssigned=this._numCandidate=0),M}closestPoint(v,M){let b,E=Number.MAX_VALUE;if(1===this.path.children.length)b=this.path.children[0].closestPoint(v,M);else{const D=Ti.collectSortedQuickMinDistances(this._fragments,v),X=[ee.resolveVariantCurveExtendParameterToCurveExtendMode(M,0),Cr.None],z=[Cr.None,ee.resolveVariantCurveExtendParameterToCurveExtendMode(M,1)],R=this._fragments[0],O=this._fragments[this._fragments.length-1];let Y;ki._numCalls++,ki._numCandidate+=D.length;for(const M of D){if(M.a>E)break;ki._numTested++,Y=M.childCurve.closestPoint(v,M===R?X:M===O&&z,Y),Y&&Y.a<E&&(E=Y.a,b=Y.clone(b),ki._numAssigned++)}}if(b)return this.computeChainDetail(b)}constructOffsetXY(v){const M=Se.create(v),b=[];for(const E of this.collectCurvePrimitives(void 0,!0,!0)){const v=E.constructOffsetXY(M);void 0!==v&&(v instanceof oe?b.push(v):Array.isArray(v)&&v.forEach((v=>b.push(v))))}return b}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}computeChainDetail(v){if(!v.curve)return;const M=this.curveAndChildFractionToFragment(v.curve,v.fraction);if(M){const b=M.childFractionToChainDistance(v.fraction),E=this.chainDistanceToChainFraction(b),D=vt.createCurveFractionPoint(this,E,v.point);return D.childDetail=v,D.a=v.a,D}}static convertChildDetailToChainDetail(v,M,b,E,D){for(let X=M;X<v.length;++X){const M=v[X];if(b){const v=b.computeChainDetail(M.detailA);v&&(M.detailA=v)}if(E){const v=E.computeChainDetail(M.detailB);v&&(M.detailB=v)}}return D&&(v=Pt.removeAdjacentDuplicates(v,M)),v}}ki._numCalls=0,ki._numTested=0,ki._numAssigned=0,ki._numCandidate=0;class Mi extends Ze{setGeometryB(v){if(this._geometryB=v,this._circularArcB=void 0,this._circularRadiusB=void 0,v instanceof ti){const M=v.circularRadiusXY();void 0!==M&&(this._circularRadiusB=M,this._circularArcB=v)}}constructor(v){super(),this.setGeometryB(v),this._maxDistanceSquared=K.smallMetricDistanceSquared,this._results=[]}set maxDistanceToAccept(v){this._maxDistanceToAccept=v,void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0&&(this._maxDistanceSquared=this._maxDistanceToAccept*this._maxDistanceToAccept)}get maxDistanceToAccept(){return this._maxDistanceToAccept}get isMaxDistanceSet(){return void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0}resetGeometry(v){this.setGeometryB(v)}acceptFraction(v,M=1e-12){return!(v<-M||v>1+M)}grabPairedResults(v=!1){const M=this._results;return v&&(this._results=[]),M}testAndRecordPointPairApproach(v,M,b,E,D,X,z){if(b.distanceSquaredXY(X)<this._maxDistanceSquared){const R=vt.createCurveFractionPoint(v,M,b),O=vt.createCurveFractionPoint(E,D,X),Y=Pt.createCapture(R,O);z&&Y.swapDetails(),this._results.push(Y)}}recordPointWithLocalFractions(v,M,b,E,D,X,z,R,O,Y){let N,B,V,U;const Sr=void 0!==Y&&Y.detailA.hasFraction1&&Y.detailB.hasFraction1;Sr?(N=K.interpolate(b,Y.detailA.fraction,E),B=K.interpolate(z,Y.detailB.fraction,R),V=K.interpolate(b,Y.detailA.fraction1,E),U=K.interpolate(z,Y.detailB.fraction1,R)):(N=V=K.interpolate(b,v,E),B=U=K.interpolate(z,D,R));const Cr=this._results.length;if(Cr>0&&!Sr){const v=this._results[Cr-1].detailA,b=this._results[Cr-1].detailB;if(O){if(b.isSameCurveAndFraction({curve:M,fraction:N})&&v.isSameCurveAndFraction({curve:X,fraction:B}))return}else if(v.isSameCurveAndFraction({curve:M,fraction:N})&&b.isSameCurveAndFraction({curve:X,fraction:B}))return}const kr=vt.createCurveFractionPoint(M,N,M.fractionToPoint(N)),Fr=vt.createCurveFractionPoint(X,B,X.fractionToPoint(B));if(Sr)kr.captureFraction1Point1(V,M.fractionToPoint(V)),Fr.captureFraction1Point1(U,X.fractionToPoint(U));else{if(kr.point.distanceSquaredXY(Fr.point)>this._maxDistanceSquared)return;kr.setIntervalRole(L.isolated),Fr.setIntervalRole(L.isolated)}O?this._results.push(new Pt(Fr,kr)):this._results.push(new Pt(kr,Fr))}capturePairWithLocalFractions(v,M,b,E,D,X,z,R){const O=K.interpolate(b,v.detailA.fraction,E),Y=K.interpolate(X,v.detailB.fraction,z),N=this._results.length;if(N>0){const v=this._results[N-1].detailA,b=this._results[N-1].detailB;if(R){if(b.isSameCurveAndFraction({curve:M,fraction:O})&&v.isSameCurveAndFraction({curve:D,fraction:Y}))return}else if(v.isSameCurveAndFraction({curve:M,fraction:O})&&b.isSameCurveAndFraction({curve:D,fraction:Y}))return}vt.createCurveEvaluatedFraction(M,O,v.detailA),vt.createCurveEvaluatedFraction(D,Y,v.detailB),v.detailA.setIntervalRole(L.isolated),v.detailB.setIntervalRole(L.isolated),R&&v.swapDetails(),this._results.push(v)}recordPairs(v,M,b,E){if(void 0!==b)for(const D of b)this.recordPointWithLocalFractions(D.detailA.fraction,v,0,1,D.detailB.fraction,M,0,1,E,D)}captureDetailPair(v,M,b){v&&M&&(b?this._results.push(Pt.createCapture(M,v)):this._results.push(Pt.createCapture(v,M)))}static updatePointToSegmentDistance(v,M,b,E,D,X,z){let R=!1;D<0?D=0:D>1&&(D=1),this._workPointB=b.interpolate(D,E,this._workPointB);const O=this._workPointB.distanceSquaredXY(M);return O<=Math.min(X,z.detailA.a)&&(z.detailA.setFP(v,M,void 0,O),z.detailB.setFP(D,this._workPointB,void 0,O),R=!0),R}static segmentSegmentBoundedApproach(v,M,b,E,D){const X=M.x-v.x,z=M.y-v.y,R=E.x-b.x,O=E.y-b.y,Y=b.x-v.x,N=b.y-v.y,B=E.x-v.x,V=E.y-v.y,L=b.x-M.x,U=b.y-M.y,Sr=K.crossProductXYXY(X,z,Y,N),Cr=K.crossProductXYXY(X,z,B,V),kr=-K.crossProductXYXY(R,O,Y,N),Fr=-K.crossProductXYXY(R,O,L,U);if(Sr*Cr<0&&kr*Fr<0){const D=-kr/(Fr-kr),X=-Sr/(Cr-Sr);return Pt.createCapture(vt.createCurveFractionPoint(void 0,D,v.interpolate(D,M)),vt.createCurveFractionPoint(void 0,X,b.interpolate(X,E)))}const Xr=new Pt;Xr.detailA.a=2*D;let zr=!1;const Rr=K.hypotenuseSquaredXY(X,z);if(Sr*Sr<=D*Rr){const E=K.dotProductXYXY(X,z,Y,N)/Rr;this.updatePointToSegmentDistance(0,b,v,M,E,D,Xr)&&(zr=!0)}if(Cr*Cr<=D*Rr){const b=K.dotProductXYXY(X,z,B,V)/Rr;this.updatePointToSegmentDistance(1,E,v,M,b,D,Xr)&&(zr=!0)}const Or=K.hypotenuseSquaredXY(R,O);if(kr*kr<=D*Or){const M=-K.dotProductXYXY(R,O,Y,N)/Or;this.updatePointToSegmentDistance(0,v,b,E,M,D,Xr)&&(zr=!1)}if(Fr*Fr<=D*Or){const v=-K.dotProductXYXY(R,O,L,U)/Or;this.updatePointToSegmentDistance(1,M,b,E,v,D,Xr)&&(zr=!1)}if(!(Xr.detailA.a>D))return zr&&Xr.swapDetails(),Xr}testAndRecordFractionalPairApproach(v,M,b,E,D,X,z,R,O){const Y=v.fractionToPoint(M),N=v.fractionToPoint(b),B=D.fractionToPoint(X),V=D.fractionToPoint(z);this.testAndRecordPointPairApproach(v,M,Y,D,X,B,O),this.testAndRecordPointPairApproach(v,b,N,D,X,B,O),this.testAndRecordPointPairApproach(v,M,Y,D,z,V,O),this.testAndRecordPointPairApproach(v,b,N,D,z,V,O),R&&(this.testAndRecordProjection(v,M,Y,D,X,z,O),this.testAndRecordProjection(v,b,N,D,X,z,O)),E&&(this.testAndRecordProjection(D,X,B,v,M,b,!O),this.testAndRecordProjection(D,z,V,v,M,b,!O))}getPointCurveClosestApproachXYNewton(v,M){if(!(v instanceof ti||v instanceof we))return void e(!0);const b=[.2,.4,.6,.8],E=new jt(v,M),D=new qt(E);let X,z,R=K.largeCoordinateResult;for(const O of b)if(D.setX(O),D.runIterations()){const b=D.getX();if(this.acceptFraction(b)){const E=v.fractionToPoint(b),D=E.distanceSquaredXY(M);D<R&&(R=D,X=b,z=E)}}return X&&z?vt.createCurveFractionPoint(v,X,z):void 0}testAndRecordProjection(v,M,b,E,D,X,z){const R=this.getPointCurveClosestApproachXYNewton(E,b);R&&K.restrictToInterval(R.fraction,D,X)===R.fraction&&this.testAndRecordPointPairApproach(v,M,b,E,R.fraction,R.point,z)}computeSegmentSegment3D(v,M,b,E,D,X,z,R,O,Y,N){const B=Mi.segmentSegmentBoundedApproach(M,E,z,O,this._maxDistanceSquared);B&&(B.detailA.setCurve(v),B.detailB.setCurve(X),this.capturePairWithLocalFractions(B,v,b,D,X,R,Y,N))}dispatchSegmentSegment(v,M,b,E,D,X,z,R,O,Y,N){this.computeSegmentSegment3D(v,M,b,E,D,X,z,R,O,Y,N)}dispatchSegmentArc(v,M,b,E,D,X,z){let R=!1;const O=X.toTransformedVectors(),Y=M,N=E,B=K.tripleProductXYW(Y,1,N,1,O.center,1),V=K.tripleProductXYW(Y,1,N,1,O.vector0,0),L=K.tripleProductXYW(Y,1,N,1,O.vector90,0),U=new At(2),Sr=new At(2),Cr=new At(2),kr=wt.appendImplicitLineUnitCircleIntersections(B,V,L,U,Sr,Cr);for(let Rr=0;Rr<kr;Rr++){const M=O.center.plus2Scaled(O.vector0,U.atUncheckedIndex(Rr),O.vector90,Sr.atUncheckedIndex(Rr)),E=O.sweep.radiansToSignedPeriodicFraction(Cr.atUncheckedIndex(Rr)),B=Ft.lineSegment3dXYClosestPointUnbounded(Y,N,M);void 0!==B&&this.acceptFraction(B)&&this.acceptFraction(E)&&(this.recordPointWithLocalFractions(B,v,b,D,E,X,0,1,z),R=!0)}if(R)return;this.testAndRecordFractionalPairApproach(v,b,D,!0,X,0,1,!0,z);const Fr=O.vector0.crossProductStartEndXY(M,E),Xr=O.vector90.crossProductStartEndXY(M,E),zr=Math.atan2(Xr,Fr);for(const Rr of[zr,zr+Math.PI]){const M=O.center.plus2Scaled(O.vector0,Math.cos(Rr),O.vector90,Math.sin(Rr)),E=O.sweep.radiansToSignedPeriodicFraction(Rr),R=Ft.lineSegment3dXYClosestPointUnbounded(Y,N,M);void 0!==R&&this.acceptFraction(R)&&this.acceptFraction(E)&&this.recordPointWithLocalFractions(R,v,b,D,E,X,0,1,z)}}solveArcArcNewton(v,M,b,E){const D=[.2,.4,.6,.8],X=[.2,.4,.6,.8],z=new Jt(E);for(const R of D)for(const E of X)if(z.setUV(R,E),z.runIterations()){const E=z.getU(),D=z.getV();this.acceptFraction(E)&&this.acceptFraction(D)&&this.recordPointWithLocalFractions(E,v,0,1,D,M,0,1,b)}}findPerpLineXYArcArcNewton(v,M,b){const E=new Qt(v,M);this.solveArcArcNewton(v,M,b,E)}dispatchArcArc(v,M,b){const E=v.range(),D=M.range();E.expandInPlace(this._maxDistanceToAccept),D.intersectsRangeXY(E)&&(this.testAndRecordFractionalPairApproach(v,0,1,!0,M,0,1,!0,b),this.findPerpLineXYArcArcNewton(v,M,b))}dispatchArcBsplineCurve3d(v,M,b){const E=ke.create();M.emitStrokes(E),this.computeArcLineString(v,E,b)}dispatchBSplineCurve3dBSplineCurve3d(v,M,b){const E=ke.create();v.emitStrokes(E);const D=ke.create();M.emitStrokes(D),this.computeLineStringLineString(E,D,b)}dispatchLineStringBSplineCurve(v,M,b){const E=ke.create();M.emitStrokes(E),this.computeLineStringLineString(v,E,b)}dispatchSegmentBsplineCurve(v,M,b){const E=ke.create();M.emitStrokes(E),this.computeSegmentLineString(v,E,b)}computeSegmentLineString(v,M,b){const E=M.numPoints(),D=K.safeDivideFraction(1,E-1,0),X=v.point0Ref,z=v.point1Ref,R=Mi._workPointBB0,O=Mi._workPointBB1;for(let Y=0;Y<E-1;++Y){const N=Y*D,B=Y+1===E-1?1:(Y+1)*D;M.packedPoints.getPoint3dAtUncheckedPointIndex(Y,R),M.packedPoints.getPoint3dAtUncheckedPointIndex(Y+1,O),this.dispatchSegmentSegment(v,X,0,z,1,M,R,N,O,B,b)}}computeArcLineString(v,M,b){const E=v.range(),D=M.range();if(E.expandInPlace(this._maxDistanceToAccept),!D.intersectsRangeXY(E))return;const X=Mi._workPointBB0,z=Mi._workPointBB1,R=M.numPoints();if(R>1){const E=1/(R-1);let D,O;D=0,M.pointAt(0,X);for(let Y=1;Y<R;Y++,X.setFrom(z),D=O)M.pointAt(Y,z),O=Y*E,this.dispatchSegmentArc(M,X,D,z,O,v,!b)}}dispatchCurveCollection(v,M){const b=this._geometryB;if(b&&b.children&&b instanceof ze){for(const E of b.children)this.resetGeometry(E),M(v);this._geometryB=b}}dispatchCurveChainWithDistanceIndex(v,M){if(!(this._geometryB&&this._geometryB instanceof ki))return;if(v instanceof ki)return void e(!0);const b=this._results.length,E=this._geometryB;for(const D of E.path.children)this.resetGeometry(D),M(v);this.resetGeometry(E),this._results=ki.convertChildDetailToChainDetail(this._results,b,void 0,E,!0)}handleLineSegment3d(v){if(this._geometryB instanceof we){const M=this._geometryB;this.dispatchSegmentSegment(v,v.point0Ref,0,v.point1Ref,1,M,M.point0Ref,0,M.point1Ref,1,!1)}else this._geometryB instanceof ke?this.computeSegmentLineString(v,this._geometryB,!1):this._geometryB instanceof ti?this.dispatchSegmentArc(v,v.point0Ref,0,v.point1Ref,1,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchSegmentBsplineCurve(v,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleLineSegment3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleLineSegment3d.bind(this))}classifyBitsPointRangeXY(v,M,b){let E=0;return v<b.low.x?E=1:v>b.high.x&&(E=2),M<b.low.y?E|=4:M>b.high.y&&(E|=8),E}computeLineStringLineString(v,M,b){const E=v.range(),D=M.range();if(E.expandInPlace(this._maxDistanceToAccept),!D.intersectsRangeXY(E))return;let X,z;const R=ut.createNull(),O=Mi._workPointAA0,Y=Mi._workPointAA1,N=Mi._workPointBB0,B=Mi._workPointBB1,V=v.numPoints(),L=M.numPoints();if(V>1&&L>1){const E=1/(V-1),U=1/(L-1);let Sr,Cr,kr,Fr=0;v.pointAt(0,O);for(let Xr=1;Xr<V;Xr++,O.setFrom(Y),Fr=Sr)if(Sr=Xr*E,Cr=0,v.pointAt(Xr,Y),R.setNull(),R.extendPoint(O),R.extendPoint(Y),R.expandInPlace(this._maxDistanceToAccept),R.intersectsRangeXY(D)){M.pointAt(0,N),X=this.classifyBitsPointRangeXY(N.x,N.y,R);for(let E=1;E<L;E++,N.setFrom(B),Cr=kr,X=z)M.pointAt(E,B),z=this.classifyBitsPointRangeXY(B.x,B.y,R),kr=E*U,0==(X&z)&&this.dispatchSegmentSegment(v,O,Fr,Y,Sr,M,N,Cr,B,kr,b)}}}handleLineString3d(v){if(this._geometryB instanceof ke){const M=this._geometryB;this.computeLineStringLineString(v,M,!1)}else this._geometryB instanceof we?this.computeSegmentLineString(this._geometryB,v,!0):this._geometryB instanceof ti?this.computeArcLineString(this._geometryB,v,!0):this._geometryB instanceof $e?this.dispatchLineStringBSplineCurve(v,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleLineString3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleLineString3d.bind(this))}handleArc3d(v){this._geometryB instanceof we?this.dispatchSegmentArc(this._geometryB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,v,!0):this._geometryB instanceof ke?this.computeArcLineString(v,this._geometryB,!1):this._geometryB instanceof ti?this.dispatchArcArc(v,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchArcBsplineCurve3d(v,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleArc3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleArc3d.bind(this))}handleBSplineCurve3d(v){this._geometryB instanceof we?this.dispatchSegmentBsplineCurve(this._geometryB,v,!0):this._geometryB instanceof ke?this.dispatchLineStringBSplineCurve(this._geometryB,v,!0):this._geometryB instanceof ti?this.dispatchArcBsplineCurve3d(this._geometryB,v,!0):this._geometryB instanceof Qe?this.dispatchBSplineCurve3dBSplineCurve3d(v,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(v){super.handleCurveChainWithDistanceIndex(v),this._results=ki.convertChildDetailToChainDetail(this._results,0,v,void 0,!0)}handleBSplineCurve3dH(v){}}Mi._workPointAA0=Q.create(),Mi._workPointAA1=Q.create(),Mi._workPointBB0=Q.create(),Mi._workPointBB1=Q.create(),Mi._workPointB=Q.create();class bi{get tolerance(){return this._tolerance}constructor(v=K.smallMetricDistance){this._tolerance=v}static create(v=K.smallMetricDistance){return new bi(v)}static assignDetailInterpolatedFractionsAndPoints(v,M,b,E,D,X=!1){X?(v.fraction=b,v.fraction1=M):(v.fraction=M,v.fraction1=b),v.point=E.interpolate(v.fraction,D,v.point),v.point1=E.interpolate(v.fraction1,D,v.point1)}projectPointToSegmentXY(v,M,b){this._vectorU=$.createStartEnd(M,b,this._vectorU),this._vectorV=$.createStartEnd(M,v,this._vectorV);const E=this._vectorU.dotProductXY(this._vectorU),D=this._vectorU.dotProductXY(this._vectorV),X=K.safeDivideFraction(D,E,0);return vt.createCurveFractionPoint(void 0,X,M.interpolate(X,b))}clampCoincidentOverlapToSegmentBounds(v,M,b,E,D,X=!1,z=!1,R=!1,O=!1){const Y=We.create(v.detailA.fraction,v.detailA.hasFraction1?v.detailA.fraction1:v.detailA.fraction),N=We.create(v.detailB.fraction,v.detailB.hasFraction1?v.detailB.fraction1:v.detailB.fraction),B=Y.signedDelta()<0,u=()=>{const X=Y.x0,z=Y.x1,R=N.x0,O=N.x1;return bi.assignDetailInterpolatedFractionsAndPoints(v.detailA,X,z,M,b,X>z),bi.assignDetailInterpolatedFractionsAndPoints(v.detailB,R,O,E,D,R>O),v},V=Y.clampDirectedTo01(!X,!z,!1),L=N.clampDirectedTo01(!R,!O,!1);if(V&&L){if(K.isAlmostEqualNumber(Y.absoluteDelta(),N.absoluteDelta(),K.smallFraction))return u();if(Y.clampDirectedTo01(!0,!0,!1)&&N.clampDirectedTo01(!0,!0,!1))return u()}const p=(M,b,E,D)=>(M.clone(v.detailA.point),b.clone(v.detailB.point),v.detailA.fraction=E?0:1,v.detailB.fraction=D?0:1,v.detailA.collapseToStart(),v.detailB.collapseToStart(),v),U=Y.clampDirectedTo01(!0,!0,!0),Sr=N.clampDirectedTo01(!0,!0,!0);if(U&&Sr){const X=v.detailA.point1??v.detailA.point;if(B){if(v.detailA.point.isAlmostEqual(M,this.tolerance))return p(M,E,!0,!0);if(X.isAlmostEqual(b,this.tolerance))return p(b,D,!1,!1)}else{if(X.isAlmostEqual(M,this.tolerance))return p(M,D,!0,!1);if(v.detailA.point.isAlmostEqual(b,this.tolerance))return p(b,E,!1,!0)}}}coincidentSegmentRangeXY(v,M,b,E,D=!0){const X=this.projectPointToSegmentXY(v,b,E);if(v.distanceXY(X.point)>this._tolerance)return;const z=this.projectPointToSegmentXY(M,b,E);if(M.distanceXY(z.point)>this._tolerance)return;const R=this.projectPointToSegmentXY(b,v,M);if(b.distanceXY(R.point)>this._tolerance)return;const O=this.projectPointToSegmentXY(E,v,M);if(E.distanceXY(O.point)>this._tolerance)return;X.fraction1=z.fraction,X.point1=z.point,R.fraction1=O.fraction,R.point1=O.point;const Y=Pt.createCapture(R,X);return D?this.clampCoincidentOverlapToSegmentBounds(Y,v,M,b,E):Y}createDetailPair(v,M,b,E,D,X){const z=D-E,R=K.conditionalDivideFraction(b.x0-E,z),O=K.conditionalDivideFraction(b.x1-E,z);if(void 0!==R&&void 0!==O){const E=vt.createCurveEvaluatedFractionFraction(v,b.x0,b.x1),D=vt.createCurveEvaluatedFractionFraction(M,R,O);return X&&E.swapFractionsAndPoints(),Pt.createCapture(E,D)}}appendDetailPair(v,M){return void 0===M?v:void 0===v?[M]:(v.push(M),v)}coincidentArcIntersectionXY(v,M,b=!0){let E;if(v.center.isAlmostEqual(M.center,this.tolerance)){const b=v.matrixRef.multiplyMatrixInverseMatrix(M.matrixRef);if(b){const D=b.at(0,0),X=b.at(1,0),z=b.at(0,1),R=b.at(1,1),O=K.hypotenuseXY(D,X),Y=K.hypotenuseXY(z,R),N=K.dotProductXYXY(D,X,z,R),B=K.crossProductXYXY(D,X,z,R);if(K.isAlmostEqualNumber(O,1)&&K.isAlmostEqualNumber(Y,1)&&K.isAlmostEqualNumber(0,N)){const b=Math.atan2(X,D),z=B>0?1:-1,R=b+z*M.sweep.startRadians,O=b+z*M.sweep.endRadians,Y=z*v.sweep.sweepRadians*M.sweep.sweepRadians<0,N=It.createStartEndRadians(R,O),V=v.sweep,L=V.fractionPeriod(),U=V.radiansToPositivePeriodicFraction(N.startRadians);e(U>=0);const Sr=U+N.sweepRadians/V.sweepRadians,x=(b,D)=>{const X=E?E.length:0,z=b.x0,R=b.x1;if(b.clampDirectedTo01()&&!K.isSmallRelative(b.absoluteDelta()))E=this.appendDetailPair(E,this.createDetailPair(v,M,b,z,R,Y));else{const b=Y?D:!D,X=this._point0=D?v.startPoint(this._point0):v.endPoint(this._point0),z=this._point1=b?M.startPoint(this._point1):M.endPoint(this._point1);if(X.isAlmostEqual(z,this.tolerance)){const R=vt.createCurveFractionPoint(v,D?0:1,X),O=vt.createCurveFractionPoint(M,b?0:1,z);E=this.appendDetailPair(E,Pt.createCapture(R,O))}}return void 0!==E&&E.length>X};x(We.create(U,Sr),!1),Sr>=L?x(We.create(U-L,Sr-L),!0):0===U&&x(We.create(U+L,Sr+L),!0)}}}return E}}class Ei extends Ze{constructor(v,M,b,E,D=K.smallMetricDistance){super(),this._extendA=M,this._geometryB=b,this._extendB=E,this._worldToLocalPerspective=void 0,this._worldToLocalAffine=void 0,void 0===v||v.isIdentity()||(this._worldToLocalAffine=v.asTransform,this._worldToLocalAffine||(this._worldToLocalPerspective=v.clone())),this._coincidentGeometryContext=bi.create(D),this._results=[]}resetGeometry(v){this._geometryB=v}acceptFraction(v,M,b,E=1e-12){return!(!v&&M<-E||!b&&M>1+E)}acceptFractionOnLine(v,M,b,E,D,X=K.smallMetricDistance){return!v&&M<0?K.isDistanceWithinTol(M*E.distanceXY(D),X):!(!b&&M>1)||K.isDistanceWithinTol((M-1)*E.distanceXY(D),X)}grabPairedResults(v=!1){const M=this._results;return v&&(this._results=[]),M}recordPointWithLocalFractions(v,M,b,E,D,X,z,R,O,Y){let N,B,V,U;const Sr=void 0!==Y&&Y.detailA.hasFraction1&&Y.detailB.hasFraction1;Sr?(N=K.interpolate(b,Y.detailA.fraction,E),B=K.interpolate(z,Y.detailB.fraction,R),V=K.interpolate(b,Y.detailA.fraction1,E),U=K.interpolate(z,Y.detailB.fraction1,R)):(N=V=K.interpolate(b,v,E),B=U=K.interpolate(z,D,R));const Cr=this._results.length;if(Cr>0&&!Sr){const v=this._results[Cr-1].detailA,b=this._results[Cr-1].detailB;if(O){if(b.isSameCurveAndFraction({curve:M,fraction:N})&&v.isSameCurveAndFraction({curve:X,fraction:B}))return}else if(v.isSameCurveAndFraction({curve:M,fraction:N})&&b.isSameCurveAndFraction({curve:X,fraction:B}))return}const kr=vt.createCurveFractionPoint(M,N,M.fractionToPoint(N)),Fr=vt.createCurveFractionPoint(X,B,X.fractionToPoint(B));Sr?(kr.captureFraction1Point1(V,M.fractionToPoint(V)),Fr.captureFraction1Point1(U,X.fractionToPoint(U))):(kr.setIntervalRole(L.isolated),Fr.setIntervalRole(L.isolated)),O?this._results.push(new Pt(Fr,kr)):this._results.push(new Pt(kr,Fr))}recordPairs(v,M,b,E){if(void 0!==b)for(const D of b)this.recordPointWithLocalFractions(D.detailA.fraction,v,0,1,D.detailB.fraction,M,0,1,E,D)}computeSegmentSegment3D(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U){const Sr=Ei._workVector2dA,Cr=this._coincidentGeometryContext.coincidentSegmentRangeXY(b,D,Y,B,!1);Cr?this._coincidentGeometryContext.clampCoincidentOverlapToSegmentBounds(Cr,b,D,Y,B,M,z,O,L)&&this.recordPointWithLocalFractions(Cr.detailA.fraction,v,E,X,Cr.detailB.fraction,R,N,V,U,Cr):Ft.lineSegment3dXYTransverseIntersectionUnbounded(b,D,Y,B,Sr)&&this.acceptFractionOnLine(M,Sr.x,z,b,D,this._coincidentGeometryContext.tolerance)&&this.acceptFractionOnLine(O,Sr.y,L,Y,B,this._coincidentGeometryContext.tolerance)&&this.recordPointWithLocalFractions(Sr.x,v,E,X,Sr.y,R,N,V,U)}computeSegmentSegment3DH(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U){const Sr=Ei._workPointA0H,Cr=Ei._workPointA1H,kr=Ei._workPointB0H,Fr=Ei._workPointB1H;this._worldToLocalPerspective.multiplyPoint3d(b,1,Sr),this._worldToLocalPerspective.multiplyPoint3d(D,1,Cr),this._worldToLocalPerspective.multiplyPoint3d(Y,1,kr),this._worldToLocalPerspective.multiplyPoint3d(B,1,Fr);const Xr=Ft.lineSegment3dHXYTransverseIntersectionUnbounded(Sr,Cr,kr,Fr);if(void 0!==Xr){const b=Xr.x,D=Xr.y;this.acceptFraction(M,b,z)&&this.acceptFraction(O,D,L)&&this.recordPointWithLocalFractions(b,v,E,X,D,R,N,V,U)}}dispatchSegmentSegment(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U){this._worldToLocalAffine?(Ei.setTransformedWorkPoints(this._worldToLocalAffine,b,D,Y,B),this.computeSegmentSegment3D(v,M,Ei._workPointA0,E,Ei._workPointA1,X,z,R,O,Ei._workPointB0,N,Ei._workPointB1,V,L,U)):this._worldToLocalPerspective?this.computeSegmentSegment3DH(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U):this.computeSegmentSegment3D(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U)}dispatchSegmentArc(v,M,b,E,D,X,z,R,O,Y,N){if(this._worldToLocalPerspective){const B=R.toTransformedPoint4d(this._worldToLocalPerspective),V=this._worldToLocalPerspective.multiplyPoint3d(b,1),L=this._worldToLocalPerspective.multiplyPoint3d(D,1),U=K.tripleProductPoint4dXYW(V,L,B.center),Sr=K.tripleProductPoint4dXYW(V,L,B.vector0),Cr=K.tripleProductPoint4dXYW(V,L,B.vector90),kr=new At(2),Fr=new At(2),Xr=new At(2),zr=wt.appendImplicitLineUnitCircleIntersections(U,Sr,Cr,kr,Fr,Xr);for(let b=0;b<zr;b++){const D=B.center.plus2Scaled(B.vector0,kr.atUncheckedIndex(b),B.vector90,Fr.atUncheckedIndex(b)),U=B.sweep.radiansToSignedPeriodicFraction(Xr.atUncheckedIndex(b)),Sr=Ft.lineSegment3dHXYClosestPointUnbounded(V,L,D);void 0!==Sr&&this.acceptFraction(M,Sr,z)&&this.acceptFraction(O,U,Y)&&this.recordPointWithLocalFractions(Sr,v,E,X,U,R,0,1,N)}}else{const B=R.toTransformedVectors(this._worldToLocalAffine);let V=b,L=D;this._worldToLocalAffine&&(V=this._worldToLocalAffine.multiplyPoint3d(b),L=this._worldToLocalAffine.multiplyPoint3d(D));const U=K.tripleProductXYW(V,1,L,1,B.center,1),Sr=K.tripleProductXYW(V,1,L,1,B.vector0,0),Cr=K.tripleProductXYW(V,1,L,1,B.vector90,0),kr=new At(2),Fr=new At(2),Xr=new At(2),zr=wt.appendImplicitLineUnitCircleIntersections(U,Sr,Cr,kr,Fr,Xr),Rr=1e-10,Or=1e-7;for(let b=0;b<zr;b++){const D=B.center.plus2Scaled(B.vector0,kr.atUncheckedIndex(b),B.vector90,Fr.atUncheckedIndex(b)),U=B.sweep.radiansToSignedPeriodicFraction(Xr.atUncheckedIndex(b)),Sr=Ft.lineSegment3dXYClosestPointUnbounded(V,L,D);void 0!==Sr&&this.acceptFraction(M,Sr,z,Rr)&&this.acceptFraction(O,U,Y,Or)&&this.recordPointWithLocalFractions(Sr,v,E,X,U,R,0,1,N)}}}dispatchArcArcThisOrder(v,M,b,E,D,X,z){const R=M.inverse();if(R){const M=R.multiplyMatrixMatrix(D),O=[],Y=[];Tt.solveUnitCircleHomogeneousEllipseIntersection(M.coffs[2],M.coffs[5],M.coffs[8],M.coffs[0],M.coffs[3],M.coffs[6],M.coffs[1],M.coffs[4],M.coffs[7],O,Y);for(let D=0;D<O.length;D++){const M=v.sweep.radiansToSignedPeriodicFraction(Y[D]),R=E.sweep.radiansToSignedPeriodicFraction(O[D]);this.acceptFraction(b,M,b)&&this.acceptFraction(X,R,X)&&this.recordPointWithLocalFractions(M,v,0,1,R,E,0,1,z)}}}dispatchArcArc(v,M,b,E,D){let X,z;if(this._worldToLocalPerspective){const M=v.toTransformedPoint4d(this._worldToLocalPerspective),E=b.toTransformedPoint4d(this._worldToLocalPerspective);X=xt.createColumnsXYW(M.vector0,M.vector0.w,M.vector90,M.vector90.w,M.center,M.center.w),z=xt.createColumnsXYW(E.vector0,E.vector0.w,E.vector90,M.vector90.w,E.center,E.center.w)}else{const M=v.toTransformedVectors(this._worldToLocalAffine),E=b.toTransformedVectors(this._worldToLocalAffine);X=xt.createColumnsXYW(M.vector0,0,M.vector90,0,M.center,1),z=xt.createColumnsXYW(E.vector0,0,E.vector90,0,E.center,1)}if(X.conditionNumber()>z.conditionNumber()?this.dispatchArcArcThisOrder(v,X,M,b,z,E,D):this.dispatchArcArcThisOrder(b,z,E,v,X,M,!D),this._coincidentGeometryContext)if(this._worldToLocalPerspective);else if(this._worldToLocalAffine);else{const M=this._coincidentGeometryContext.coincidentArcIntersectionXY(v,b,!0);void 0!==M&&this.recordPairs(v,b,M,D)}}dispatchArcBsplineCurve3d(v,M,b,E,D){let X;if(this._worldToLocalPerspective){const M=v.toTransformedPoint4d(this._worldToLocalPerspective);X=xt.createColumnsXYW(M.vector0,M.vector0.w,M.vector90,M.vector90.w,M.center,M.center.w)}else{const M=v.toTransformedVectors(this._worldToLocalAffine);X=xt.createColumnsXYW(M.vector0,0,M.vector90,0,M.center,1)}const z=X.inverse();if(z){const X=b.order,R=2*X-1,O=new Float64Array(X),Y=new Vt(R),N=z.at(0,0),B=z.at(0,1),V=0,L=z.at(0,2),U=z.at(1,0),Sr=z.at(1,1),Cr=0,kr=z.at(1,2),Fr=z.at(2,0),Xr=z.at(2,1),zr=0,Rr=z.at(2,2);if(z){let X;for(let z=0;X=b.getSaturatedBezierSpan3dH(z,X),X;z++){this._worldToLocalPerspective?X.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective):this._worldToLocalAffine&&X.tryTransformInPlace(this._worldToLocalAffine),Y.zero(),X.poleProductsXYZW(O,N,B,V,L),Y.addSquaredSquaredBezier(O,1),X.poleProductsXYZW(O,U,Sr,Cr,kr),Y.addSquaredSquaredBezier(O,1),X.poleProductsXYZW(O,Fr,Xr,zr,Rr),Y.addSquaredSquaredBezier(O,-1);const z=Y.roots(0,!0);if(z)for(const R of z){const z=X.fractionToParentFraction(R),O=X.fractionToPoint4d(R),Y=O.dotProductXYZW(N,B,V,L),Fr=O.dotProductXYZW(U,Sr,Cr,kr),Xr=v.sweep.radiansToSignedPeriodicFraction(Math.atan2(Fr,Y));this.acceptFraction(M,Xr,M)&&this.acceptFraction(E,z,E)&&this.recordPointWithLocalFractions(Xr,v,0,1,z,b,0,1,D)}}}}}transformBeziers(v){if(this._worldToLocalAffine)for(const M of v)M.tryTransformInPlace(this._worldToLocalAffine);else if(this._worldToLocalPerspective)for(const M of v)M.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective)}getRanges(v){const M=[];M.length=0;for(const b of v)M.push(b.range());return M}dispatchBezierBezierStrokeFirst(v,M,b,E,D,X,z,R){this._xyzwA0||(this._xyzwA0=Dt.create()),this._xyzwA1||(this._xyzwA1=Dt.create()),this._xyzwPlane||(this._xyzwPlane=Dt.create()),this._xyzwB||(this._xyzwB=Dt.create()),v.fractionToPoint4d(0,this._xyzwA0);let O,Y=0;const N=1/b;for(let B=1;B<=b;B++,Y=O,this._xyzwA0.setFrom(this._xyzwA1)){O=B*N,v.fractionToPoint4d(O,this._xyzwA1),Dt.createPlanePointPointZ(this._xyzwA0,this._xyzwA1,this._xyzwPlane),E.poleProductsXYZW(z.coffs,this._xyzwPlane.x,this._xyzwPlane.y,this._xyzwPlane.z,this._xyzwPlane.w);const b=z.roots(0,!0);if(b)for(const X of b){let b=X;E.fractionToPoint4d(b,this._xyzwB);const z=Ft.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0,this._xyzwA1,this._xyzwB);if(z&&K.isIn01WithTolerance(z,1e-5)){let X=K.interpolate(Y,z,O);const N=new Kt(v,E),B=new Jt(N);B.setUV(X,b),B.runIterations()&&(X=B.getU(),b=B.getV());const V=v.fractionToParentFraction(X),L=E.fractionToParentFraction(b);this.acceptFraction(!1,V,!1)&&this.acceptFraction(!1,L,!1)&&this.recordPointWithLocalFractions(V,M,0,1,L,D,0,1,R)}}}}dispatchBSplineCurve3dBSplineCurve3d(v,M,b){const E=v.collectBezierSpans(!0),D=M.collectBezierSpans(!0),X=E.length,z=D.length;this.transformBeziers(E),this.transformBeziers(D);const R=this.getRanges(E),O=this.getRanges(D),Y=v.order,N=M.order,B=new Vt(Y),V=new Vt(N);for(let L=0;L<X;L++)for(let X=0;X<z;X++)if(R[L].intersectsRangeXY(O[X])){const z=E[L].computeStrokeCountForOptions(),R=D[X].computeStrokeCountForOptions();z<R?this.dispatchBezierBezierStrokeFirst(E[L],v,z,D[X],M,R,V,b):this.dispatchBezierBezierStrokeFirst(D[X],M,R,E[L],v,z,B,!b)}}projectPoint(v,M=1){return this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyPoint3d(v,M):this._worldToLocalAffine?this._worldToLocalAffine.multiplyXYZW(v.x,v.y,v.z,M):Dt.createFromPointAndWeight(v,M)}mapNPCPlaneToWorld(v,M){this._worldToLocalAffine?this._worldToLocalAffine.multiplyTransposeXYZW(v.x,v.y,v.z,v.w,M):this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyTransposePoint4d(v,M):v.clone(M)}dispatchSegmentBsplineCurve(v,M,b,E,D,X,z,R,O,Y){const N=this.projectPoint(b),B=this.projectPoint(D),V=Dt.createPlanePointPointZ(N,B);this.mapNPCPlaneToWorld(V,V);const L=[];R.appendPlaneIntersectionPoints(V,L);for(const U of L){const b=U.fraction,D=U.point,V=this.projectPoint(D),L=Ft.lineSegment3dHXYClosestPointUnbounded(N,B,V);void 0!==L&&this.acceptFraction(M,L,z)&&this.acceptFraction(O,b,O)&&this.recordPointWithLocalFractions(L,v,E,X,b,R,0,1,Y)}}dispatchLineStringBSplineCurve(v,M,b,E,D){const X=v.numPoints();if(X>1){const z=1/(X-1);let R,O;R=0;const Y=Ei._workPointA0,N=Ei._workPointA1;v.pointAt(0,Y);for(let B=1;B<X;B++,Y.setFrom(N),R=O)v.pointAt(B,N),O=B*z,this.dispatchSegmentBsplineCurve(v,1===B&&M,Y,R,N,O,B+1===X&&M,b,E,D)}}computeSegmentLineString(v,M,b,E,D){const X=v.point0Ref,z=v.point1Ref,R=Ei._workPointBB0,O=Ei._workPointBB1,Y=b.numPoints();if(Y>1){const N=1/(Y-1);let B,V;B=0,b.pointAt(0,R);for(let L=1;L<Y;L++,R.setFrom(O),B=V)b.pointAt(L,O),V=L*N,this.dispatchSegmentSegment(v,M,X,0,z,1,M,b,1===L&&E,R,B,O,V,L+1===Y&&E,D)}}computeArcLineString(v,M,b,E,D){const X=Ei._workPointBB0,z=Ei._workPointBB1,R=b.numPoints();if(R>1){const O=1/(R-1);let Y,N;Y=0,b.pointAt(0,X);for(let B=1;B<R;B++,X.setFrom(z),Y=N)b.pointAt(B,z),N=B*O,this.dispatchSegmentArc(b,1===B&&E,X,Y,z,N,B+1===R&&E,v,M,M,!D)}}computeLineStringLineString(v,M,b){const E=Ei._workPointAA0,D=Ei._workPointAA1,X=Ei._workPointBB0,z=Ei._workPointBB1,R=v.numPoints(),O=M.numPoints();if(R>1&&O>1){v.pointAt(0,E);const Y=1/(R-1),N=1/(O-1);let B,V,L,U=0;const Sr=this._extendA,Cr=this._extendB;v.pointAt(0,E);for(let kr=1;kr<R;kr++,E.setFrom(D),U=V){V=kr*Y,B=0,v.pointAt(kr,D),M.pointAt(0,X);for(let Y=1;Y<O;Y++,X.setFrom(z),B=L)M.pointAt(Y,z),L=Y*N,this.dispatchSegmentSegment(v,1===kr&&Sr,E,U,D,V,kr+1===R&&Sr,M,1===Y&&Cr,X,B,z,L,Y+1===O&&Cr,b)}}}static setTransformedWorkPoints(v,M,b,E,D){v.multiplyPoint3d(M,this._workPointA0),v.multiplyPoint3d(b,this._workPointA1),v.multiplyPoint3d(E,this._workPointB0),v.multiplyPoint3d(D,this._workPointB1)}dispatchCurveCollection(v,M){const b=this._geometryB;if(b&&b.children&&b instanceof ze){for(const E of b.children)this.resetGeometry(E),M(v);this._geometryB=b}}dispatchCurveChainWithDistanceIndex(v,M){if(!(this._geometryB&&this._geometryB instanceof ki))return;if(v instanceof ki)return void e(!0);const b=this._results.length,E=this._geometryB;for(const D of E.path.children)this.resetGeometry(D),M(v);this.resetGeometry(E),this._results=ki.convertChildDetailToChainDetail(this._results,b,void 0,E,!0)}handleLineSegment3d(v){if(this._geometryB instanceof we){const M=this._geometryB;this.dispatchSegmentSegment(v,this._extendA,v.point0Ref,0,v.point1Ref,1,this._extendA,M,this._extendB,M.point0Ref,0,M.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof ke?this.computeSegmentLineString(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ti?this.dispatchSegmentArc(v,this._extendA,v.point0Ref,0,v.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof $e?this.dispatchSegmentBsplineCurve(v,this._extendA,v.point0Ref,0,v.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleLineSegment3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleLineSegment3d.bind(this))}handleLineString3d(v){if(this._geometryB instanceof ke){const M=this._geometryB;this.computeLineStringLineString(v,M,!1)}else this._geometryB instanceof we?this.computeSegmentLineString(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof ti?this.computeArcLineString(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof $e?this.dispatchLineStringBSplineCurve(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleLineString3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleLineString3d.bind(this))}handleArc3d(v){this._geometryB instanceof we?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,v,this._extendA,this._extendA,!0):this._geometryB instanceof ke?this.computeArcLineString(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ti?this.dispatchArcArc(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof $e?this.dispatchArcBsplineCurve3d(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleArc3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleArc3d.bind(this))}handleBSplineCurve3d(v){this._geometryB instanceof we?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,v,this._extendA,!0):this._geometryB instanceof ke?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof ti?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof Qe?this.dispatchBSplineCurve3dBSplineCurve3d(v,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(v){super.handleCurveChainWithDistanceIndex(v),this._results=ki.convertChildDetailToChainDetail(this._results,0,v,void 0,!0)}handleBSplineCurve3dH(v){}}Ei._workVector2dA=J.create(),Ei._workPointA0H=Dt.create(),Ei._workPointA1H=Dt.create(),Ei._workPointB0H=Dt.create(),Ei._workPointB1H=Dt.create(),Ei._workPointAA0=Q.create(),Ei._workPointAA1=Q.create(),Ei._workPointBB0=Q.create(),Ei._workPointBB1=Q.create(),Ei._workPointA0=Q.create(),Ei._workPointA1=Q.create(),Ei._workPointB0=Q.create(),Ei._workPointB1=Q.create();class Di extends Ze{constructor(v,M,b){super(),this._extendA=v,this._geometryB=M,this._extendB=b,this._results=[]}resetGeometry(v){this._geometryB=v}grabPairedResults(v=!1){const M=this._results;return v&&(this._results=[]),M}acceptFraction(v,M,b){return!(!v&&M<0||!b&&M>1)}recordPointWithLocalFractions(v,M,b,E,D,X,z,R,O){const Y=K.interpolate(b,v,E),N=K.interpolate(z,D,R),B=this._results.length;if(B>0){const v=this._results[B-1].detailA,b=this._results[B-1].detailB;if(O){if(b.isSameCurveAndFraction({curve:M,fraction:Y})&&v.isSameCurveAndFraction({curve:X,fraction:N}))return}else if(v.isSameCurveAndFraction({curve:M,fraction:Y})&&b.isSameCurveAndFraction({curve:X,fraction:N}))return}const V=M.fractionToPoint(Y),U=X.fractionToPoint(N);if(!V.isAlmostEqualMetric(U))return;const Sr=vt.createCurveFractionPoint(M,Y,V);Sr.setIntervalRole(L.isolated);const Cr=vt.createCurveFractionPoint(X,N,U);if(Cr.setIntervalRole(L.isolated),O){const v=new Pt(Cr,Sr);this._results.push(v)}else{const v=new Pt(Sr,Cr);this._results.push(v)}}computeSegmentSegment3D(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U){const Sr=Di._workVector2dA;Ft.lineSegment3dClosestApproachUnbounded(b,D,Y,B,Sr)&&this.acceptFraction(M,Sr.x,z)&&this.acceptFraction(O,Sr.y,L)&&this.recordPointWithLocalFractions(Sr.x,v,E,X,Sr.y,R,N,V,U)}dispatchSegmentSegment(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U){this.computeSegmentSegment3D(v,M,b,E,D,X,z,R,O,Y,N,B,V,L,U)}createPlaneWithPreferredPerpendicular(v,M,b,E,D){b=K.restrictToInterval(Math.abs(b),0,1-K.smallFraction);const X=M.magnitudeSquared(),z=E.magnitudeSquared(),R=Math.abs(M.dotProduct(E)),O=M.unitCrossProduct(R*R<=b*b*X*z?E:D);if(O)return yt.create(v,O)}dispatchSegmentArc(v,M,b,E,D,X,z,R,O,Y,N){const B=$.createStartEnd(b,D),V=this.createPlaneWithPreferredPerpendicular(b,B,.94,R.perpendicularVector,R.vector0);if(void 0!==V){const B=[];let L,U;R.appendPlaneIntersectionPoints(V,B);for(const V of B)this.acceptFraction(O,V.fraction,Y)&&(L=Ft.lineSegment3dClosestPointUnbounded(b,D,V.point),void 0!==L&&(U=b.interpolate(L,D,U),U.isAlmostEqualMetric(V.point)&&this.acceptFraction(M,L,z)&&this.recordPointWithLocalFractions(L,v,E,X,V.fraction,R,0,1,N)))}}dispatchArcArcInPlane(v,M,b,E,D){const X=v.otherArcAsLocalVectors(b);if(void 0!==X){const z=[],R=[];Tt.solveUnitCircleHomogeneousEllipseIntersection(X.center.x,X.center.y,1,X.vector0.x,X.vector0.y,0,X.vector90.x,X.vector90.y,0,z,R);for(let X=0;X<z.length;X++){const O=v.sweep.radiansToSignedPeriodicFraction(R[X]),Y=b.sweep.radiansToSignedPeriodicFraction(z[X]);this.acceptFraction(M,O,M)&&this.acceptFraction(E,Y,E)&&this.recordPointWithLocalFractions(O,v,0,1,Y,b,0,1,D)}}}dispatchArcArc(v,M,b,E,D){const X=yt.create(v.center,v.perpendicularVector),z=yt.create(b.center,b.perpendicularVector);if(void 0!==X&&void 0!==z)if(X.getNormalRef().isParallelTo(z.getNormalRef()))X.isPointInPlane(z.getOriginRef())&&z.isPointInPlane(X.getOriginRef())&&this.dispatchArcArcInPlane(v,M,b,E,D);else{const R=[];b.appendPlaneIntersectionPoints(X,R);const O=[];v.appendPlaneIntersectionPoints(z,O);for(const X of R)for(const z of O)z.point.isAlmostEqual(X.point)&&this.acceptFraction(M,z.fraction,M)&&this.acceptFraction(E,X.fraction,E)&&this.recordPointWithLocalFractions(z.fraction,v,0,1,X.fraction,b,0,1,D)}}dispatchArcBsplineCurve3d(v,M,b,E,D){}dispatchBSplineCurve3dBSplineCurve3d(v,M,b){}dispatchSegmentBsplineCurve(v,M,b,E,D,X,z,R,O,Y){}dispatchLineStringBSplineCurve(v,M,b,E,D){}computeSegmentLineString(v,M,b,E,D){const X=v.point0Ref,z=v.point1Ref,R=Di._workPointBB0,O=Di._workPointBB1,Y=b.numPoints();if(Y>1){const N=1/(Y-1);let B,V;B=0,b.pointAt(0,R);for(let L=1;L<Y;L++,R.setFrom(O),B=V)b.pointAt(L,O),V=L*N,this.dispatchSegmentSegment(v,M,X,0,z,1,M,b,1===L&&E,R,B,O,V,L+1===Y&&E,D)}}computeArcLineString(v,M,b,E,D){const X=Di._workPointBB0,z=Di._workPointBB1,R=b.numPoints();if(R>1){const O=1/(R-1);let Y,N;Y=0,b.pointAt(0,X);for(let B=1;B<R;B++,X.setFrom(z),Y=N)b.pointAt(B,z),N=B*O,this.dispatchSegmentArc(b,1===B&&E,X,Y,z,N,B+1===R&&E,v,M,M,!D)}}computeLineStringLineString(v,M,b){const E=Di._workPointAA0,D=Di._workPointAA1,X=Di._workPointBB0,z=Di._workPointBB1,R=v.numPoints(),O=M.numPoints();if(R>1&&O>1){v.pointAt(0,E);const Y=1/(R-1),N=1/(O-1);let B,V,L,U=0;const Sr=this._extendA,Cr=this._extendB;v.pointAt(0,E);for(let kr=1;kr<R;kr++,E.setFrom(D),U=V){V=kr*Y,B=0,v.pointAt(kr,D),M.pointAt(0,X);for(let Y=1;Y<O;Y++,X.setFrom(z),B=L)M.pointAt(Y,z),L=Y*N,this.dispatchSegmentSegment(v,1===kr&&Sr,E,U,D,V,kr+1===R&&Sr,M,1===Y&&Cr,X,B,z,L,Y+1===O&&Cr,b)}}}dispatchCurveCollection(v,M){const b=this._geometryB;if(b&&b.children&&b instanceof ze){for(const E of b.children)this.resetGeometry(E),M(v);this._geometryB=b}}dispatchCurveChainWithDistanceIndex(v,M){if(!(this._geometryB&&this._geometryB instanceof ki))return;if(v instanceof ki)return void e(!0);const b=this._results.length,E=this._geometryB;for(const D of E.path.children)this.resetGeometry(D),M(v);this.resetGeometry(E),this._results=ki.convertChildDetailToChainDetail(this._results,b,void 0,E,!0)}handleLineSegment3d(v){if(this._geometryB instanceof we){const M=this._geometryB;this.dispatchSegmentSegment(v,this._extendA,v.point0Ref,0,v.point1Ref,1,this._extendA,M,this._extendB,M.point0Ref,0,M.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof ke?this.computeSegmentLineString(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ti?this.dispatchSegmentArc(v,this._extendA,v.point0Ref,0,v.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof $e?this.dispatchSegmentBsplineCurve(v,this._extendA,v.point0Ref,0,v.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleLineSegment3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleLineSegment3d.bind(this))}handleLineString3d(v){if(this._geometryB instanceof ke){const M=this._geometryB;this.computeLineStringLineString(v,M,!1)}else this._geometryB instanceof we?this.computeSegmentLineString(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof ti?this.computeArcLineString(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof $e?this.dispatchLineStringBSplineCurve(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleLineString3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleLineString3d.bind(this))}handleArc3d(v){this._geometryB instanceof we?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,v,this._extendA,this._extendA,!0):this._geometryB instanceof ke?this.computeArcLineString(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ti?this.dispatchArcArc(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof $e?this.dispatchArcBsplineCurve3d(v,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleArc3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleArc3d.bind(this))}handleBSplineCurve3d(v){this._geometryB instanceof we?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,v,this._extendA,!0):this._geometryB instanceof ke?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof ti?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,v,this._extendA,!0):this._geometryB instanceof Qe?this.dispatchBSplineCurve3dBSplineCurve3d(v,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchCurveCollection(v,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof ki&&this.dispatchCurveChainWithDistanceIndex(v,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(v){super.handleCurveChainWithDistanceIndex(v),this._results=ki.convertChildDetailToChainDetail(this._results,0,v,void 0,!0)}handleBSplineCurve3dH(v){}}Di._workVector2dA=J.create(),Di._workPointAA0=Q.create(),Di._workPointAA1=Q.create(),Di._workPointBB0=Q.create(),Di._workPointBB1=Q.create();class Xi{static intersectionXYPairs(v,M,b,E,D=K.smallMetricDistance){return Xi.intersectionProjectedXYPairs(void 0,v,M,b,E,D)}static intersectionProjectedXYPairs(v,M,b,E,D,X=K.smallMetricDistance){const z=new Ei(v,b,E,D,X);return M.dispatchToGeometryHandler(z),z.grabPairedResults()}static intersectionXYZPairs(v,M,b,E){const D=new Di(M,b,E);return v.dispatchToGeometryHandler(D),D.grabPairedResults()}static allIntersectionsAmongPrimitivesXY(v,M=K.smallMetricDistance){const b=new Ei(void 0,!1,void 0,!1,M);for(let E=0;E<v.length;E++){const M=v[E];for(let D=E+1;D<v.length;D++)b.resetGeometry(v[D]),M.dispatchToGeometryHandler(b)}return b.grabPairedResults()}static closeApproachProjectedXYPairs(v,M,b){const E=new Mi(M);return E.maxDistanceToAccept=b,v.dispatchToGeometryHandler(E),E.grabPairedResults()}static closestApproachProjectedXYPair(v,M){const b=v.range();b.extendRange(M.range());const E=b.low.distanceXY(b.high),D=this.closeApproachProjectedXYPairs(v,M,E);if(!D.length)return;let X=0,z=2*E;for(let R=0;R<D.length;++R){const v=D[R].detailA.point.distanceXY(D[R].detailB.point);v<z&&(X=R,z=v)}return D[X]}}class Ri{constructor(v=K.smallMetricDistance,M=K.smallMetricDistance){this._chains=[],this._gapTolerance=v,this._snapTolerance=K.smallMetricDistance,this._planeTolerance=M}findAnyChainToConnect(v,M,b=-1){for(let E=0;E<this._chains.length;E++){if(b===E)continue;const D=this._chains[E];if(this._xyzWork1=D[D.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(v,M))return{chainIndex:E,atEnd:!0};if(this._xyzWork1=D[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(v,M))return{chainIndex:E,atEnd:!1}}}captureCurvePrimitive(v){this._snapTolerance<this._gapTolerance&&this.attachPrimitiveToAnyChain(v,this._snapTolerance)||this.attachPrimitiveToAnyChain(v,this._gapTolerance)||this._chains.push([v])}captureCurve(v){if(v instanceof oe)this.captureCurvePrimitive(v);else if(v instanceof ze)for(const M of v.children)this.captureCurve(M)}static simpleEndPointMove(v,M,b){if(v instanceof we)return M?v.point1Ref.setFrom(b):v.point0Ref.setFrom(b),!0;if(v instanceof ke&&v.numPoints()>0){const E=M?v.numPoints()-1:0;return v.packedPoints.setAtCheckedPointIndex(E,b),!0}return!1}static moveHeadOrTail(v,M,b){const E=v.endPoint(),D=M.startPoint(),X=.001*K.smallMetricDistance,z=E.distanceXY(D);if(z<X)return!1;if(z<b&&(this.simpleEndPointMove(M,!1,E)||this.simpleEndPointMove(v,!0,D)))return!0;const R=Xi.intersectionXYPairs(v,!0,M,!0);for(const O of R){const X=O.detailA,z=O.detailB,R=X.point.distanceXY(E),Y=z.point.distanceXY(D);if(R<5*b&&Y<5*b&&v instanceof ti&&M instanceof ti){const b=v.sweep.fractionToRadians(X.fraction);v.sweep.setStartEndRadians(v.sweep.startRadians,b);const E=M.sweep.fractionToRadians(z.fraction);return M.sweep.setStartEndRadians(E,M.sweep.endRadians),!0}}return!1}attachPrimitiveToAnyChain(v,M){if(v){this._xyzWork0=v.startPoint(this._xyzWork0);let b=this.findAnyChainToConnect(this._xyzWork0,M);if(b){if(b.atEnd){const E=this._chains[b.chainIndex],D=E.length-1;return this._chains[b.chainIndex].push(v),Ri.moveHeadOrTail(E[D],E[D+1],this._gapTolerance),this.searchAndMergeChainIndex(b.chainIndex,M),!0}{v.reverseInPlace();const E=this._chains[b.chainIndex];return E.splice(0,0,v),Ri.moveHeadOrTail(E[0],E[1],this._gapTolerance),this.searchAndMergeChainIndex(b.chainIndex,M),!0}}if(this._xyzWork0=v.endPoint(this._xyzWork0),b=this.findAnyChainToConnect(this._xyzWork0,M),b){if(b.atEnd){v.reverseInPlace();const E=this._chains[b.chainIndex],D=E.length-1;return this._chains[b.chainIndex].push(v),Ri.moveHeadOrTail(E[D],E[D+1],this._gapTolerance),this.searchAndMergeChainIndex(b.chainIndex,M),!0}{const E=this._chains[b.chainIndex];return E.splice(0,0,v),Ri.moveHeadOrTail(E[0],E[1],this._gapTolerance),this.searchAndMergeChainIndex(b.chainIndex,M),!0}}}return!1}mergeChainsForwardForward(v,M){const b=this._chains[v],E=this._chains[M];for(const X of E)b.push(X);E.length=0;const D=this._chains.length-1;M!==D&&(this._chains[M]=this._chains[D]),this._chains.pop()}reverseChain(v){const M=this._chains[v];M.reverse();for(const b of M)b.reverseInPlace()}searchAndMergeChainIndex(v,M){const b=this._chains[v],E=b.length-1;this._xyzWork0=b[0].startPoint(this._xyzWork0);let D=this.findAnyChainToConnect(this._xyzWork0,M,v);return D?(D.atEnd||this.reverseChain(D.chainIndex),void this.mergeChainsForwardForward(D.chainIndex,v)):(this._xyzWork0=b[E].endPoint(this._xyzWork0),D=this.findAnyChainToConnect(this._xyzWork0,M,v),D?(D.atEnd&&this.reverseChain(D.chainIndex),void this.mergeChainsForwardForward(v,D.chainIndex)):void 0)}promoteArrayToCurves(v,M){if(0!==v.length){if(M){const M=v[0],b=v[v.length-1];if(Ri._staticPointA=M.startPoint(Ri._staticPointA),Ri._staticPointB=b.endPoint(Ri._staticPointB),Ri.moveHeadOrTail(b,M,this._gapTolerance)&&(Ri._staticPointA=M.startPoint(Ri._staticPointA),Ri._staticPointB=b.endPoint(Ri._staticPointB)),Ri._staticPointA.isAlmostEqual(Ri._staticPointB,this._gapTolerance)){const M=ei.createRightHandedLocalToWorld(v);if(M){const b=M.inverse();if(b){const M=lr.curveArrayRange(v,b);if(void 0!==this._planeTolerance&&M.zLength()<=this._planeTolerance)return Oe.createArray(v)}}return Ve.createArray(v)}}return 1===v.length?v[0]:Ve.createArray(v)}}chainToLineString3d(v,M){if(0===v.length)return;const b=ke.create();for(const E of v)E.emitStrokes(b,M);return b.removeDuplicatePoints(this._gapTolerance),b}grabResult(v=!1){const M=this._chains;if(0===M.length)return;if(1===M.length)return this.promoteArrayToCurves(M[0],v);const b=Ye.create();for(const E of M){const M=this.promoteArrayToCurves(E,v);b.tryAddChild(M)}return b}announceChainsAsLineString3d(v,M){const b=this._chains;if(1===b.length){const E=this.chainToLineString3d(b[0],M);E&&v(E)}else if(b.length>1)for(const E of b){const b=this.chainToLineString3d(E,M);b&&v(b)}}}!function(v){v[v.Unknown=0]="Unknown",v[v.Cap=1]="Cap",v[v.Extend=2]="Extend",v[v.Trim=-1]="Trim",v[v.JustGeometry=3]="JustGeometry",v[v.Gap=4]="Gap"}(zr||(zr={}));class zi{constructor(v,M,b){this.curve0=v,this.curve1=M,this.swingPoint=b,this.flexure=zr.Unknown}static constructArc(v,M,b){if(void 0!==M&&K.isSameCoordinate(v.origin.distance(M),b.origin.distance(M))){const E=v.direction.angleToXY(b.direction),D=$.createStartEnd(M,v.origin),X=D.rotate90CCWXY();return ti.create(M,D,X,It.createStartEndRadians(0,E.radians))}}shallowExtract(){return{curve0:this.curve0,curve1:this.curve1,fraction0:this.fraction0,fraction1:this.fraction1}}static link(v,M){v.nextJoint=M,M&&(M.previousJoint=v),v.curve1&&M&&!M.curve0?M.curve0=v.curve1:!v.curve1&&M&&M.curve0&&(v.curve1=M.curve0)}nextJointFraction0(v){return this.nextJoint&&void 0!==this.nextJoint.fraction0?this.nextJoint.fraction0:v}static addStrokes(v,M){M&&M.emitStrokes(v)}static addPoint(v,M){v.packedPoints.length>0&&(v.endPoint().isAlmostEqual(M)||v.packedPoints.push(M))}static collectStrokesFromChain(v,M,b=100){let E=-2*b;zi.visitJointsOnChain(v,(v=>{if(this.addStrokes(M,v.jointCurve),v.curve1&&void 0!==v.fraction1){const b=v.fraction1,E=v.nextJointFraction0(1);let D;0===b&&1===E?D=v.curve1.clone():b<E&&(D=v.curve1.clonePartialCurve(b,E)),D&&(v.jointCurve||this.addPoint(M,D.startPoint())),this.addStrokes(M,D)}return E++<b}),b)}static collectPrimitive(v,M){if(M){if(v.length>0){const b=v[v.length-1].endPoint(),E=M.startPoint();b.isAlmostEqual(E)||v.push(we.create(b,E))}v.push(M)}}static adjustJointToPrimitives(v){const M=v.jointCurve;if(M instanceof ke){if(v.curve0){const b=v.curve0.endPoint(),E=M.startPoint();b.isAlmostEqual(E)||M.packedPoints.setAtCheckedPointIndex(0,b)}if(v.curve1){const b=v.curve1.startPoint(),E=M.endPoint();b.isAlmostEqual(E)||M.packedPoints.setAtCheckedPointIndex(M.packedPoints.length-1,b)}}}static collectCurvesFromChain(v,M,b=100){if(void 0===v)return;let E=-2*b;zi.visitJointsOnChain(v,(v=>{if(this.adjustJointToPrimitives(v),this.collectPrimitive(M,v.jointCurve),v.curve1&&void 0!==v.fraction1){const b=v.fraction1,E=v.nextJointFraction0(1);let D;0===b&&1===E?D=v.curve1.clone():b<E&&(D=v.curve1.clonePartialCurve(b,E)),this.collectPrimitive(M,D)}return E++<b}),b)}static annotateChain(v,M,b=100){v&&zi.visitJointsOnChain(v,(v=>(v.annotateJointMode(M),!0)),b)}static visitJointsOnChain(v,M,b=100){let E=v;if(E){let D=0;for(;void 0!==E;){if(D++>=b+5)return!0;if(!M(E))return!1;if(E=E.nextJoint,E===v)break}}return!0}annotateExtension(v){if(this.curve0&&this.curve1){const M=this.curve0.fractionToPointAndDerivative(1),b=this.curve1.fractionToPointAndDerivative(0);M.direction.z=b.direction.z=0;const E=Mt.closestApproachRay3dRay3d(M,b);if(E.approachType===Sr.Intersection&&E.detailA.fraction>=0&&E.detailB.fraction<=0){this.fraction0=1,this.fraction1=0,this.flexure=zr.Extend;const D=M.getDirectionRef().angleToXY(b.getDirectionRef());if(v.needArc(D)){const v=zi.constructArc(M,this.curve0.baseCurveEnd,b);if(v)return void(this.jointCurve=v)}const X=v.numChamferPoints(D);if(X<=1)return void(this.jointCurve=ke.create(M.origin,E.detailA.point,b.origin));if(X>1){const v=2*X,E=D.radians/v,z=zi.constructArc(M,this.curve0.baseCurveEnd,b);if(void 0!==z){const D=1/Math.cos(E),R=ke.create();this.jointCurve=R,R.addPoint(M.origin);for(let M=0;M<X;M++){const b=(1+2*M)/v;R.addPoint(z.fractionAndRadialFractionToPoint(b,D))}return void R.addPoint(b.origin)}}}this.flexure=zr.Gap,this.jointCurve=we.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0}}selectIntersectionIndexByFraction(v,M,b){let E=-1,D=Number.MAX_VALUE;for(let X=0;X<b.length;X++){const z=Math.abs(b[X].detailA.fraction-v)+Math.abs(b[X].detailB.fraction-M);z<D&&(D=z,E=X)}return E}annotateJointMode(v){if(!this.curve0&&this.curve1)this.flexure=zr.Cap,this.fraction1=0;else if(this.curve0&&!this.curve1)this.flexure=zr.Cap,this.fraction0=1;else if(this.curve0&&this.curve1)if(this.curve0.endPoint().isAlmostEqualXY(this.curve1.startPoint()))this.fraction0=1,this.fraction1=0,this.flexure=zr.Trim;else if(this.curve0 instanceof we&&this.curve1 instanceof we){const M=this.curve0.fractionToPointAndDerivative(0),b=this.curve1.fractionToPointAndDerivative(0);M.direction.z=b.direction.z=0;const E=Mt.closestApproachRay3dRay3d(M,b);E.approachType!==Sr.Intersection&&E.approachType!==Sr.PerpendicularChord||(this.fraction0=E.detailA.fraction,this.fraction1=E.detailB.fraction,this.fraction0>=1&&this.fraction1<=0?this.annotateExtension(v):this.fraction0<1&&this.fraction1>0?this.flexure=zr.Trim:this.fraction0>1&&this.fraction1>1&&(this.flexure=zr.Gap,this.jointCurve=we.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0))}else{const M=Xi.intersectionXYPairs(this.curve0,!1,this.curve1,!1),b=this.selectIntersectionIndexByFraction(1,0,M);b>=0?(this.flexure=zr.Trim,this.fraction0=M[b].detailA.fraction,this.fraction1=M[b].detailB.fraction):this.annotateExtension(v)}}static removeDegeneratePrimitives(v,M,b){let E=v,D=0,X=0;if(E)for(;void 0!==E&&X++<b;){const b=E.nextJoint;if(E&&b&&E.previousJoint&&b.nextJoint&&void 0!==E.fraction1&&void 0!==b.fraction0){const X=E.fraction1,z=b.fraction0,R=b.fraction1,O=b.nextJoint.fraction0,Y=X>=z||X>1;if(Y&&(void 0!==R&&R>1||void 0!==R&&void 0!==O&&R>=O)){const v=b.nextJoint,D=new zi(E.curve0,v.curve1,void 0);zi.link(E.previousJoint,D),zi.link(D,v.nextJoint),D.annotateJointMode(M),D.previousJoint.annotateJointMode(M),D.nextJoint&&D.nextJoint.annotateJointMode(M)}else if(Y){const X=new zi(E.curve0,b.curve1,void 0);if(zi.link(E.previousJoint,X),zi.link(X,b.nextJoint),X.annotateJointMode(M),X.previousJoint.annotateJointMode(M),X.nextJoint.annotateJointMode(M),D++,E===v&&(v=X),E=X,D>=1)return{newStart:v,numJointRemoved:D}}}if(E=E.nextJoint,E===v)break}return{newStart:v,numJointRemoved:D}}}class Ni{constructor(){}static createOffsetSegment(v,M,b){if($.createStartEnd(v,M,this._unitAlong),this._unitAlong.z=0,this._unitAlong.normalizeInPlace()){this._unitAlong.rotate90CCWXY(this._unitPerp);const E=we.create(v.plusScaled(this._unitPerp,b,this._offsetA),M.plusScaled(this._unitPerp,b,this._offsetB));return Yi.applyBasePoints(E,v.clone(),M.clone()),E}}constructPolygonWireXYOffset(v,M,b){M&&!v[0].isAlmostEqual(v[v.length-1])&&(M=!1);const E=Ae.create(b),D=v.length;let X,z,R;for(let N=0;N+1<D;++N)if(R){const M=Ni.createOffsetSegment(v[N],v[N+1],E.leftOffsetDistance);if(M){const b=new zi(X,M,v[N]);zi.link(R,b),R=b,X=M}}else(X=Ni.createOffsetSegment(v[N],v[N+1],E.leftOffsetDistance))&&(R=z=new zi(void 0,X,v[N]));if(!X||!R||!z)return;const O=M?z:new zi(X,void 0,v[D-1]);zi.link(R,O),zi.annotateChain(z,E,D);for(let N=0;N++<5;){const v=zi.removeDegeneratePrimitives(z,E,D);if(z=v.newStart,0===v.numJointRemoved)break}const Y=ke.create();return zi.collectStrokesFromChain(z,Y,D),Y.packedPoints.length>1?Y.packedPoints.front().isAlmostEqual(Y.packedPoints.back())?Oe.create(Y):Ve.create(Y):void 0}}Ni._unitAlong=$.create(),Ni._unitPerp=$.create(),Ni._offsetA=Q.create(),Ni._offsetB=Q.create();class Yi{constructor(){}static applyBasePoints(v,M,b){return void 0!==v&&(void 0!==M&&(v.baseCurveStart=M),void 0!==b&&(v.baseCurveEnd=b)),v}static createSingleOffsetPrimitiveXY(v,M){const b=v.constructOffsetXY(M);if(void 0!==b){if(Array.isArray(b)){const M=v.collectCurvePrimitives(void 0,!0,!0);if(M.length!==b.length)return;for(let v=0;v<M.length;++v)this.applyBasePoints(b[v],M[v].startPoint(),M[v].endPoint());return b}return this.applyBasePoints(b,v.startPoint(),v.endPoint())}}static constructCurveXYOffset(v,M){const b=v instanceof Oe,E=Se.create(M),D=[];for(const B of v.children){const v=Yi.createSingleOffsetPrimitiveXY(B,E);if(void 0===v);else if(v instanceof oe)D.push(v);else if(Array.isArray(v))for(const M of v)M instanceof oe&&D.push(M)}let X,z,R,O;for(const B of D)B&&(z=new zi(X,B,B.fractionToPoint(0)),void 0!==z&&void 0===O&&(O=z),R&&zi.link(R,z),R=z,X=B);O&&R&&v instanceof Oe&&zi.link(R,O);const Y=D.length;zi.annotateChain(O,E.jointOptions,Y);const N=[];return zi.collectCurvesFromChain(O,N,Y),lr.createLoopPathOrBagOfCurves(N,b,!0)}}class Oi{static sumLengths(v){let M=0;if(v instanceof oe)M+=v.curveLength();else if(v instanceof ze)M+=v.sumLengths();else if(Array.isArray(v))for(const b of v)M+=this.sumLengths(b);return M}static extendRange(v,M){if(Array.isArray(M))for(const b of M)this.extendRange(v,b);else M.extendRange(v);return v}static appendXYOffsets(v,M,b){let E=0;if(v instanceof oe){const D=Yi.constructCurveXYOffset(Ve.create(v),M);D&&(E+=this.sumLengths(D),b.push(D))}else if(v instanceof Oe||v instanceof Ve){const D=Yi.constructCurveXYOffset(v,M);D&&(E+=this.sumLengths(D),b.push(D))}else if(v instanceof Ye)for(const D of v.children)E+=this.appendXYOffsets(D,M,b);else if(Array.isArray(v))for(const D of v)E+=this.appendXYOffsets(D,M,b);return E}static collectInsideAndOutsideXYOffsets(v,M,b){const E=new Ri(b);for(const R of v)E.captureCurve(R);const D=E.grabResult(!0),X=[],z=[];return Oi.appendXYOffsets(D,M,X)>Oi.appendXYOffsets(D,-M,z)?{outsideOffsets:X,insideOffsets:z,chains:D}:{insideOffsets:X,outsideOffsets:z,chains:D}}static constructCurveXYOffset(v,M){return Yi.constructCurveXYOffset(v,M)}static createSingleOffsetPrimitiveXY(v,M){return Yi.createSingleOffsetPrimitiveXY(v,M)}static collectChains(v,M=K.smallMetricDistance,b=K.smallMetricDistance){const E=new Ri(M,b);for(const D of v)E.captureCurve(D);return E.grabResult(!0)}static collectChainsAsLineString3d(v,M,b,E=K.smallMetricDistance,D=K.smallMetricDistance){const X=new Ri(E,D);for(const z of v)X.captureCurve(z);X.announceChainsAsLineString3d(M,b)}}class Bi{constructor(){this.world=new Q,this.local=new Q,this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.world.setZero(),this.local.setZero(),this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(v){return void 0===v?v=new Bi:v.invalidate(),v}copyContentsFrom(v){this.world.setFrom(v.world),this.local.setFrom(v.local),this.a=v.a,this.closestEdgeIndex=v.closestEdgeIndex,this.closestEdgeParam=v.closestEdgeParam}get isValid(){return!this.local.isZero}get isInsideOrOn(){return this.isValid&&this.local.x>=0&&this.local.y>=0&&this.local.z>=0}get classify(){if(!this.isValid)return N.Unknown;if(this.isInsideOrOn){let v=0;return 0===Math.abs(this.local.x)&&++v,0===Math.abs(this.local.y)&&++v,0===Math.abs(this.local.z)&&++v,2===v?N.OnPolygonVertex:1===v?N.OnPolygonEdgeInterior:N.InsidePolygonProjectsToEdgeInterior}return 0===this.closestEdgeParam?N.OutsidePolygonProjectsToVertex:N.OutsidePolygonProjectsToEdgeInterior}}class Vi{constructor(v,M,b){this.points=[],this.points.push(v),this.points.push(M),this.points.push(b),this.edgeLength2=[],this.edgeLength2.push(M.distanceSquared(b)),this.edgeLength2.push(v.distanceSquared(b)),this.edgeLength2.push(v.distanceSquared(M))}set(v,M,b){this.points[0].setFromPoint3d(v),this.points[1].setFromPoint3d(M),this.points[2].setFromPoint3d(b),this.edgeLength2[0]=this.points[1].distanceSquared(this.points[2]),this.edgeLength2[1]=this.points[0].distanceSquared(this.points[2]),this.edgeLength2[2]=this.points[0].distanceSquared(this.points[1])}setFrom(v){for(let M=0;M<3;++M)this.points[M].setFromPoint3d(v.points[M]),this.edgeLength2[M]=v.edgeLength2[M]}static createXYZXYZXYZ(v,M,b,E,D,X,z,R,O,Y){return Y?(Y.points[0].set(v,M,b),Y.points[1].set(E,D,X),Y.points[2].set(z,R,O),Y):new this(Q.create(v,M,b),Q.create(E,D,X),Q.create(z,R,O))}static create(v,M,b,E){return E?(E.set(v,M,b),E):new this(v.clone(),M.clone(),b.clone())}clone(v){return Vi.create(this.points[0],this.points[1],this.points[2],v)}cloneTransformed(v,M){return Vi.create(v.multiplyPoint3d(this.points[0],M?.points[0]),v.multiplyPoint3d(this.points[1],M?.points[1]),v.multiplyPoint3d(this.points[2],M?.points[2]),M)}get area(){return.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2])}edgeLengthSquared(v){return this.edgeLength2[K.cyclic3dAxis(v)]}edgeLength(v){return Math.sqrt(this.edgeLengthSquared(v))}get aspectRatio(){return K.safeDivideFraction(this.area,this.edgeLengthSquared(0)+this.edgeLengthSquared(1)+this.edgeLengthSquared(2),0)}get perimeter(){return this.edgeLength(0)+this.edgeLength(1)+this.edgeLength(2)}normal(v){const M=this.points[0].crossProductToPoints(this.points[1],this.points[2],v);if(M.tryNormalizeInPlace())return M}fractionToPoint(v,M,b,E){return Q.createAdd3Scaled(this.points[0],v,this.points[1],M,this.points[2],b,E)}pointToFraction(v,M){const b=Vi._workVector0=this.normal(Vi._workVector0);if(void 0===b)return Bi.create(M);const E=Vi._workRay=Mt.create(v,b,Vi._workRay);return this.intersectRay3d(E,M)}static edgeOppositeVertexIndexToStartVertexIndex(v){return K.cyclic3dAxis(v+1)}static edgeStartVertexIndexToOppositeVertexIndex(v){return K.cyclic3dAxis(v-1)}static isInsideTriangle(v,M,b){return v>0&&M>0&&b>0}static isInsideOrOnTriangle(v,M,b){return v>=0&&M>=0&&b>=0}static isInRegionBeyondEdge(v,M,b){return v<0&&M>=0&&b>=0?0:v>=0&&M<0&&b>=0?1:v>=0&&M>=0&&b<0?2:-1}static isInRegionBeyondVertex(v,M,b){return M<0&&b<0?0:v<0&&b<0?1:v<0&&M<0?2:-1}static isOnVertex(v,M,b){return 1===v&&0===M&&0===b?0:0===v&&1===M&&0===b?1:0===v&&0===M&&1===b?2:-1}static isOnBoundedEdge(v,M,b){return 0===v&&M>0&&b>0?0:v>0&&0===M&&b>0?1:v>0&&M>0&&0===b?2:-1}static indexOfMinimum(v){let M=0,b=v(0);const E=v(1);return b>E&&(M=1,b=E),b>v(2)&&(M=2),M}distanceSquared(v,M,b,E,D,X){return-this.edgeLengthSquared(0)*(D-M)*(X-b)-this.edgeLengthSquared(1)*(X-b)*(E-v)-this.edgeLengthSquared(2)*(E-v)*(D-M)}closestVertexIndex(v,M,b){return Vi.indexOfMinimum((E=>{const D=Vi._workPoint=Q.createZero(Vi._workPoint);return D.setAt(E,1),this.distanceSquared(D.x,D.y,D.z,v,M,b)}))}dotProductOfEdgeVectorsAtVertex(v){const M=K.cyclic3dAxis(v),b=K.cyclic3dAxis(M+1),E=K.cyclic3dAxis(b+1);return K.dotProductXYZXYZ(this.points[b].x-this.points[M].x,this.points[b].y-this.points[M].y,this.points[b].z-this.points[M].z,this.points[E].x-this.points[M].x,this.points[E].y-this.points[M].y,this.points[E].z-this.points[M].z)}computeProjectionToEdge(v,M){v=K.cyclic3dAxis(v);const b=K.cyclic3dAxis(v+1);return M[K.cyclic3dAxis(b+1)]+M[v]*this.dotProductOfEdgeVectorsAtVertex(b)/this.edgeLengthSquared(v)}closestPoint(v,M,b){const E=[v,M,b];let D=-1,X=0;return Vi.isInsideTriangle(v,M,b)?(D=Vi.indexOfMinimum((v=>E[v]*E[v]/this.edgeLengthSquared(v))),X=this.computeProjectionToEdge(D,E)):(D=Vi.isInRegionBeyondVertex(v,M,b))>=0?(D=K.cyclic3dAxis(D+1),X=this.computeProjectionToEdge(D,E),(X<0||X>1)&&(D=K.cyclic3dAxis(D+1),X=this.computeProjectionToEdge(D,E),(X<0||X>1)&&(X=0,D=Vi.edgeStartVertexIndexToOppositeVertexIndex(this.closestVertexIndex(v,M,b))))):(D=Vi.isInRegionBeyondEdge(v,M,b))>=0?(X=this.computeProjectionToEdge(D,E),X<0?X=0:X>1&&(X=0,D=K.cyclic3dAxis(D+1))):(D=Vi.isOnBoundedEdge(v,M,b))>=0?X=1-E[Vi.edgeOppositeVertexIndexToStartVertexIndex(D)]:(D=Vi.isOnVertex(v,M,b))>=0&&(X=0,D=Vi.edgeStartVertexIndexToOppositeVertexIndex(D)),e(0===D||1===D||2===D),{closestEdgeIndex:D<0?-1:Vi.edgeOppositeVertexIndexToStartVertexIndex(D),closestEdgeParam:X}}intersectRay3d(v,M){M=Bi.create(M);const b=v.origin,E=v.direction,D=Vi._workVector0=$.createStartEnd(this.points[0],this.points[1],Vi._workVector0),X=Vi._workVector1=$.createStartEnd(this.points[0],this.points[2],Vi._workVector1),z=Vi._workMatrix=xt.createColumns(D,X,E,Vi._workMatrix),R=$.createStartEnd(this.points[0],b,Vi._workVector0),O=Vi._workVector1;if(void 0===z.multiplyInverse(R,O))return M;M.a=-O.z,v.fractionToPoint(M.a,M.world),M.local.set(1-O.x-O.y,O.x,O.y);const Y=this.closestPoint(M.local.x,M.local.y,M.local.z);return M.closestEdgeIndex=Y.closestEdgeIndex,M.closestEdgeParam=Y.closestEdgeParam,M}intersectSegment(v,M,b){return Vi._workRay=Mt.createStartEnd(v,M,Vi._workRay),this.intersectRay3d(Vi._workRay,b)}snapLocationToEdge(v,M=K.smallMetricDistance,b=K.smallFloatingPoint){if(!v.isValid)return!1;if(b>0){let M=0,E=0;for(let D=0;D<3;D++){const X=Math.abs(v.local.at(D));X>0&&X<b&&(v.local.setAt(D,0),M++),E+=v.local.at(D)}if(M>0&&E>0)return v.local.scaleInPlace(1/E),1===M?(v.closestEdgeIndex=Vi.edgeOppositeVertexIndexToStartVertexIndex(Vi.isOnBoundedEdge(v.local.x,v.local.y,v.local.z)),v.closestEdgeParam=1-v.local.at(v.closestEdgeIndex)):(v.closestEdgeIndex=Vi.isOnVertex(v.local.x,v.local.y,v.local.z),v.closestEdgeParam=0),this.fractionToPoint(v.local.x,v.local.y,v.local.z,v.world),!0}if(M>0){const b=v.closestEdgeIndex,E=(b+1)%3,D=(E+1)%3,X=Vi._workPoint=this.points[b].interpolate(v.closestEdgeParam,this.points[E],Vi._workPoint),z=v.world.distance(X);if(z>0&&z<M)return v.local.setAt(b,1-v.closestEdgeParam),v.local.setAt(E,v.closestEdgeParam),v.local.setAt(D,0),v.world.setFrom(X),!0}return!1}dotProductOfCrossProductsFromOrigin(v){return Vi._workVector0=this.points[0].crossProductToPoints(this.points[1],this.points[2],Vi._workVector0),Vi._workVector1=v.points[0].crossProductToPoints(v.points[1],v.points[2],Vi._workVector1),Vi._workVector0.dotProduct(Vi._workVector1)}centroid(v){return Q.create((this.points[0].x+this.points[1].x+this.points[2].x)/3,(this.points[0].y+this.points[1].y+this.points[2].y)/3,(this.points[0].z+this.points[1].z+this.points[2].z)/3,v)}incenter(v){const M=this.edgeLength(0),b=this.edgeLength(1),E=this.edgeLength(2),D=K.safeDivideFraction(1,M+b+E,0);return this.fractionToPoint(D*M,D*b,D*E,v)}circumcenter(v){const M=this.edgeLengthSquared(0),b=this.edgeLengthSquared(1),E=this.edgeLengthSquared(2),D=M*(b+E-M),X=b*(E+M-b),z=E*(M+b-E),R=K.safeDivideFraction(1,D+X+z,0);return this.fractionToPoint(R*D,R*X,R*z,v)}isAlmostEqual(v,M){return this.points[0].isAlmostEqual(v.points[0],M)&&this.points[1].isAlmostEqual(v.points[1],M)&&this.points[2].isAlmostEqual(v.points[2],M)}}class Li{constructor(v=0){this._parentArray=[];for(let M=0;M<v;M++)this._parentArray.push(M)}get length(){return this._parentArray.length}isValidIndex(v){return 0<=v&&v<this._parentArray.length}addLeaf(){const v=this._parentArray.length;return this._parentArray.push(v),v}findRoot(v){if(!this.isValidIndex(v))return v;let M=v,b=this._parentArray[v];for(;b!==M;)M=b,b=this._parentArray[M];const E=M;for(M=v;M!==E;)b=this._parentArray[M],this._parentArray[M]=E,M=b;return E}mergeSubsets(v,M){if(!this.isValidIndex(v)||!this.isValidIndex(M))return v;const b=this.findRoot(v),E=this.findRoot(M);return b!==E&&(this._parentArray[b]=E),this.findRoot(v)}askParent(v){return this.isValidIndex(v)?this._parentArray[v]:v}countRoots(){let v=0;const M=this._parentArray.length;for(let b=0;b<M;b++)this._parentArray[b]===b&&v++;return v}countNonTrivialPaths(){let v=0;const M=this._parentArray.length;for(let b=0;b<M;b++){const M=this._parentArray[b];M!==b&&this._parentArray[M]!==M&&v++}return v}collectRootIndices(){const v=[],M=this._parentArray.length;for(let b=0;b<M;b++)this._parentArray[b]===b&&v.push(b);return v}}class Ui{constructor(v,M){this._freeMasks=v,this._originalFreeMasks=v,this._firstFreeMask=M}static create(v){let M=0,b=1;for(let E=0;E<32;E++){if(0!=(b&v)){M=b;break}b<<=1}if(0!==M)return new Ui(v,M)}grabMask(){if(0===this._freeMasks)return 0;let v=this._firstFreeMask;for(;!(v&this._freeMasks);)v<<=1;return this._freeMasks&=~v,v}dropMask(v){v&=this._originalFreeMasks,this._freeMasks|=v}}(oo=Rr||(Rr={}))[oo.EXTERIOR=1]="EXTERIOR",oo[oo.BOUNDARY_EDGE=2]="BOUNDARY_EDGE",oo[oo.PRIMARY_EDGE=4]="PRIMARY_EDGE",oo[oo.VISITED=16]="VISITED",oo[oo.TRIANGULATED_FACE=256]="TRIANGULATED_FACE",oo[oo.NULL_FACE=512]="NULL_FACE",oo[oo.NULL_MASK=0]="NULL_MASK",oo[oo.ALL_GRAB_DROP_MASKS=4293918720]="ALL_GRAB_DROP_MASKS",oo[oo.ALL_MASK=4294967295]="ALL_MASK";class Zi{get id(){return this._id}get facePredecessor(){return this._facePredecessor}get faceSuccessor(){return this._faceSuccessor}get edgeMate(){return this._edgeMate}constructor(v=0,M=0,b=0,E=0){this._id=Zi._totalNodesCreated++,this.i=E,this.maskBits=0,this.x=v,this.y=M,this.z=b,this.sortAngle=void 0,this.sortData=void 0,this.edgeTag=void 0,this.faceTag=void 0,this._facePredecessor=this,this._faceSuccessor=this,this._edgeMate=this}faceStepY(v){let M=this;if(v>0)for(let b=0;b<v;b++)M=M.faceSuccessor;else if(v<0)for(let b=0;b>v;b--)M=M.facePredecessor;return M.y}static createHalfEdgePair(v){const M=new Zi,b=new Zi;return v&&(v.push(M),v.push(b)),Zi.setFaceLinks(M,b),Zi.setFaceLinks(b,M),Zi.setEdgeMates(M,b),M}static createHalfEdgePairWithCoordinates(v=0,M=0,b=0,E=0,D=0,X=0,z=0,R=0,O){const Y=Zi.createHalfEdgePair(O),N=Y._edgeMate;return Y.x=v,Y.y=M,Y.z=b,Y.i=E,N.x=D,N.y=X,N.z=z,N.i=R,Y}static setFaceLinks(v,M){v._faceSuccessor=M,M._facePredecessor=v}static setEdgeMates(v,M){v._edgeMate=M,M._edgeMate=v}static splitEdge(v,M=0,b=0,E=0,D=0,X){const z=new Zi(M,b,E,D),R=new Zi(M,b,E,D);if(X&&(X.push(z),X.push(R)),void 0===v)z._faceSuccessor=z._facePredecessor=z,R._faceSuccessor=R._facePredecessor=R,Zi.setEdgeMates(z,R);else{const M=v._faceSuccessor,b=v._edgeMate,E=b._faceSuccessor;Zi.setFaceLinks(z,M),Zi.setFaceLinks(v,z),Zi.setFaceLinks(b,R),Zi.setFaceLinks(R,E),Zi.setEdgeMates(z,b),Zi.setEdgeMates(R,v),this.transferEdgeProperties(v,z),this.transferEdgeProperties(b,R)}return z}static splitEdgeCreateSliverFace(v,M){const b=v.edgeMate,E=new Zi,D=new Zi;return M&&(M.push(E),M.push(D)),E._faceSuccessor=E._facePredecessor=D,D._faceSuccessor=D._facePredecessor=E,Zi.setEdgeMates(E,b),Zi.setEdgeMates(D,v),E.copyDataFrom(v,!0,!0,!1,!1),D.copyDataFrom(b,!0,!0,!1,!1),E}static transferEdgeProperties(v,M){M.edgeTag=v.edgeTag;for(const b of this._edgePropertyMasks)v.getMask(b)?M.setMask(b):M.clearMask(b)}get vertexSuccessor(){return this.facePredecessor.edgeMate}get vertexPredecessor(){return this.edgeMate.faceSuccessor}setMask(v){this.maskBits|=v}getMask(v){return this.maskBits&v}clearMask(v){this.maskBits&=~v}setMaskAroundVertex(v){let M=this;do{M.setMask(v),M=M.vertexSuccessor}while(M!==this)}setXYZAroundVertex(v,M,b){let E=this;do{E.x=v,E.y=M,E.z=b,E=E.vertexSuccessor}while(E!==this)}setMaskAroundFace(v){let M=this;do{M.setMask(v),M=M.faceSuccessor}while(M!==this)}setMaskAroundEdge(v){this.setMask(v),this.edgeMate.setMask(v)}clearMaskAroundEdge(v){this.clearMask(v),this.edgeMate.clearMask(v)}countEdgesAroundFace(){let v=0,M=this;do{v++,M=M.faceSuccessor}while(M!==this);return v}findAroundVertex(v){let M=this;do{if(M===v)return!0;M=M.vertexSuccessor}while(M!==this);return!1}findAroundFace(v){let M=this;do{if(M===v)return!0;M=M.faceSuccessor}while(M!==this);return!1}isMaskedAroundFace(v,M=!0){let b=this;if(M)do{if(!b.isMaskSet(v))return!1;b=b.faceSuccessor}while(b!==this);else do{if(b.isMaskSet(v))return!1;b=b.faceSuccessor}while(b!==this);return!0}setMaskAndEdgeTagAroundFace(v,M,b=!1){let E=this;do{if(E.setMask(v),E.edgeTag=M,b){const b=E.edgeMate;b.setMask(v),b.edgeTag=M}E=E.faceSuccessor}while(E!==this)}countEdgesAroundVertex(){let v=0,M=this;do{v++,M=M.vertexSuccessor}while(M!==this);return v}countMaskAroundFace(v,M=!0){let b=0,E=this;if(M)do{E.isMaskSet(v)&&b++,E=E.faceSuccessor}while(E!==this);else do{E.isMaskSet(v)||b++,E=E.faceSuccessor}while(E!==this);return b}countMaskAroundVertex(v,M=!0){let b=0,E=this;if(M)do{E.isMaskSet(v)&&b++,E=E.vertexSuccessor}while(E!==this);else do{E.isMaskSet(v)||b++,E=E.vertexSuccessor}while(E!==this);return b}findMaskAroundVertex(v,M=!0){let b=this;do{if(b.isMaskSet(v)===M)return b;b=b.vertexSuccessor}while(b!==this)}findMaskAroundFace(v,M=!0){let b=this;do{if(b.isMaskSet(v)===M)return b;b=b.faceSuccessor}while(b!==this)}findMaskAroundEdge(v,M=!0){if(this.isMaskSet(v)===M)return this;const b=this.edgeMate;return b.isMaskSet(v)===M?b:void 0}testAndSetMask(v){const M=this.maskBits&v;return this.maskBits|=v,M}setXYZFrom(v){this.x=v.x,this.y=v.y,this.z=v.z}setXYZ(v){this.x=v.x,this.y=v.y,this.z=v.z}isMaskSet(v){return 0!=(this.maskBits&v)}static filterIsMaskOn(v,M){return v.isMaskSet(M)}static filterIsMaskOff(v,M){return!v.isMaskSet(M)}static createEdgeXYXY(v,M,b,E,D,X){const z=new Zi(M,b),R=new Zi(D,X);return z._faceSuccessor=z._facePredecessor=z._edgeMate=R,R._faceSuccessor=R._facePredecessor=R._edgeMate=z,z._id=v,R._id=E,z}static pinch(v,M){if(v!==M){const b=v._facePredecessor,E=M._facePredecessor;M._facePredecessor=b,v._facePredecessor=E,E._faceSuccessor=v,b._faceSuccessor=M}}yankFromVertexLoop(){const v=this.edgeMate.faceSuccessor;if(v!==this)return Zi.pinch(this,v),v}decommission(){this._facePredecessor=void 0,this._faceSuccessor=void 0,this._edgeMate=void 0}static nodeToSelf(v){return v}static nodeToId(v){return v.id}static nodeToIdString(v){return v.id.toString()}static nodeToIdMaskXY(v){return{id:v.id,mask:Zi.nodeToMaskString(v),xy:[v.x,v.y]}}static nodeToIdXYString(v){return`${v.id.toString()}+${Zi.nodeToMaskString(v)}[${v.x},${v.y}]`}static nodeToIdXYZString(v){return`[${v.id.toString()}: ${v.x},${v.y},${v.z}]`}static nodeToMaskString(v){let M="";return v.isMaskSet(Rr.BOUNDARY_EDGE)&&(M+="B"),v.isMaskSet(Rr.PRIMARY_EDGE)&&(M+="P"),v.isMaskSet(Rr.EXTERIOR)&&(M+="X"),v.isMaskSet(Rr.NULL_FACE)&&(M+="N"),M}static nodeToXY(v){return[v.x,v.y]}vectorToFaceSuccessorXY(v){return J.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,v)}vectorToFaceSuccessor(v){const M=this.faceSuccessor;return $.create(M.x-this.x,M.y-this.y,M.z-this.z,v)}vectorToFacePredecessor(v){const M=this.facePredecessor;return $.create(M.x-this.x,M.y-this.y,M.z-this.z,v)}static isNodeVisibleInSector(v,M){if(M.vertexSuccessor===M)return!0;const b=M.faceSuccessor,E=M.facePredecessor,D=this.crossProductXYToTargets(M,b,v),X=this.crossProductXYToTargets(E,M,v);if(D>0&&X>0)return!0;const z=this.crossProductXYToTargets(E,M,b);return X<=0&&D<=0?0===X&&0===D&&0===z&&(E===b&&M.vertexSuccessor!==M?v===b:Zi.dotProductNodeToNodeVectorsXY(E,M,M,v)>0):0===z&&0!==X&&0!==D?E!==b:z<0}static crossProductXYToTargets(v,M,b){return K.crossProductXYXY(M.x-v.x,M.y-v.y,b.x-v.x,b.y-v.y)}static dotProductNodeToNodeVectorsXY(v,M,b,E){return K.dotProductXYXY(M.x-v.x,M.y-v.y,E.x-b.x,E.y-b.y)}static crossProductXYAlongChain(v,M,b){return K.crossProductXYXY(M.x-v.x,M.y-v.y,b.x-M.x,b.y-M.y)}static isSectorConvex(v,M,b,E=0){const D=.5*Zi.crossProductXYAlongChain(v,M,b);return E=E??0,Math.abs(D)<=Math.abs(E)?Zi.dotProductNodeToNodeVectorsXY(v,M,M,b)>0:D>-E}isSectorConvex(v){return void 0===v&&(v=K.smallMetricDistanceSquared*this.signedFaceArea()),Zi.isSectorConvex(this.facePredecessor,this,this.faceSuccessor,v)}isFaceConvex(v=K.smallMetricDistanceSquared){let M=this;const b=v>0?v*M.signedFaceArea():0;do{if(!M.isSectorConvex(b))return!1;M=M.faceSuccessor}while(M!==this);return!0}isolateEdge(){const v=this.edgeMate;this.yankFromVertexLoop(),v.yankFromVertexLoop()}get isIsolatedEdge(){return this===this.vertexSuccessor&&this.edgeMate===this.edgeMate.vertexSuccessor}belowYX(v){return this.y<v.y||!(this.y>v.y)&&this.x<v.x}static testNodeMaskNotExterior(v){return!v.isMaskSet(Rr.EXTERIOR)}static testMateMaskExterior(v){return v.edgeMate.isMaskSet(Rr.EXTERIOR)}static sectorSweepRadiansXYZ(v,M){const b=v.faceSuccessor,E=v.facePredecessor;return W.orientedRadiansBetweenVectorsXYZ(b.x-v.x,b.y-v.y,b.z-v.z,E.x-v.x,E.y-v.y,E.z-v.z,M.x,M.y,M.z,!0)}static testFacePositiveAreaXY(v){return v.countEdgesAroundFace()>2&&v.signedFaceArea()>0}isEqualXY(v){return this.x===v.x&&this.y===v.y}distanceXY(v){return K.distanceXYXY(this.x,this.y,v.x,v.y)}distanceXYZ(v){return K.distanceXYZXYZ(this.x,this.y,this.z,v.x,v.y,v.z)}collectAroundFace(v){const M=[];let b=this;do{M.push(v?v(b):b),b=b.faceSuccessor}while(b!==this);return M}collectMaskedEdgesAroundVertex(v,M=!0,b){void 0===b?b=[]:b.length=0;let E=this;do{E.isMaskSet(v)===M&&b.push(E),E=E.vertexSuccessor}while(E!==this);return b}collectAroundVertex(v){const M=[];let b=this;do{M.push(v?v(b):b),b=b.vertexSuccessor}while(b!==this);return M}sumAroundFace(v){let M=this,b=0;do{b+=v(M),M=M.faceSuccessor}while(M!==this);return b}sumAroundVertex(v){let M=this,b=0;do{b+=v(M),M=M.vertexSuccessor}while(M!==this);return b}clearMaskAroundFace(v){let M=this;do{M.clearMask(v),M=M.faceSuccessor}while(M!==this)}clearMaskAroundVertex(v){let M=this;do{M.clearMask(v),M=M.vertexSuccessor}while(M!==this)}signedFaceArea(){let v=0,M=this.x,b=0;const E=this.y;let D,X=0,z=0,R=this;do{D=R.faceSuccessor,b=D.x,z=D.y-E,v+=(M-b)*(X+z),M=b,X=z,R=D}while(R!==this);return.5*v}fractionToPoint2d(v,M){const b=this.faceSuccessor;return H.create(this.x+(b.x-this.x)*v,this.y+(b.y-this.y)*v,M)}fractionToPoint3d(v,M){const b=this.faceSuccessor;return Q.create(this.x+(b.x-this.x)*v,this.y+(b.y-this.y)*v,this.z+(b.z-this.z)*v,M)}fractionAlongAndPerpendicularToPoint2d(v,M,b){const E=this.faceSuccessor,D=E.x-this.x,X=E.y-this.y;return H.create(this.x+D*v-X*M,this.y+X*v+D*M,b)}getPoint3d(v){return Q.create(this.x,this.y,this.z,v)}getPoint2d(v){return H.create(this.x,this.y,v)}getVector3dAlongEdge(v){const M=this.faceSuccessor;return $.create(M.x-this.x,M.y-this.y,M.z-this.z,v)}getVector2dAlongEdge(v){const M=this.faceSuccessor;return J.create(M.x-this.x,M.y-this.y,v)}fractionToX(v){const M=this.faceSuccessor;return this.x+(M.x-this.x)*v}fractionToY(v){const M=this.faceSuccessor;return this.y+(M.y-this.y)*v}fractionToZ(v){const M=this.faceSuccessor;return this.z+(M.z-this.z)*v}static transverseIntersectionFractions(v,M,b){const E=v.faceSuccessor,D=M.faceSuccessor;if(b||(b=J.create()),Ft.linearSystem2d(E.x-v.x,M.x-D.x,E.y-v.y,M.y-D.y,M.x-v.x,M.y-v.y,b))return b}static horizontalScanFraction(v,M){const b=v.faceSuccessor,E=b.y-v.y;return K.isSameCoordinate(M,v.y)&&K.isSameCoordinate(M,b.y)?v:K.isSameCoordinate(E,0)?void 0:K.conditionalDivideFraction(M-v.y,E)}static horizontalScanFraction01(v,M){const b=v.faceSuccessor,E=b.y-v.y;if(K.isSameCoordinate(M,v.y)&&K.isSameCoordinate(M,b.y))return;if(K.isSameCoordinate(E,0))return;const D=K.conditionalDivideFraction(M-v.y,E);return void 0!==D&&D>=0&&D<=1?D:void 0}copyDataFrom(v,M,b,E,D){M&&(this.x=v.x,this.y=v.y,this.z=v.z),b&&(this.i=v.i),E&&(Zi.transferEdgeProperties(v,this),this.edgeTag=v.edgeTag),D&&(this.faceTag=v.faceTag)}}Zi._totalNodesCreated=0,Zi._edgePropertyMasks=[Rr.BOUNDARY_EDGE,Rr.EXTERIOR,Rr.PRIMARY_EDGE,Rr.NULL_FACE];class qi{constructor(){this._numNodesCreated=0,this.allHalfEdges=[],this._maskManager=Ui.create(Rr.ALL_GRAB_DROP_MASKS)}grabMask(v=!0){const M=this._maskManager.grabMask();return v&&this.clearMask(M),M}dropMask(v){this._maskManager.dropMask(v)}createEdgeXYZXYZ(v=0,M=0,b=0,E=0,D=0,X=0,z=0,R=0){return Zi.createHalfEdgePairWithCoordinates(v,M,b,E,D,X,z,R,this.allHalfEdges)}createEdgeIdId(v=0,M=0){return Zi.createHalfEdgePairWithCoordinates(0,0,0,v,0,0,0,M,this.allHalfEdges)}createEdgeXYZHalfEdge(v=0,M=0,b=0,E=0,D,X=0){const z=Zi.createHalfEdgePairWithCoordinates(v,M,b,E,D.x,D.y,D.z,X,this.allHalfEdges),R=z.faceSuccessor;return Zi.pinch(D,R),z}createEdgeHalfEdgeHalfEdge(v,M,b,E=0){const D=Zi.createHalfEdgePairWithCoordinates(v.x,v.y,v.z,M,b.x,b.y,b.z,E,this.allHalfEdges),X=D.faceSuccessor;return Zi.pinch(v,D),Zi.pinch(b,X),D}createEdgeXYAndZ(v,M,b,E){return Zi.createHalfEdgePairWithCoordinates(v.x,v.y,v.z,M,b.x,b.y,b.z,E,this.allHalfEdges)}splitEdge(v,M=0,b=0,E=0,D=0){return Zi.splitEdge(v,M,b,E,D,this.allHalfEdges)}splitEdgeCreateSliverFace(v){return Zi.splitEdgeCreateSliverFace(v,this.allHalfEdges)}splitEdgeAtFraction(v,M){return Zi.splitEdge(v,v.fractionToX(M),v.fractionToY(M),v.fractionToZ(M),0,this.allHalfEdges)}decommission(){for(const v of this.allHalfEdges)v.decommission();this.allHalfEdges.length=0,this.allHalfEdges=void 0}addEdgeXY(v,M,b,E){const D=Zi.createEdgeXYXY(this._numNodesCreated,v,M,this._numNodesCreated+1,b,E);return this._numNodesCreated+=2,this.allHalfEdges.push(D),this.allHalfEdges.push(D.faceSuccessor),D}clearMask(v){for(const M of this.allHalfEdges)M.maskBits&=~v}setMask(v){for(const M of this.allHalfEdges)M.maskBits|=v}reverseMask(v){for(const M of this.allHalfEdges)M.maskBits^=v}countMask(v){let M=0;for(const b of this.allHalfEdges)b.isMaskSet(v)&&M++;return M}collectSegments(){const v=[];for(const M of this.allHalfEdges)M.id<M.edgeMate.id&&v.push(we.create(Q.create(M.x,M.y),Q.create(M.faceSuccessor.x,M.faceSuccessor.y)));return v}countVertexLoops(){this.clearMask(Rr.VISITED);let v=0;return this.announceVertexLoops(((M,b)=>(v++,!0))),v}countFaceLoops(){this.clearMask(Rr.VISITED);let v=0;return this.announceFaceLoops(((M,b)=>(v++,!0))),v}countFaceLoopsWithMaskFilter(v,M){this.clearMask(Rr.VISITED);let b=0;return this.announceFaceLoops(((E,D)=>(v(D,M)&&b++,!0))),b}collectVertexLoops(){const v=[];return this.announceVertexLoops(((M,b)=>(v.push(b),!0))),v}collectFaceLoops(){const v=[];return this.announceFaceLoops(((M,b)=>(v.push(b),!0))),v}announceVertexLoops(v){this.clearMask(Rr.VISITED);for(const M of this.allHalfEdges)if(!M.getMask(Rr.VISITED)&&(M.setMaskAroundVertex(Rr.VISITED),!v(this,M)))break}announceFaceLoops(v){this.clearMask(Rr.VISITED);for(const M of this.allHalfEdges)if(!M.getMask(Rr.VISITED)&&(M.setMaskAroundFace(Rr.VISITED),!v(this,M)))break}announceEdges(v){this.clearMask(Rr.VISITED);for(const M of this.allHalfEdges){if(M.getMask(Rr.VISITED))continue;const b=M.edgeMate;if(M.setMask(Rr.VISITED),b.setMask(Rr.VISITED),!v(this,M))break}}announceNodes(v){for(const M of this.allHalfEdges)if(!v(this,M))break}countNodes(){return this.allHalfEdges.length}transformInPlace(v){for(const M of this.allHalfEdges)v.multiplyXYAndZInPlace(M)}yankAndDeleteEdges(v){const M=this.allHalfEdges.length;let b=0;for(let D=0;D<M;D++){const M=this.allHalfEdges[D];v(M)?M.yankFromVertexLoop():this.allHalfEdges[b++]=M}const E=M-b;return this.allHalfEdges.length=b,E}deleteIsolatedEdges(){const v=this.allHalfEdges.length;let M=0;for(let E=0;E<v;E++){const v=this.allHalfEdges[E];v.isIsolatedEdge||(this.allHalfEdges[M++]=v)}const b=v-M;return this.allHalfEdges.length=M,b}}class Wi{constructor(v,M=Z){this._array=[],this._compare=v,this._clone=M}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}_swap(v,M){const b=this._array[v];this._array[v]=this._array[M],this._array[M]=b}_heapify(v){let M=-1;for(;;){const b=2*(v+1),E=b-1;if(M=E<this.length&&this._compare(this._array[E],this._array[v])<0?E:v,b<this.length&&this._compare(this._array[b],this._array[M])<0&&(M=b),M===v)break;this._swap(M,v),v=M}}sort(){for(let v=Math.ceil(this.length/2);v>=0;v--)this._heapify(v)}push(v){const M=this._clone(v);let b=this.length;for(this._array.push(M);0!==b;){const v=Math.floor((b-1)/2);if(!(this._compare(this._array[b],this._array[v])<0))break;this._swap(b,v),b=v}return M}append(v){const M=this._clone(v);return this._array.push(M),M}get front(){return this._peek(0)}pop(){return this._pop(0)}clear(){this._array.length=0}_pop(v){if(v<0||v>=this.length)return;const M=this._array[v];return this._swap(v,this.length-1),this._array.length--,this._heapify(v),M}_peek(v){return v<0||v>=this.length?void 0:this._array[v]}}class Gi{constructor(v=((v,M)=>ws.compareNodesYXUp(v,M))){this.priorityQueue=new Wi(v),this.activeEdges=[]}popQueueToArray(){if(this.priorityQueue.isEmpty)return;const v=this.priorityQueue.pop();return this.activeEdges.push(v),v}popArrayToArrayIndex(v){if(v<this.activeEdges.length){const M=this.activeEdges.pop();this.activeEdges[v]=M}}removeArrayMembersWithY1Below(v){let M=0;const b=this.activeEdges.length;for(let E=0;E<b;E++){const b=this.activeEdges[E];b.faceSuccessor.y>=v&&(M<E&&(this.activeEdges[M]=b),M++)}this.activeEdges.length=M}}class Hi{constructor(v){this.graph=v,this.upEdges=[],this.downEdges=[],this.bottomPeaks=[],this.topPeaks=[],this.localMin=[],this.localMax=[]}collectVerticalEventsAroundFace(v){let M,b,E,D,X=v;this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0;do{M=X.faceSuccessor,b=M.faceSuccessor,E=ws.compareNodesYXUp(X,M)<0,D=ws.compareNodesYXUp(M,b)<0,E?(this.upEdges.push(X),D||(ws.crossProductToTargets(M,X,b)<0?this.localMax.push(M):this.topPeaks.push(M))):(this.downEdges.push(X),D&&(ws.crossProductToTargets(M,X,b)>0?this.bottomPeaks.push(M):this.localMin.push(M))),X=M}while(X!==v)}collectVerticalEventFromEdgesInAndArray(v){let M,b,E,D,X;for(M of(this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0,v))b=M.faceSuccessor,E=b.faceSuccessor,D=ws.compareNodesYXUp(M,b)<0,X=ws.compareNodesYXUp(b,E)<0,D?(this.upEdges.push(M),X||(ws.crossProductToTargets(b,M,E)<0?this.localMax.push(b):this.topPeaks.push(b))):(this.downEdges.push(M),X&&(ws.crossProductToTargets(b,M,E)>0?this.bottomPeaks.push(b):this.localMin.push(b)))}swapArrays(){let v=this.downEdges;this.downEdges=this.upEdges,this.upEdges=v,v=this.localMax,this.localMax=this.localMin,this.localMin=v,v=this.topPeaks,this.topPeaks=this.bottomPeaks,this.bottomPeaks=v}findTopVisibleEdge(v,M,b){const E=v.y,D=v.x;let X,z,R=Number.MAX_SAFE_INTEGER;for(const O of M){const M=O.faceSuccessor;if(O===v||M===v)continue;if(ws.compareNodesYXUp(v,O)*ws.compareNodesYXUp(v,M)>=0)continue;const Y=Zi.horizontalScanFraction01(O,E);void 0!==Y&&(X=b*(O.fractionToX(Y)-D),X>0&&X<R&&(z=O,R=X))}return z}highestUpPeakConnection(v,M,b){let E;for(const D of this.topPeaks){const X=D.y,z=D.x;if(!(void 0!==E&&ws.compareNodesYXUp(D,E)<0)&&ws.compareNodesYXUp(D,v)<0){if(M){const v=Zi.horizontalScanFraction01(M,X);if(void 0===v)continue;if(z<=M.fractionToX(v))continue}if(b){const v=Zi.horizontalScanFraction01(b,X);if(void 0===v)continue;if(b.fractionToX(v)<=z)continue}E=D}}return E}updateMaxNode(v,M,b){return v?M&&b(v,M)<0?M:v:M}negateXY(){for(const v of this.graph.allHalfEdges)v.x*=-1,v.y*=-1}downwardConnectionFromBottomPeak(v){let M;const i=(v,M)=>ws.compareNodesYXUp(v,M),b=this.findTopVisibleEdge(v,this.upEdges,1),E=this.findTopVisibleEdge(v,this.downEdges,-1);M=this.updateMaxNode(M,b,i),E&&(M=this.updateMaxNode(M,E.faceSuccessor,i));const D=this.highestUpPeakConnection(v,E,b);return void 0!==D&&(M=this.updateMaxNode(M,D,i)),M}findVisibleSector(v,M){let b=v;do{if(Zi.isNodeVisibleInSector(M,b))return b;b=b.vertexSuccessor}while(b!==v)}joinNodes(v,M,b){const E=this.graph.createEdgeXYZXYZ(v.x,v.y,v.z,0,M.x,M.y,M.z,0),D=this.findVisibleSector(v,M),X=this.findVisibleSector(M,v);if(void 0!==D&&void 0!==X)return Zi.pinch(D,E),Zi.pinch(X,E.edgeMate),Hi.announceEdge&&Hi.announceEdge(this.graph,v,M,b),E}runRegularization(v=!0,M=!0){if(v){this.bottomPeaks.sort(((v,M)=>ws.compareNodesYXUp(v,M)));for(const v of this.bottomPeaks){if(!ws.isDownPeak(v))continue;const M=this.downwardConnectionFromBottomPeak(v);void 0!==M&&this.joinNodes(v,M,1)}}if(M){this.negateXY(),this.swapArrays(),this.bottomPeaks.sort(((v,M)=>ws.compareNodesYXUp(v,M)));for(const v of this.bottomPeaks){if(!ws.isDownPeak(v))continue;const M=this.downwardConnectionFromBottomPeak(v);void 0!==M&&this.joinNodes(v,M,-1)}this.negateXY(),this.swapArrays()}}regularizeFace(v,M=!0,b=!0){this.collectVerticalEventsAroundFace(v),this.runRegularization(M,b)}regularizeGraph(v=!0,M=!0){this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges),this.runRegularization(v,M)}static isMonotoneFace(v){let M,b=0,E=0,D=v;do{const v=D.faceSuccessor,X=v.faceSuccessor,z=ws.compareNodesYXUp(D,v),R=ws.compareNodesYXUp(v,X);z*R<=0&&(z>0&&(b++,M=v),R>0&&E++)}while((D=D.faceSuccessor)!==v);return 1===b&&1===E?M:void 0}static collectMappedFaceRepresentatives(v,M,b,E,D){E&&(E.length=0),D&&(D.length=0);const X=Rr.VISITED;v.clearMask(X);for(const z of v.allHalfEdges)if(!z.getMask(X)&&(z.setMaskAroundFace(X),!M||z.signedFaceArea()>0)){const v=b(z);v?E&&E.push(v):D&&D.push(z)}}}class Ji extends ze{isSameGeometryClass(v){return v instanceof Ji}get children(){return this._children}constructor(){super(),this.curveCollectionType="unionRegion",this._children=[]}static create(...v){const M=new Ji;for(const b of v)M.tryAddChild(b);return M}dgnBoundaryType(){return 5}announceToCurveProcessor(v,M=-1){return v.announceUnionRegion(this,M)}cloneStroked(v){const M=new Ji;let b;for(b of this._children){const E=b.cloneStroked(v);E&&M.children.push(E)}return M}cloneEmptyPeer(){return new Ji}tryAddChild(v){return!(!v||!(v instanceof ii||v instanceof Oe)||(this._children.push(v),0))}getChild(v){if(v<this._children.length)return this._children[v]}dispatchToGeometryHandler(v){return v.handleUnionRegion(this)}}class Ki{constructor(){this._cachedObjects=[],this.numDrop=0,this.numCreate=0,this.numReuse=0}dropToCache(v){v&&(this.numDrop++,this.clearForCache(v),this._cachedObjects.push(v))}grabFromCache(){let v=this._cachedObjects.pop();return void 0===v?(v=this.createForCache(),this.numCreate++):this.numReuse++,v}dropAllToCache(v){for(;v.length>0;)this.dropToCache(v.pop())}}class ji extends Ki{clearForCache(v){v.length=0}createForCache(){return new nt(10)}constructor(){super()}grabAndFill(v){const M=this.grabFromCache();return M.pushFrom(v),M}}class Qi{get convexSets(){return this._convexSets}constructor(){this._convexSets=[]}toJSON(){const v=[];for(const M of this._convexSets)v.push(M.toJSON());return v}static fromJSON(v,M){if((M=M||new Qi)._convexSets.length=0,!Array.isArray(v))return M;for(const b of v)M._convexSets.push(an.fromJSON(b));return M}static createEmpty(v){return v?(v._convexSets.length=0,v):new Qi}isAlmostEqual(v){if(this._convexSets.length!==v._convexSets.length)return!1;for(let M=0;M<this._convexSets.length;M++)if(!this._convexSets[M].isAlmostEqual(v._convexSets[M]))return!1;return!0}static createConvexSets(v,M){M=M||new Qi;for(const b of v)M._convexSets.push(b);return M}clone(v){(v=v||new Qi)._convexSets.length=0;for(const M of this._convexSets)v._convexSets.push(M.clone());return v}addConvexSet(v){v&&this._convexSets.push(v)}hasIntersectionWithRay(v,M){if(void 0===M){for(const M of this._convexSets)if(M.hasIntersectionWithRay(v))return!0;return!1}M.setNull();const b=ft.createNull();for(const E of this._convexSets)E.hasIntersectionWithRay(v,b)&&M.extendRange(b);return!M.isNull}isPointInside(v){for(const M of this._convexSets)if(M.isPointInside(v))return!0;return!1}isPointOnOrInside(v,M=K.smallMetricDistance){for(const b of this._convexSets)if(b.isPointOnOrInside(v,M))return!0;return!1}isSphereInside(v,M){for(const b of this._convexSets)if(b.isSphereInside(v,M))return!0;return!1}isAnyPointInOrOnFromSegment(v){for(const M of this._convexSets)if(M.announceClippedSegmentIntervals(0,1,v.point0Ref,v.point1Ref))return!0;return!1}appendIntervalsFromSegment(v,M){for(const b of this._convexSets)b.announceClippedSegmentIntervals(0,1,v.point0Ref,v.point1Ref,((v,b)=>M.push(We.create(v,b))))}transformInPlace(v){for(const M of this._convexSets)M.transformInPlace(v)}classifyPointContainment(v,M){for(const b of this._convexSets){const E=b.classifyPointContainment(v,M);if(E!==Nr.StronglyOutside)return E}return Nr.StronglyOutside}polygonClip(v,M){M.length=0,Array.isArray(v)&&(v=nt.create(v));const b=new nt;for(const E of this._convexSets){const D=new nt;E.polygonClip(v,D,b),0!==D.length&&M.push(D)}}announceClippedSegmentIntervals(v,M,b,E,D){let X=0;for(const z of this._convexSets)z.announceClippedSegmentIntervals(v,M,b,E,D)&&X++;return X>0}announceClippedArcIntervals(v,M){const b=Qi._clipArcFractionArray;b.clear();for(const E of this._convexSets)for(const M of E.planes)M.appendIntersectionRadians(v,b);return v.sweep.radiansArrayToPositivePeriodicFractions(b),ds.selectIntervals01(v,b,this,M)}computePlanePlanePlaneIntersectionsInAllConvexSets(v,M,b,E=!0){let D=0;for(const X of this._convexSets)D+=X.computePlanePlanePlaneIntersections(v,M,b,E);return D}multiplyPlanesByMatrix4d(v,M=!0,b=!0){if(M){const M=v.createInverse();return!!M&&this.multiplyPlanesByMatrix4d(M,!1,b)}for(const E of this._convexSets)E.multiplyPlanesByMatrix4d(v,!1,b);return!0}setInvisible(v){for(const M of this._convexSets)M.setInvisible(v)}addOutsideZClipSets(v,M,b){if(M){const b=an.createEmpty();b.addZClipPlanes(v,M),this._convexSets.push(b)}if(b){const M=an.createEmpty();M.addZClipPlanes(v,void 0,b),this._convexSets.push(M)}}takeConvexSets(v){let M;for(;void 0!==(M=v._convexSets.pop());)this._convexSets.push(M)}appendPolygonClip(v,M,b,E){const D=b.length,X=M.length;let z,R,O=[E.grabAndFill(v)],Y=[];for(const N of this._convexSets){for(;void 0!==(R=O.pop());)N.appendPolygonClip(R,M,Y,E),E.dropToCache(R);z=Y,Y=O,O=z}for(;void 0!==(R=O.pop());)b.push(R);b.length===D?ds.restoreSingletonInPlaceOfMultipleShards(M,X,v,E):M.length===X&&ds.restoreSingletonInPlaceOfMultipleShards(b,D,v,E)}}Qi._clipArcFractionArray=new At;class $i{static advanceIntervalDifference(v,M,b,E){const D=M.length;let X=v.low,z=v.high;for(;b<D;){const v=M[b];if(v.high<X)b++;else{if(!(v.high<=z)){v.low<z&&(z=v.low);break}v.low>X&&E.push(ft.createXX(X,v.low)),X=v.high,b++}}return X<z&&E.push(ft.createXX(X,z)),E}static differenceSorted(v,M){const b=v.length,E=[];for(let D=0;D<b;D++)$i.advanceIntervalDifference(v[D],M,0,E);return E}static advanceIntervalIntersection(v,M,b){return M.low>v.high||(M.high>=v.high?(b.push(ft.createXX(M.low,v.high)),!0):(b.push(ft.createXX(M.low,M.high)),!1))}static intersectSorted(v,M){let b=0,E=0;const D=v.length,X=M.length,z=[];for(;b<D&&E<X;){const D=v[b],X=M[E];D.low<=X.low?$i.advanceIntervalIntersection(D,X,z)?b++:E++:$i.advanceIntervalIntersection(X,D,z)?E++:b++}return z}static advanceIntervalUnion(v,M,b){if(b>=M.length)return!1;const E=M[b];return!(E.low>v.high||(E.high>v.high&&(v.high=E.high),0))}static unionSorted(v,M){const b=v.length,E=M.length;let D=0,X=0;const z=[];for(;D<b&&X<E;){const b=v[D],E=M[X];let R;b.low<=E.low?(R=b.clone(),D++):(R=E.clone(),X++);let O=!0;do{const b=$i.advanceIntervalUnion(R,v,D),E=$i.advanceIntervalUnion(R,M,X);b&&D++,E&&X++,b||E||(O=!1)}while(O);z.push(R)}for(;D<b;)z.push(v[D++]);for(;X<E;)z.push(M[X++]);return z}static paritySorted(v,M){const b=[];for(const E of v)b.push(E.clone());for(const E of M)b.push(E.clone());return b.sort(ts),$i.simplifySortParity(b,!0),b}static sort(v){v.sort(ts)}static simplifySortUnion(v,M=!1){if(v.length<2)return;v.sort(ts);let b=0;for(let E=1;E<v.length;E++)v[E].low<=v[b].high?v[E].high>v[b].high&&(v[b].high=v[E].high):(b++,v[b].setFrom(v[E]));if(v.length=b+1,M){b=-1;for(let M=0;M<v.length;M++)v[M].low<v[M].high&&b<M&&v[++b].setFrom(v[M])}}static simplifySortParity(v,M=!1){const b=[];for(const R of v)R.low!==R.high&&(b.push(R.low),b.push(R.high));const E=b.length;b.sort(((v,M)=>v<M?-1:v>M?1:0));let D,X,z=0;for(let R=0;R<E;R+=2)if(D=b[R],X=b[R+1],M){for(;R+2<E&&b[R+2]===X;)R+=2,X=b[R+1];X>D&&ft.createXX(D,X,v[z++])}else ft.createXX(D,X,v[z++]);v.length=z}static testUnion(v,M){return this.countContainingRanges(v,M)>0}static testParity(v,M){let b=!1;for(const E of v)E.containsX(M)&&(b=!b);return b}static countContainingRanges(v,M){let b=0;for(const E of v)E.containsX(M)&&b++;return b}static getBreaks(v,M,b=!1,E=!1,D=!0){M||(M=new At(2*v.length)),D&&M.clear();for(const X of v)M.push(X.low),M.push(X.high);return b&&M.sort(),E&&M.compressAdjacentDuplicates(),M}static appendFractionalPoints(v,M,b,E,D,X,z,R){const O=v.length;if(O>0){void 0!==M&&R.push(v[0].fractionToPoint(M));for(let M=0;M<O;M++)void 0===b||!E&&v[M].low===v[M].high||R.push(v[M].fractionToPoint(b)),M>1&&void 0!==D&&(X||v[M].low!==v[M].high)&&R.push(K.interpolate(v[M-1].high,D,v[M].low));void 0!==z&&R.push(v[O-1].fractionToPoint(z))}return R}static firstLowToLastHigh(v){return 0===v.length?ft.createNull():ft.createXX(v[0].low,v[v.length-1].high)}static sumLengths(v){let M=0;for(const b of v)M+=b.length();return M}static isSorted(v,M=!0){const b=v.length;if(M){for(let E=0;E+1<b;E++)if(v[E].high>=v[E+1].low)return!1}else for(let E=0;E+1<b;E++)if(v[E].high>v[E+1].low)return!1;return!0}}function ts(v,M){return v.low<M.low?-1:v.low>M.low?1:v.high<M.high?-1:v.high>M.high?1:0}class es{constructor(){this.points=[],this.planes=an.createEmpty(),this.children=[],this.startIdx=-1,this.numPoints=-1}static createWithIndices(v,M,b){return(b=b||new es).startIdx=v,b.numPoints=M,b.children.length=0,b}static createTreeForPolygon(v,M){return(M=M||new es).empty(),is.createPointsRef(v).buildHullTree(M),M}static createHullAndInletsForPolygon(v,M){return(M=M||new es).empty(),is.createPointsRef(v).buildHullAndInletsForPolygon(M),M}extractLoopsGo(v){v.push(de.clonePoint3dArray(this.points));for(const M of this.children)M.extractLoopsGo(v)}extractLoops(){const v=[];return this.extractLoopsGo(v),v}empty(){this.points.length=0,this.planes.planes.length=0,this.children.length=0,this.startIdx=-1,this.numPoints=-1}clone(v){v=v||new es;for(const M of this.points)v.points.push(M.clone());v.planes=an.createEmpty();for(const M of this.planes.planes)v.planes.planes.push(M.clone());for(const M of this.children)v.children.push(M.clone());return v.startIdx=this.startIdx,v.numPoints=this.numPoints,v}addEmptyChild(v,M){const b=es.createWithIndices(v,M);this.children.push(b)}addPlane(v){this.planes.addPlaneToConvexSet(v)}isPointOnOrInside(v){if(!this.planes.isPointOnOrInside(v,0))return!1;for(const M of this.children)if(M.isPointOnOrInside(v))return!1;return!0}captureConvexClipPlaneSetAsVoid(v){this.children.push(v)}appendCurvePrimitiveClipIntervals(v,M,b){(new ss).appendSingleClipPrimitive(this,v,M,b)}appendCurveCollectionClipIntervals(v,M,b){(new ss).appendCurveCollectionClip(this,v,M,b)}appendPolygonClip(v,M,b,E){const D=b.length,X=this.planes.clipInsidePushOutside(v,b,E);if(void 0===X)ds.restoreSingletonInPlaceOfMultipleShards(b,D,v,E);else{let v,D,z=[X],R=[];for(const M of this.children){for(R.length=0;void 0!==(D=z.pop());)M.appendPolygonClip(D,b,R,E),E.dropToCache(D);v=R,R=z,z=v}for(;void 0!==(D=z.pop());)M.push(D)}}depth(){let v=0;for(const M of this.children)v=Math.max(v,M.depth());return 1+v}}class is{constructor(){this._points=[],this._stack=[]}static createPointsRef(v,M){return(M=M||new is)._points=v,vr.areaXY(v)<0&&M._points.reverse(),M._points[M._points.length-1].isAlmostEqualMetric(M._points[0])&&M._points.pop(),M}get period(){return this._points.length}indexAfter(v){return(v+1)%this._points.length}indexBefore(v){return(v+this._points.length-1)%this._points.length}pushIndex(v){this._stack.push(v)}static cross(v,M,b){return v.crossProductToPointsXY(M,b)}cyclicStackPoint(v){let M;const b=this._stack;return M=v>0?v:v+10*b.length,M%=b.length,this._points[b[M]]}signFromStackTip(v,M){const b=this.cyclicStackPoint(-2),E=this.cyclicStackPoint(-1),D=this._points[v];return M*is.cross(b,E,D)>=0?1:-1}get indexOfMaxX(){let v=0;const M=this._points,b=this._points.length;for(let E=1;E<b;E++)M[E].x>M[v].x&&(v=E);return v}extendHullChain(v,M,b){for(;this._stack.length>1&&this.signFromStackTip(v,M)<0;)this._stack.pop();b&&this.pushIndex(v)}collectHullChain(v,M,b){if(this._stack.length=0,M>2){let E=v;for(let v=0;v<M;v++)this.extendHullChain(E,b,!0),E=this.indexAfter(E)}}collectHullPointsInArray(v,M,b,E){if(v.length=0,b>2){let E=M;for(let M=0;M<b;M++)v.push(this._points[E]),E=this.indexAfter(E)}}buildHullTreeGo(v,M,b=!0){this.collectHullChain(v.startIdx,v.numPoints,M?1:-1),v.points.length=0;const E=this._stack,D=this._points,X=E.length;for(let z=0;z<X;z++){const b=E[z];if(v.points.push(D[b]),z+1<X){let X=E[z+1];if(X===this.indexAfter(b)){const E=Ar.createEdgeAndUpVector(D[b],D[X],$.create(0,0,1),W.createRadians(0));void 0!==E&&(M&&E.negateInPlace(),v.addPlane(E))}else X<b&&(X+=this.period),v.addEmptyChild(b,X-b+1)}}if(b)for(const z of v.children)this.buildHullTreeGo(z,!M);else for(const z of v.children)this.collectHullPointsInArray(z.points,z.startIdx,z.numPoints,M?-1:1);return!0}buildHullAndInletsForPolygon(v){return es.createWithIndices(this.indexOfMaxX,this.period+1,v),this.buildHullTreeGo(v,!0,!1)}buildHullTree(v){return es.createWithIndices(this.indexOfMaxX,this.period+1,v),this.buildHullTreeGo(v,!0)}}class ss{constructor(){this._stackDepth=0,this._intervalStack=[]}setCurveRef(v){this._curve=v}popSegmentFrame(){this._stackDepth>0&&(this._topOfStack.length=0,this._stackDepth-=1)}clearSegmentStack(){for(;this._stackDepth>0;)this.popSegmentFrame()}pushEmptySegmentFrame(){for(this._stackDepth+=1;this._intervalStack.length<this._stackDepth;)this._intervalStack.push([]);this._topOfStack.length=0}get _topOfStack(){return this._intervalStack[this._stackDepth-1]}set _topOfStack(v){const M=this._stackDepth;M>0&&(this._intervalStack[M-1]=v)}stackEntry(v){return v<=this._stackDepth?this._intervalStack[this._stackDepth-1-v]:[]}isTopOfStackEmpty(){return 0===this._topOfStack.length}appendSingleClipToStack(v,M){const b=ss._fractionIntervals;if(this._curve instanceof we){let b,E;return this._curve.announceClipIntervals(v,((v,M,D)=>{b=v,E=M}))&&M.push(ft.createXX(b,E)),!0}if(this._curve instanceof ti){const E=this._curve;b.length=0,E.announceClipIntervals(v,((v,M,E)=>{b.push(v),b.push(M)}));for(let v=0;v<b.length;v+=2)M.push(ft.createXX(b[v],b[v+1]));return!0}if(this._curve instanceof ke&&this._curve.points.length>1){const b=this._curve;let E,D;const X=b.points.length,z=1/(X-1);for(let R=0;R<X-1;R++)we.create(b.points[R],b.points[R+1]).announceClipIntervals(v,((v,M,b)=>{E=v,D=M}))&&M.push(ft.createXX((R+E)*z,(R+D)*z));return!0}if(this._curve instanceof $e){const E=this._curve;b.length=0,E.announceClipIntervals(v,((v,M,E)=>{b.push(v),b.push(M)}));for(let v=0;v<b.length;v+=2)M.push(ft.createXX(b[v],b[v+1]));return!0}return!1}recurse(v){if(this.pushEmptySegmentFrame(),this.appendSingleClipToStack(v.planes,this._topOfStack),$i.sort(this._topOfStack),!this.isTopOfStackEmpty())for(const M of v.children){if(this.recurse(M),this.isTopOfStackEmpty())this.popSegmentFrame();else{const v=$i.differenceSorted(this.stackEntry(1),this.stackEntry(0));this.popSegmentFrame(),this._topOfStack=v}if(this.isTopOfStackEmpty())break}}appendSingleClipPrimitive(v,M,b,E){if(this.setCurveRef(M),this.clearSegmentStack(),this.recurse(v),1!==this._stackDepth)return;const D=this._topOfStack;for(const X of D){const v=X.low,E=X.high,D=M.fractionToPoint(v),z=M.fractionToPoint(E);b.push(Pt.createCapture(vt.createCurveFractionPoint(M,v,D),vt.createCurveFractionPoint(M,E,z)))}this.popSegmentFrame()}appendCurveCollectionClip(v,M,b,E){for(const D of M.children)D instanceof oe?this.appendSingleClipPrimitive(v,D,b,E):D instanceof ze&&this.appendCurveCollectionClip(v,D,b,E)}}ss._fractionIntervals=[],function(v){v[v.None=0]="None",v[v.XLow=1]="XLow",v[v.XHigh=2]="XHigh",v[v.YLow=4]="YLow",v[v.YHigh=8]="YHigh",v[v.ZLow=16]="ZLow",v[v.ZHigh=32]="ZHigh",v[v.XAndY=15]="XAndY",v[v.All=63]="All"}(Or||(Or={}));class ns{fetchClipPlanesRef(){return this.ensurePlaneSets(),this._clipPlanes}get invisible(){return this._invisible}constructor(v,M=!1){this._clipPlanes=v,this._invisible=M}static createCapture(v,M=!1){let b;return v instanceof Qi&&(b=v),v instanceof an&&(b=Qi.createConvexSets([v])),new ns(b,M)}toJSON(){const v={};return this._clipPlanes&&(v.clips=this._clipPlanes.toJSON()),this._invisible&&(v.invisible=!0),{planes:v}}arePlanesDefined(){return void 0!==this._clipPlanes}clone(){const v=this._clipPlanes?this._clipPlanes.clone():void 0;return new ns(v,this._invisible)}ensurePlaneSets(){}pointInside(v,M=K.smallMetricDistanceSquared){this.ensurePlaneSets();let b=!0;return this._clipPlanes&&(b=this._clipPlanes.isPointOnOrInside(v,M)),b}isPointOnOrInside(v,M=K.smallMetricDistanceSquared){this.ensurePlaneSets();let b=!0;return this._clipPlanes&&(b=this._clipPlanes.isPointOnOrInside(v,M)),b}announceClippedSegmentIntervals(v,M,b,E,D){this.ensurePlaneSets();let X=!1;return this._clipPlanes&&(X=this._clipPlanes.announceClippedSegmentIntervals(v,M,b,E,D)),X}announceClippedArcIntervals(v,M){this.ensurePlaneSets();let b=!1;return this._clipPlanes&&(b=this._clipPlanes.announceClippedArcIntervals(v,M)),b}multiplyPlanesByMatrix4d(v,M=!0,b=!0){if(M){const M=v.createInverse();return!!M&&this.multiplyPlanesByMatrix4d(M,!1,b)}return this._clipPlanes&&this._clipPlanes.multiplyPlanesByMatrix4d(v),!0}transformInPlace(v){return this._clipPlanes&&this._clipPlanes.transformInPlace(v),!0}setInvisible(v){this._invisible=v}containsZClip(){if(void 0!==this.fetchClipPlanesRef())for(const v of this._clipPlanes.convexSets)for(const M of v.planes)if(Math.abs(M.inwardNormalRef.z)>1e-6&&Math.abs(M.distance)!==Number.MAX_VALUE)return!0;return!1}classifyPointContainment(v,M){this.ensurePlaneSets();const b=this._clipPlanes;let E=Nr.StronglyInside;if(b&&(E=b.classifyPointContainment(v,!1)),this._invisible&&!M)switch(E){case Nr.StronglyInside:return Nr.StronglyOutside;case Nr.StronglyOutside:return Nr.StronglyInside;case Nr.Ambiguous:return Nr.Ambiguous}return E}static fromJSON(v){if(v)return os.fromClipShapeJSON(v)||ns.fromJSONClipPrimitive(v)}static fromJSONClipPrimitive(v){const M=v?.planes;if(!M)return;const b=M.clips?Qi.fromJSON(M.clips):void 0,E=void 0!==M.invisible&&M.invisible;return new ns(b,E)}}class rs{constructor(v,M,b,E){this.pointA=Q.create(v.x,v.y,E),this.pointB=Q.create(M.x,M.y,E),this.normal=b}static makeUnitPerpendicularToBisector(v,M,b){let E=M.normal.minus(v.normal);if(void 0!==E.normalize(E)||(E=$.createStartEnd(v.pointA,M.pointB),void 0!==E.normalize(E)))return b&&E.scale(-1,E),E}}class os extends ns{constructor(v=[],M,b,E,D=!1,X=!1){super(void 0,X),this._isMask=!1,this._polygon=v,this.initSecondaryProps(D,M,b,E)}get invisible(){return this._invisible}get transformFromClip(){return this._transformFromClip}get transformToClip(){return this._transformToClip}get transformValid(){return void 0!==this.transformFromClip}get zLowValid(){return void 0!==this._zLow}get zHighValid(){return void 0!==this._zHigh}get transformIsValid(){return void 0!==this._transformFromClip}get zLow(){return this._zLow}get zHigh(){return this._zHigh}get polygon(){return this._polygon}get isMask(){return this._isMask}setPolygon(v){v[0].isAlmostEqual(v[v.length-1])||v.push(v[0].clone()),this._polygon=v}ensurePlaneSets(){void 0===this._clipPlanes&&(this._clipPlanes=Qi.createEmpty(),this.parseClipPlanes(this._clipPlanes),this._transformFromClip&&this._clipPlanes.transformInPlace(this._transformFromClip))}initSecondaryProps(v,M,b,E){this._isMask=v,this._zLow=M,this._zHigh=b,void 0!==E?(this._transformFromClip=E,this._transformToClip=E.inverse()):(this._transformFromClip=pt.createIdentity(),this._transformToClip=pt.createIdentity())}toJSON(){const v={points:this._polygon.map((v=>v.toJSON()))};return this.invisible&&(v.invisible=!0),this._transformFromClip&&!this._transformFromClip.isIdentity&&(v.trans=this._transformFromClip.toJSON()),this.isMask&&(v.mask=!0),void 0!==this.zLow&&this.zLow!==-Number.MAX_VALUE&&(v.zlow=this.zLow),void 0!==this.zHigh&&this.zHigh!==Number.MAX_VALUE&&(v.zhigh=this.zHigh),{shape:v}}static fromClipShapeJSON(v,M){const b=v?.shape;if(!b)return;const E=b.points?b.points.map((v=>Q.fromJSON(v))):[],D=b.trans?pt.fromJSON(b.trans):void 0,X="number"==typeof b.zlow?b.zlow:void 0,z="number"==typeof b.zhigh?b.zhigh:void 0,R="boolean"==typeof b.mask&&b.mask,O="boolean"==typeof b.invisible&&b.invisible;return os.createShape(E,X,z,D,R,O,M)}static createFrom(v,M){const b=os.createEmpty(!1,!1,void 0,M);b._invisible=v._invisible;for(const E of v._polygon)b._polygon.push(E.clone());return b._isMask=v._isMask,b._zLow=v._zLow,b._zHigh=v._zHigh,b._transformToClip=v._transformToClip?v._transformToClip.clone():void 0,b._transformFromClip=v._transformFromClip?v._transformFromClip.clone():void 0,b}static createShape(v=[],M,b,E,D=!1,X=!1,z){if(v.length<3)return;const R=v.slice(0);return R[0].isAlmostEqual(R[R.length-1])?R[0].clone(R[R.length-1]):R.push(R[0].clone()),z?(z._clipPlanes=void 0,z._invisible=X,z._polygon=R,z.initSecondaryProps(D,M,b,E),z):new os(R,M,b,E,D,X)}static createBlock(v,M,b=!1,E=!1,D,X){const z=v.low,R=v.high,O=[];for(let Y=0;Y<5;Y++)O.push(Q.create());return O[0].x=O[3].x=O[4].x=z.x,O[1].x=O[2].x=R.x,O[0].y=O[1].y=O[4].y=z.y,O[2].y=O[3].y=R.y,os.createShape(O,Or.None!==(M&Or.ZLow)?z.z:void 0,Or.None!==(M&Or.ZHigh)?R.z:void 0,D,b,E,X)}static createEmpty(v=!1,M=!1,b,E){return E?(E._clipPlanes=void 0,E._invisible=M,E._polygon.length=0,E.initSecondaryProps(v,void 0,void 0,b),E):new os([],void 0,void 0,b,v,M)}get isValidPolygon(){return!(this._polygon.length<3||!this._polygon[0].isExactEqual(this._polygon[this._polygon.length-1]))}clone(v){return os.createFrom(this,v)}parseClipPlanes(v){const M=this._polygon;if(3===M.length&&!this._isMask&&M[0].isExactEqual(M[M.length-1]))return this.parseLinearPlanes(v,this._polygon[0],this._polygon[1]),!0;if(!this.isMask){const M=vr.testXYPolygonTurningDirections(this.polygon);if(0!==M)return this.parseConvexPolygonPlanes(v,this._polygon,M,!1),!0}return this.parsePolygonPlanes(v,this._polygon,this.isMask),!0}parseLinearPlanes(v,M,b,E){const D=M.vectorTo(b);if(0===D.magnitude())return!1;D.normalize(D);const X=an.createEmpty();if(void 0===E){const v=J.create(-D.y,D.x);X.planes.push(Ar.createNormalAndPoint($.create(D.x,D.y),Q.createFrom(M),this._invisible)),X.planes.push(Ar.createNormalAndPoint($.create(-D.x,-D.y),Q.createFrom(b),this._invisible)),X.planes.push(Ar.createNormalAndPoint($.create(v.x,v.y),Q.createFrom(M),this._invisible)),X.planes.push(Ar.createNormalAndPoint($.create(-v.x,-v.y),Q.createFrom(M),this._invisible))}else{const v=Q.create(M.x,M.y,-E),D=Q.create(b.x,b.y,-E),z=$.createFrom(D),R=z.crossProduct($.createFrom(v)).normalize();let O=$.createFrom(v).crossProduct(R).normalize();X.planes.push(Ar.createNormalAndDistance(R,0,this._invisible)),X.planes.push(Ar.createNormalAndDistance(O,0,this._invisible)),R.negate(),O=z.crossProduct(R).normalize(),X.planes.push(Ar.createNormalAndDistance(R,0,this._invisible)),X.planes.push(Ar.createNormalAndDistance(O,0,this._invisible))}return X.addZClipPlanes(this._invisible,this._zLow,this._zHigh),v.addConvexSet(X),!0}parseConvexPolygonPlanes(v,M,b,E,D){const X=[],z=b<0;for(let R=0;R<M.length-1;R++){const v=void 0===D?0:-D,b=$.createStartEnd(M[R],M[R+1]),E=b.magnitude();if(b.normalize(b),E>1e-8){const E=$.create(z?b.y:-b.y,z?-b.x:b.x);X.push(new rs(M[R],M[R+1],E,v))}}if(X.length<3)return!1;if(E){const M=X.length-1;for(let b=0;b<=M;b++){const E=X[b],D=X[b?b-1:M],R=X[b===M?0:b+1],O=an.createEmpty(),Y=rs.makeUnitPerpendicularToBisector(D,E,!z),N=rs.makeUnitPerpendicularToBisector(E,R,z);Y&&O.planes.push(Ar.createNormalAndPoint(Y,E.pointA,this._invisible,!0)),O.planes.push(Ar.createNormalAndPoint(E.normal,E.pointB,this._invisible,!1)),N&&O.planes.push(Ar.createNormalAndPoint(N,R.pointA,this._invisible,!0)),v.addConvexSet(O),v.addOutsideZClipSets(this._invisible,this._zLow,this._zHigh)}}else{const M=an.createEmpty();if(void 0===D)for(const v of X)M.planes.push(Ar.createNormalAndPoint($.create(v.normal.x,v.normal.y),v.pointA));else if(z)for(const v of X)M.planes.push(Ar.createNormalAndDistance($.createFrom(v.pointA).crossProduct($.createFrom(v.pointB)).normalize(),0));else for(const v of X)M.planes.push(Ar.createNormalAndDistance($.createFrom(v.pointB).crossProduct($.createFrom(v.pointA)).normalize(),0));M.addZClipPlanes(this._invisible,this._zLow,this._zHigh),v.addConvexSet(M)}return!0}parsePolygonPlanes(v,M,b,E){const D=oi.compressDanglers(M,!0),r=(M,b)=>{if(!b.isMaskSet(Rr.EXTERIOR)){const M=b.collectAroundFace((v=>{if(!v.isMaskSet(Rr.EXTERIOR))return Q.create(v.x,v.y,0)}));M.push(M[0].clone());const D=vr.testXYPolygonTurningDirections(M);this.parseConvexPolygonPlanes(v,M,D,!1,E)}return!0};if(b){const M=de.clonePoint3dArray(D),b=es.createHullAndInletsForPolygon(M).extractLoops();if(0===b.length)return!1;const X=b[0],z=vr.testXYPolygonTurningDirections(X);this.parseConvexPolygonPlanes(v,X,-z,!0,E);for(let v=1;v<b.length;v++){const M=Ps.createTriangulatedGraphFromSingleLoop(b[v]);M&&(Ps.flipTriangles(M),M.announceFaceLoops(r))}return!0}{const v=Ps.createTriangulatedGraphFromSingleLoop(D);if(void 0===v)return!1;Ps.flipTriangles(v),v.announceFaceLoops(r)}return!0}multiplyPlanesByMatrix4d(v,M=!0,b=!0){return this.ensurePlaneSets(),super.multiplyPlanesByMatrix4d(v,M,b)}transformInPlace(v){return v.isIdentity||(super.transformInPlace(v),this._transformFromClip?v.multiplyTransformTransform(this._transformFromClip,this._transformFromClip):this._transformFromClip=v.clone(),this._transformToClip=this._transformFromClip.inverse()),!0}get isXYPolygon(){return 0!==this._polygon.length&&(void 0===this._transformFromClip||this._transformFromClip.matrix.columnZ().magnitudeXY()<1e-8)}performTransformToClip(v){void 0!==this._transformToClip&&this._transformToClip.multiplyPoint3d(v,v)}performTransformFromClip(v){void 0!==this._transformFromClip&&this._transformFromClip.multiplyPoint3d(v,v)}}class as{constructor(v){this._keepInside=v,this._clippers=[],this._intervalsA=[],this._intervalsB=[]}toJSON(){const v=[];for(const b of this._clippers){const M=b;M.toJSON&&v.push(M.toJSON())}const M={};return M[this.operationName]=v,M}captureChild(v){if(Array.isArray(v))for(const M of v)this.captureChild(M);else this._clippers.push(v)}toggleResult(){return this.selectResult(!this._keepInside)}selectResult(v){const M=this._keepInside;return this._keepInside=v,M}testedAnnounceNN(v,M,b){return v<M?(b&&b(v,M),1):0}testedAnnounceNNC(v,M,b,E){return v<M?(E&&E(v,M,b),1):0}swapAB(){const v=this._intervalsA;this._intervalsA=this._intervalsB,this._intervalsB=v}announcePartsNN(v,M,b,E,D){let X=0;if(v)for(const z of M)X+=this.testedAnnounceNN(z.low,z.high,D);else{let v=b;for(const b of M)X+=this.testedAnnounceNN(v,b.low,D),v=b.high;X+=this.testedAnnounceNN(v,E,D)}return X>0}announcePartsNNC(v,M,b,E,D,X){let z=0;if(v)for(const R of M)z+=this.testedAnnounceNNC(R.low,R.high,D,X);else{let v=b;for(const b of M)z+=this.testedAnnounceNNC(v,b.low,D,X),v=b.high;z+=this.testedAnnounceNNC(v,E,D,X)}return z>0}isPointOnOrInside(v){const M=this.isPointOnOrInsideChildren(v);return this._keepInside?M:!M}announceClippedSegmentIntervals(v,M,b,E,D){this._intervalsA.length=0;const r=(v,M)=>{this._intervalsB.push(ft.createXX(v,M))};let X=0;for(const z of this._clippers)this._intervalsB.length=0,z.announceClippedSegmentIntervals(v,M,b,E,r),$i.simplifySortUnion(this._intervalsB),0===X?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),X++;return this.announcePartsNN(this._keepInside,this._intervalsA,v,M,D)}announceClippedArcIntervals(v,M){this._intervalsA.length=0;const i=(v,M)=>{this._intervalsB.push(ft.createXX(v,M))};let b=0;for(const E of this._clippers)this._intervalsB.length=0,E.announceClippedArcIntervals(v,i),$i.simplifySortUnion(this._intervalsB),0===b?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),b++;return this.announcePartsNNC(this._keepInside,this._intervalsA,0,1,v,M)}}class cs extends as{get operationName(){return this._keepInside?"AND":"NAND"}constructor(v){super(v)}isPointOnOrInsideChildren(v){for(const M of this._clippers)if(!M.isPointOnOrInside(v))return!1;return!0}combineIntervals(v,M){return $i.intersectSorted(v,M)}appendPolygonClip(v,M,b,E){ds.doPolygonClipSequence(v,this._clippers,this._keepInside?M:b,this._keepInside?b:M,void 0,Lr.passToNextStep,Lr.acceptOut,Lr.acceptIn,E)}}class hs{get clips(){return this._clips}constructor(v){this.boundingRange=ut.createNull(),this._clips=v||[]}get isValid(){return this._clips.length>0}static createEmpty(v){return v?(v._clips.length=0,v):new hs}static createCapture(v,M){return M?(M._clips=v,M):new hs(v)}static create(v,M){const b=[];for(const E of v)b.push(E.clone());return hs.createCapture(b,M)}clone(v){const M=v||new hs;M._clips.length=0;for(const b of this._clips)M._clips.push(b.clone());return M.boundingRange.setFrom(this.boundingRange),M}toJSON(){return this.isValid?this.clips.map((v=>v.toJSON())):[]}static fromJSON(v,M){if((M=M||new hs).clear(),!Array.isArray(v))return M;try{for(const b of v){const v=ns.fromJSON(b);v&&M._clips.push(v)}}catch(v){M.clear()}return M}clear(){this._clips.length=0}appendClone(v){this._clips.push(v.clone())}appendReference(v){this._clips.push(v)}appendShape(v,M,b,E,D=!1,X=!1){const z=os.createShape(v,M,b,E,D,X);return!!z&&(this._clips.push(z),!0)}pointInside(v,M=K.smallMetricDistanceSquared){return this.isPointOnOrInside(v,M)}isPointOnOrInside(v,M=K.smallMetricDistanceSquared){if(!this.boundingRange.isNull&&!this.boundingRange.containsPoint(v))return!1;for(const b of this._clips)if(!b.pointInside(v,M))return!1;return!0}ensureProxyClipNode(){if(this._clipNodeProxy)return!0;this._clipNodeProxy=new cs(!0);let v=0;for(const M of this._clips){const b=M.fetchClipPlanesRef();b&&(v++,this._clipNodeProxy.captureChild(b))}return v>0}announceClippedSegmentIntervals(v,M,b,E,D){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedSegmentIntervals(v,M,b,E,D)}announceClippedArcIntervals(v,M){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedArcIntervals(v,M)}appendPolygonClip(v,M,b,E){this.ensureProxyClipNode(),this._clipNodeProxy&&this._clipNodeProxy.appendPolygonClip(v,M,b,E)}transformInPlace(v){for(const M of this._clips)if(!1===M.transformInPlace(v))return!1;return this.boundingRange.isNull||v.multiplyRange(this.boundingRange,this.boundingRange),!0}extractBoundaryLoops(v,M){let b=Or.None,E=-Number.MAX_VALUE,D=Number.MAX_VALUE;const X=[];let z,R=0;if(0===this._clips.length)return X;const O=pt.createIdentity();for(const Y of this._clips)if(Y instanceof os){if(void 0!==z&&Y!==z){let v=pt.createIdentity(),M=pt.createIdentity();z.transformValid&&Y.transformValid&&(v=Y.transformFromClip.clone(),M=z.transformToClip.clone()),O.setFrom(M.multiplyTransformTransform(v))}if(z||(z=Y),v[R]=[],void 0!==Y.polygon){b=Or.XAndY,Y.zHighValid&&(b|=Or.ZHigh,D=Y.zHigh),Y.zLowValid&&(b|=Or.ZLow,E=Y.zLow);for(const M of Y.polygon)v[R].push(M.clone());O.multiplyPoint3dArray(v[R],v[R]),R++}}return X.push(b),X.push(E),X.push(D),M&&z&&M.setFrom(z.transformFromClip),X}setInvisible(v){for(const M of this._clips)M.setInvisible(v)}parseClipPlanes(){for(const v of this._clips)v.fetchClipPlanesRef()}multiplyPlanesByMatrix4d(v,M=!0,b=!0){if(M){const M=v.createInverse();return!!M&&this.multiplyPlanesByMatrix4d(M,!1,b)}for(const E of this._clips)E.multiplyPlanesByMatrix4d(v,!1,b);return!0}classifyPointContainment(v,M=!1){let b=Nr.Ambiguous;for(const E of this._clips){const D=E.classifyPointContainment(v,M);if(Nr.Ambiguous===D)return Nr.Ambiguous;if(Nr.Ambiguous===b)b=D;else if(b!==D)return Nr.Ambiguous}return b}classifyRangeContainment(v,M){const b=v.corners();return this.classifyPointContainment(b,M)}isAnyLineStringPointInside(v){for(const M of this._clips){const b=M.fetchClipPlanesRef();if(void 0!==b)for(let M=0;M+1<v.length;M++){const E=we.create(v[M],v[M+1]);if(b.isAnyPointInOrOnFromSegment(E))return!0}}return!1}sumSizes(v,M,b){let E=0;for(let D=M;D<b;D++)E+=v[D].x1-v[D].x0;return E}isLineStringCompletelyContained(v){const M=[];for(let b=0;b+1<v.length;b++){const E=we.create(v[b],v[b+1]);let D=0,X=0;for(const v of this._clips){const b=v.fetchClipPlanesRef();if(void 0!==b){b.appendIntervalsFromSegment(E,M);const v=M.length;if(D+=this.sumSizes(M,X,v),X=v,D>=hs._TARGET_FRACTION_SUM)break}}if(D<hs._TARGET_FRACTION_SUM)return!1}return!0}toCompactString(){function t(v){return`${v.toString()}_`}function i(v){let M=v.invisible?1:0;return M|=v.interior?2:0,`${function(v){const M=v.toString();return e(1===M.length),M}(M)}${b=v.inwardNormalRef,`${t(b.x)}${t(b.y)}${t(b.z)}`}${t(v.distance)}`;var b}function s(v){let M="";for(const b of v.planes)M=`${M}${i(b)}`;return`${M}_`}function n(v){let M=(v.invisible?1:0).toString();e(1===M.length);const b=v.fetchClipPlanesRef();if(b)for(const E of b.convexSets)M=`${M}${s(E)}`;return`${M}_`}let v="";for(const M of this.clips)v=`${v}${n(M)}`;return`${v}_`}}hs._TARGET_FRACTION_SUM=.99999999,function(v){v.fromClipVector=function(v){if(!v||!v.isValid)return;const M=v;void 0===M.clipString&&(M.clipString=v.toCompactString());const b=M;return e(void 0!==b.clipString),b}}(Yr||(Yr={}));class ls{constructor(v,M){this._positiveOffsetLeft=v,this._positiveOffsetRight=M,this._turnDegrees=60}static createUnit(v,M,b,E=!0){let D=M,X=M+1;const z=v.length-1;b?M<0?(D=z-1,X=z):M>=z&&(D=0,X=1):0===M?(D=0,X=1):X>z&&(D=z-1,X=z);const R=v.vectorIndexIndex(D,X);if(R)return E&&(R.z=0),R.normalize(R)}static createDirectedPlane(v,M,b,E,D=!1){return Ar.createNormalAndPointXYZXYZ(M.x*E,M.y*E,M.z*E,v.x+b*M.x,v.y+b*M.y,v.z+b*M.z,D,D)}createChamferCut(v,M,b,E){const D=b.angleToXY(E).degrees;if(Math.abs(D)>this._turnDegrees){const X=b.interpolate(.5,E);X.rotate90CCWXY(X),X.normalizeInPlace(),D>0?v.addPlaneToConvexSet(ls.createDirectedPlane(M,X,-this._positiveOffsetRight,1,!1)):v.addPlaneToConvexSet(ls.createDirectedPlane(M,X,this._positiveOffsetLeft,-1,!1))}}createOffsetFromSegment(v,M,b,E,D){if(void 0===E)return;void 0===b&&(b=E),void 0===D&&(D=E);const X=b.interpolate(.5,E);X.normalizeInPlace();const z=E.rotate90CCWXY(),R=E.interpolate(.5,D);R.normalizeInPlace();const O=an.createEmpty();return O.addPlaneToConvexSet(ls.createDirectedPlane(v,z,this._positiveOffsetLeft,-1,!1)),O.addPlaneToConvexSet(ls.createDirectedPlane(v,z,-this._positiveOffsetRight,1,!1)),O.addPlaneToConvexSet(ls.createDirectedPlane(v,X,0,1,!0)),O.addPlaneToConvexSet(ls.createDirectedPlane(M,R,0,-1,!0)),this.createChamferCut(O,v,b,E),this.createChamferCut(O,M,E,D),O}static createClipBetweenOffsets(v,M,b,E,D){const X=new ls(M,b),z=Qi.createEmpty();if(v.length>1){const M=K.isSmallMetricDistance(v.distanceIndexIndex(0,v.length-1));for(let b=0;b+1<v.length;b++){const R=this.createUnit(v,b-1,M),O=this.createUnit(v,b,M),Y=this.createUnit(v,b+1,M),N=X.createOffsetFromSegment(v.getPoint3dAtUncheckedPointIndex(b),v.getPoint3dAtUncheckedPointIndex(b+1),R,O,Y);N?.addZClipPlanes(!1,E,D),N&&z.addConvexSet(N)}}else{const v=an.createEmpty();v?.addZClipPlanes(!1,E,D),v.planes.length>0&&z.addConvexSet(v)}return z}}!function(v){v[v.StronglyInside=1]="StronglyInside",v[v.Ambiguous=2]="Ambiguous",v[v.StronglyOutside=3]="StronglyOutside"}(Nr||(Nr={})),(ho=Lr||(Lr={}))[ho.acceptIn=1]="acceptIn",ho[ho.acceptOut=-1]="acceptOut",ho[ho.passToNextStep=0]="passToNextStep",function(v){v[v.ClipRequired=0]="ClipRequired",v[v.TrivialReject=1]="TrivialReject",v[v.TrivialAccept=2]="TrivialAccept"}(Kr||(Kr={}));class ds{static selectIntervals01(v,M,b,E){M.push(0),M.push(1),M.sort();let D,X,z=M.atUncheckedIndex(0);const R=ds._selectIntervals01TestPoint,O=M.length;for(let Y=1;Y<O;Y++)if(D=M.atUncheckedIndex(Y),D>z+K.smallFraction){if(X=.5*(z+D),X>=0&&X<=1&&(v.fractionToPoint(X,R),b.isPointOnOrInside(R))){if(!E)return!0;E(z,D,v)}z=D}return!1}static announceNNC(v,M,b){if(b)for(const E of v)b(E.low,E.high,M);return v.length>0}static collectClippedCurves(v,M){const b=[];return v.announceClipIntervals(M,((v,M,E)=>{if(M!==v){const D=E.clonePartialCurve(v,M);D&&b.push(D)}})),b}static clipAnyRegion(v,M){let b;const E=ds._workTransform=ei.createRightHandedFrame(void 0,v,ds._workTransform);if(!E)return b;const D=E?.inverse();if(!D)return b;const X=v.cloneTransformed(D);if(!X)return b;const z=ds._workRange=X.range(),R=z.xLength(),O=z.yLength(),Y=ke.createRectangleXY(z.low,R,O,!0);Y.tryTransformInPlace(E);const N=[],B=new ji;if(M.appendPolygonClip?.(Y.packedPoints,N,[],B),0===N.length)return b;for(const V of N){const v=Oe.createPolygon(V);v.tryTransformInPlace(D);const M=lr.regionBooleanXY(X,v,ro.Intersection);M&&(M.tryTransformInPlace(E),b?b.tryAddChild(M)||b.children.push(...M.children):b=M instanceof Ji?M:Ji.create(M))}return b}static clipAnyCurve(v,M){if(v instanceof oe)return ds.collectClippedCurves(v,M);if(v.isAnyRegion()){const b=ds.clipAnyRegion(v,M);return b?[b]:[]}const b=[];if(v instanceof Ve||v instanceof Ye)for(const E of v.children){const v=ds.clipAnyCurve(E,M);b.push(...v)}return b}static clipPolygonToClipShape(v,M){const b=this.clipPolygonToClipShapeReturnGrowableXYZArrays(v,M),E=[];for(const D of b)E.push(D.getPoint3dArray());return E}static clipPolygonToClipShapeReturnGrowableXYZArrays(v,M){const b=[],E=M.fetchClipPlanesRef();return E&&E.polygonClip(v,b),b}static pointSetSingleClipStatus(v,M,b){if(0===M.convexSets.length)return Kr.TrivialAccept;for(const E of M.convexSets){let M=!1,D=!1;for(const X of E.planes){let E=0,z=0;const R=X.distance-b,O=Q.create(),Y=$.create();for(let M=0;M<v.length;M++)v.getPoint3dAtUncheckedPointIndex(M,O),Y.setFrom(O),Y.dotProduct(X.inwardNormalRef)>R?E++:z++;if(D=0!==z||D,0===E){M=!0;break}}if(!D)return Kr.TrivialAccept;if(!M)return Kr.ClipRequired}return Kr.TrivialReject}static announceLoopsOfConvexClipPlaneSetIntersectRange(v,M,b,E=!0,D=!0,X=!1){const z=new nt;if(E)if(v instanceof an)for(const R of v.planes){if(X&&R.invisible)continue;const E=R.intersectRange(M,!0),D=new nt;E&&(v.polygonClip(E,D,z,R),D.length>0&&b(D))}else if(X&&v.invisible);else{const E=v.intersectRange(M,!0);E&&b(E)}if(D){const E=M.corners();for(let M=0;M<6;M++){const D=ut.faceCornerIndices(M),X=new nt,R=ke.createIndexedPoints(E,D);v instanceof an?(v.polygonClip(R.packedPoints,X,z),X.length>0&&b(X)):(v.clipConvexPolygonInPlace(R.packedPoints,z),R.packedPoints.length>0&&b(R.packedPoints))}}}static loopsOfConvexClipPlaneIntersectionWithRange(v,M,b=!0,E=!0,D=!1){const X=[];if(v instanceof Qi)for(const z of v.convexSets)this.announceLoopsOfConvexClipPlaneSetIntersectRange(z,M,(v=>{v.length>0&&X.push(Oe.createPolygon(v))}),b,E,D);else(v instanceof an||v instanceof Ar)&&this.announceLoopsOfConvexClipPlaneSetIntersectRange(v,M,(v=>{v.length>0&&X.push(Oe.createPolygon(v))}),b,E,D);return X}static rangeOfConvexClipPlaneSetIntersectionWithRange(v,M){const b=ut.createNull();return this.announceLoopsOfConvexClipPlaneSetIntersectRange(v,M,(v=>{v.length>0&&b.extendArray(v)}),!0,!0,!1),b}static rangeOfClipperIntersectionWithRange(v,M,b=!0){if(void 0===v)return M.clone();if(v instanceof an)return this.rangeOfConvexClipPlaneSetIntersectionWithRange(v,M);if(v instanceof Qi){const b=ut.createNull();for(const E of v.convexSets){const v=this.rangeOfConvexClipPlaneSetIntersectionWithRange(E,M);b.extendRange(v)}return b}if(v instanceof ns)return b&&v.invisible?M.clone():this.rangeOfClipperIntersectionWithRange(v.fetchClipPlanesRef(),M);if(v instanceof hs){const E=M.clone();for(const D of v.clips)if(b&&D.invisible);else{const v=this.rangeOfClipperIntersectionWithRange(D,M,b);E.intersect(v,E)}return E}return M.clone()}static doesClipperIntersectRange(v,M,b=!0){if(void 0===v)return!0;if(v instanceof an)return this.doesConvexClipPlaneSetIntersectRange(v,M);if(v instanceof Qi){for(const b of v.convexSets)if(this.doesConvexClipPlaneSetIntersectRange(b,M))return!0;return!1}if(v instanceof ns)return!(!b||!v.invisible)||this.doesClipperIntersectRange(v.fetchClipPlanesRef(),M);if(v instanceof hs){const E=M.clone();for(const D of v.clips)if(b&&D.invisible);else{const v=this.rangeOfClipperIntersectionWithRange(D,M,b);E.intersect(v,E)}return!E.isNull}return!1}static doesConvexClipPlaneSetIntersectRange(v,M,b=!0,E=!0,D=!1){const X=new nt;if(b)for(const z of v.planes){if(D&&z.invisible)continue;const b=z.intersectRange(M,!0);if(b){const M=new nt;if(v.polygonClip(b,M,X,z),M.length>0)return!0}}if(E){const b=M.corners();for(let M=0;M<6;M++){const E=ut.faceCornerIndices(M),D=new nt,z=ke.createIndexedPoints(b,E);if(v.polygonClip(z.packedPoints,D,X),D.length>0)return!0}}return!1}static createClipperFromTransformedRange3d(v,M,b){M||(M=pt.createIdentity());const E=On.create();E.addTransformedRangeMesh(M,v);const D=E.claimPolyface(),X=this._workClipper=an.createConvexPolyface(D,this._workClipper).clipper;if(X.planes.length>0)return X;if(b){e(D.data.point.length<=2);for(let v=0;v<2;++v){const M=D.data.point.getPoint3dAtCheckedPointIndex(v);M&&b.push(M)}}}static rangeIntersectPointOrSegment(v,M,b,E){const D=E?(v,M,D)=>{E.extendPoint(D.fractionToPoint(v),b),E.extendPoint(D.fractionToPoint(M),b)}:void 0;let X=!1;if(M.length>1){const b=we.createCapture(M[0],M[1]),E=an.createRange3dPlanes(v);X=b.announceClipIntervals(E,D)}else M.length>0&&(X=v.containsPoint(M[0]),X&&E&&E.extendPoint(M[0],b));return X}static doLocalRangesIntersect(v,M,b,E,D){const X=this._workTransform=E.inverse(this._workTransform);if(!X)return!1;let z=b;D&&(z=this._workRange=b.clone(this._workRange),z.expandInPlace(D));const R=[],O=X.multiplyTransformTransform(M,X),Y=this.createClipperFromTransformedRange3d(v,O,R);return Y?this.doesClipperIntersectRange(Y,z):this.rangeIntersectPointOrSegment(z,R,E)}static rangeOfIntersectionOfLocalRanges(v,M,b,E,D){const X=ut.createNull(D),z=this._workTransform=E.inverse(this._workTransform);if(!z)return X;const R=[],O=z.multiplyTransformTransform(M,z),Y=this.createClipperFromTransformedRange3d(v,O,R);return Y?this.announceLoopsOfConvexClipPlaneSetIntersectRange(Y,b,(v=>{v.extendRange(X,E)})):this.rangeIntersectPointOrSegment(b,R,E,X),X}static isClipper(v){return!!(v&&v.isPointOnOrInside&&v.announceClippedSegmentIntervals&&v.announceClippedArcIntervals)}static restoreSingletonInPlaceOfMultipleShards(v,M,b,E){if(v&&v.length>M+1){for(;v.length>M;){const M=v.pop();E.dropToCache(M)}v.push(E.grabAndFill(b))}}static createXYOffsetClipFromLineString(v,M,b,E,D){return Array.isArray(v)?ls.createClipBetweenOffsets(new ae(v),M,b,E,D):ls.createClipBetweenOffsets(v,M,b,E,D)}static captureOrDrop(v,M,b,E){v.length>=M?b.push(v):E.dropToCache(v)}static clipSegmentToLLeftOfLineXY(v,M,b,E,D,X=1e-14){const z=M.x-v.x,R=M.y-v.y,O=-(z*(b.y-v.y)-R*(b.x-v.x)),Y=-(z*(E.y-v.y)-R*(E.x-v.x));if(!(O<X&&Y<X))if(O*Y>0)O>0&&D.setNull();else{if(O*Y<0){const v=-O/(Y-O);return O<0?D.intersectRangeXXInPlace(0,v):D.intersectRangeXXInPlace(v,1)}O>0?D.intersectRangeXXInPlace(1,1):Y>0&&D.intersectRangeXXInPlace(0,0)}}static clipSegmentToCCWTriangleXY(v,M,b,E,D,X,z=1e-14){X.isNull||(this.clipSegmentToLLeftOfLineXY(v,M,E,D,X,z),X.isNull||(this.clipSegmentToLLeftOfLineXY(M,b,E,D,X,z),X.isNull||this.clipSegmentToLLeftOfLineXY(b,v,E,D,X,z)))}static clipSegmentBelowPlaneXY(v,M,b,E,D=1e-14){const X=v.altitudeXY(M.x,M.y),z=v.altitudeXY(b.x,b.y);if(!(X<D&&z<D))if(X*z>0)X>0&&E.setNull();else{if(X*z<0){const v=-X/(z-X);return X<0?E.intersectRangeXXInPlace(0,v):E.intersectRangeXXInPlace(v,1)}X>0?E.intersectRangeXXInPlace(1,1):z>0&&E.intersectRangeXXInPlace(0,0)}}static clipSegmentBelowPlanesXY(v,M,b,E,D=1e-14){const X=v.length;for(let z=0;!E.isNull&&z<X;z++)this.clipSegmentBelowPlaneXY(v[z],M,b,E,D)}static announcePolylineClip(v,M,b){for(let E=0;E+1<M.length;E++)v.announceClippedSegmentIntervals(0,1,M[E],M[E+1],((v,D)=>{b(M[E].interpolate(v,M[E+1]),M[E].interpolate(D,M[E+1]))}))}static sumPolylineClipLength(v,M){let b=0;for(let E=0;E+1<M.length;E++){const D=M[E].distance(M[E+1]);v.announceClippedSegmentIntervals(0,1,M[E],M[E+1],((v,M)=>{b+=Math.abs(M-v)*D}))}return b}static doPolygonClipSequence(v,M,b,E,D,X,z,R,O){void 0===O&&(O=new ji);let Y=[O.grabAndFill(v)],N=[];const B=[],V=[],L=b?b.length:0,U=E?E.length:0;let Sr;for(const Cr of M)if(Cr.appendPolygonClip){for(;void 0!==(Sr=Y.pop());)Cr.appendPolygonClip(Sr,B,V,O),fs(X,B,b,E,N,O),fs(z,V,b,E,N,O),O.dropToCache(Sr);const v=Y;Y=N,N=v}fs(R,Y,b,E,D,O),E?.length===U&&ds.restoreSingletonInPlaceOfMultipleShards(b,L,v,O),b?.length===L&&ds.restoreSingletonInPlaceOfMultipleShards(E,U,v,O)}static doPolygonClipParitySequence(v,M,b,E,D){void 0===D&&(D=new ji);let X=[D.grabAndFill(v)],z=[],R=[],O=[];const Y=[],N=[];let B;for(const V of M)if(V.appendPolygonClip){for(;void 0!==(B=z.pop());)V.appendPolygonClip(B,Y,N,D),fs(Lr.acceptOut,Y,R,O,void 0,D),fs(Lr.acceptIn,N,R,O,void 0,D),D.dropToCache(B);for(;void 0!==(B=X.pop());)V.appendPolygonClip(B,Y,N,D),fs(Lr.acceptIn,Y,R,O,void 0,D),fs(Lr.acceptOut,N,R,O,void 0,D),D.dropToCache(B);const v=z;z=R,R=v;const M=X;X=O,O=M}0===X.length?b?.push(D.grabAndFill(v)):0===X.length?E?.push(D.grabAndFill(v)):(us(z,b,D),us(X,E,D))}static createComplementaryClips(v){const M=v.planes,b=ft.createNull(),E=M.length,D=[];for(const X of M){const v=an.createEmpty();v.addPlaneToConvexSet(X.cloneNegated()),D.push(v)}for(let X=0;X<E;X++)for(let z=X+1;z<E;z++){const E=vn.planePlaneIntersectionRay(M[X],M[z]);if(E&&v.hasIntersectionWithRay(E,b)){const v=M[z].inwardNormalRef.minus(M[X].inwardNormalRef),b=Ar.createNormalAndPoint(v,E.origin);if(b){const v=b.cloneNegated();D[X].addPlaneToConvexSet(b),D[z].addPlaneToConvexSet(v)}}}return Qi.createConvexSets(D)}}function us(v,M,b){if(void 0===M)b.dropAllToCache(v);else for(const E of v)M.push(E);v.length=0}function fs(v,M,b,E,D,X){let z;if(v===Lr.acceptIn?z=b:v===Lr.acceptOut?z=E:v===Lr.passToNextStep&&(z=D),void 0===z)X.dropAllToCache(M);else for(const R of M)z.push(R);M.length=0}ds._selectIntervals01TestPoint=Q.create();class gs{constructor(v,M){this._graph=v,this._candidates=[],this._mask=M,this._graph.clearMask(M)}clear(){for(;void 0!==this.chooseAndRemoveAny(););}getLength(){let v=0;for(const M of this._candidates)M.isMaskSet(this._mask)&&v++;return v}getNumCandidates(){return this._candidates.length}get graph(){return this._graph}teardown(){this._graph.dropMask(this._mask),this._candidates.length=0}get mask(){return this._mask}popAndReturn(){const v=this._candidates.length;if(0===v)return;const M=this._candidates[v-1];return this._candidates.pop(),M}getAtIndex(v){if(v>=0&&v<this._candidates.length){const M=this._candidates[v];if(M.isMaskSet(this._mask))return M}}addToSet(v){return!v.isMaskSet(this._mask)&&(this._candidates.push(v),this.setMaskInScope(v),!0)}isCandidateInSet(v){return v.isMaskSet(this._mask)}removeFromSet(v){return!!v.isMaskSet(this._mask)&&(this.clearMaskInScope(v),!0)}chooseAndRemoveAny(){for(;;){const v=this.popAndReturn();if(!v)return;if(this.removeFromSet(v))return v}}[Symbol.iterator](){return new ms(this)}addAroundFace(v){let M=v;do{this.addToSet(M),M=M.faceSuccessor}while(M!==v)}addAroundVertex(v){let M=v;do{this.addToSet(M),M=M.vertexSuccessor}while(M!==v)}}class ps extends gs{constructor(v,M){super(v,M)}static create(v){const M=v.grabMask();if(M!==Rr.NULL_MASK)return new ps(v,M)}setMaskInScope(v){v.setMaskAroundEdge(this._mask)}clearMaskInScope(v){v.clearMaskAroundEdge(this._mask)}countHalfEdgesAroundCandidate(v){return v?2:0}}class ms{constructor(v){this._markSet=v,this._nextReadIndex=0}next(){const v=this._markSet.getNumCandidates();for(;this._nextReadIndex<v;){const v=this._markSet.getAtIndex(this._nextReadIndex++);if(void 0!==v)return{done:!1,value:v}}return{done:!0,value:void 0}}[Symbol.iterator](){return this}}class xs{constructor(v,M,b,E,D,X){this._x=M,this._y=b,this._z=E,this._u=D,this._v=X,this._node=v}set(v,M,b,E,D,X){return this._x=M,this._y=b,this._z=E,this._u=D,this._v=X,this._node=v,this}setFrom(v){this._x=v.x,this._y=v.y,this._z=v.z,this._u=v.u,this._v=v.v,this._node=v.node}static createNodeAndRayOrigin(v,M,b){const E=v.x,D=v.y,X=v.z,z=E-M.origin.x,R=D-M.origin.y,O=K.dotProductXYXY(z,R,M.direction.x,M.direction.y),Y=K.crossProductXYXY(M.direction.x,M.direction.y,z,R);return b?b.set(v,E,D,X,O,Y):new xs(v,E,D,X,O,Y)}static create(v,M=0,b=0,E=0,D=0,X=0){return new xs(v,M,b,E,D,X)}get node(){return this._node}get x(){return this._x}get y(){return this._y}get z(){return this._z}get u(){return this._u}get v(){return this._v}getXYZAsPoint3d(v){return Q.create(this._x,this._y,this._z,v)}getUVAsPoint2d(v){return H.create(this._u,this._v,v)}classifyU(v,M){const b=this.u-v;return Math.abs(b)<=M?0:b>=0?1:-1}classifyV(v,M){const b=v-this._v;return Math.abs(b)<=M?0:b>=0?1:-1}}!function(v){v[v.None=0]="None",v[v.Vertex=1]="Vertex",v[v.Edge=2]="Edge",v[v.Face=3]="Face",v[v.ExteriorFace=4]="ExteriorFace"}(qr||(qr={}));class ys{constructor(v,M,b,E,D,X,z,R,O){this._node=v,this.x=M,this.y=b,this.z=E,this._topo=D,this._edgeFraction=X,this._iTag=z,this._dTag=R,this._isExteriorTarget=O}setFrom(v){this._node=v._node,this.x=v.x,this.y=v.y,this.z=v.z,this._topo=v._topo,this._edgeFraction=v._edgeFraction,this._iTag=v._iTag,this._dTag=v._dTag}resetAsUnknown(){this._node=void 0,this._topo=qr.None}static create(){return new ys(void 0,0,0,0,qr.None)}getITag(){return this._iTag}setITag(v){this._iTag=v}getDTag(){return this._dTag}setDTag(v){this._dTag=v}getTopo(){return this._topo}static createEdgeAtFraction(v,M){const b=v.faceSuccessor,E=K.interpolate(v.x,M,b.x),D=K.interpolate(v.y,M,b.y),X=K.interpolate(v.z,M,b.z);return new ys(v,E,D,X,qr.Edge,M)}resetAsFace(v,M){return this._topo=qr.Face,v&&(this._node=v),M&&(this.x=M.x,this.y=M.y,this.z=M.z),this._isExteriorTarget=void 0,this}resetAsUndefinedWithTag(v){return this._topo=qr.None,this._dTag=0,this._iTag=0,this._dTag=v,this._node=void 0,this._isExteriorTarget=void 0,this}resetAtEdgeAndFraction(v,M){this._topo=qr.Edge,this._node=v;const b=v.faceSuccessor;return this._edgeFraction=M,this.x=K.interpolate(v.x,M,b.x),this.y=K.interpolate(v.y,M,b.y),this.z=K.interpolate(v.z,M,b.z),this._isExteriorTarget=void 0,this}static createVertex(v){return new ys(v,v.x,v.y,v.z,qr.Vertex)}resetAsVertex(v){return this._topo=qr.Vertex,this._node=v,this._edgeFraction=0,this.setXYZFromNode(v),this._isExteriorTarget=void 0,this}setIsExteriorTarget(v){this._isExteriorTarget=v}setXYZFromNode(v){this.x=v.x,this.y=v.y,this.z=v.z}get edgeFraction(){return this._edgeFraction}get isExteriorTarget(){return void 0!==this._isExteriorTarget&&this._isExteriorTarget}get isFace(){return this._topo===qr.Face}get isEdge(){return this._topo===qr.Edge}get isVertex(){return this._topo===qr.Vertex}get isUnclassified(){return this._topo===qr.None}get node(){return this._node}clonePoint(v){return Q.create(this.x,this.y,this.z,v)}isAtXY(v,M){return this._topo!==qr.None&&K.isSameCoordinate(this.x,v)&&K.isSameCoordinate(this.y,M)}}!function(v){v[v.RC_NoHits=0]="RC_NoHits",v[v.RC_TargetOnVertex=1]="RC_TargetOnVertex",v[v.RC_TargetOnEdge=2]="RC_TargetOnEdge",v[v.RC_Bracket=3]="RC_Bracket",v[v.RC_TargetBefore=4]="RC_TargetBefore",v[v.RC_TargetAfter=5]="RC_TargetAfter"}(Qr||(Qr={}));class _s{constructor(v){this._tol=v}static create(v=K.smallMetricDistance){return new _s(v)}panic(){return ys.create()}reAimFromEdge(v,M,b){const E=v.node,D=xs.createNodeAndRayOrigin(E,M),X=xs.createNodeAndRayOrigin(E.edgeMate,M),z=-D.classifyV(0,this._tol),R=-X.classifyV(0,this._tol);let O;if(z*R<0)O=z>0?v.resetAsFace(D.node):v.resetAsFace(X.node);else if(0===z||0===R){const M=D.classifyU(b,this._tol),E=X.classifyU(b,this._tol);if(0===M&&0===z)O=v.resetAsVertex(D.node),O.setITag(1);else if(0===E&&0===R)O=v.resetAsVertex(X.node),O.setITag(1);else if(M*E<0){const M=(b-D.u)/(X.u-D.u);O=v.resetAtEdgeAndFraction(D.node,M),O.setITag(1)}else M<0&&E<0?O=D.u>X.u?v.resetAsVertex(D.node):v.resetAsVertex(X.node):Math.abs(D.u)<this._tol&&Math.abs(D.v)<this._tol?O=v.resetAsVertex(D.node):Math.abs(X.u)<this._tol&&Math.abs(X.v)<this._tol?O=v.resetAsVertex(X.node):(v.resetAsUnknown(),O=this.panic())}else v.resetAsUnknown(),O=this.panic();return O}reAimFromVertex(v,M,b){const E=v.node;let D,X=E;do{const E=xs.createNodeAndRayOrigin(X.faceSuccessor,M),z=xs.createNodeAndRayOrigin(X.facePredecessor,M),R=E.u,O=E.v,Y=z.v;if(Math.abs(O)<this._tol){if(Math.abs(R-b)<this._tol)return D=v.resetAsVertex(E.node),D.setITag(1),D;if(R>b){const M=b/R;return D=v.resetAtEdgeAndFraction(X,M),D}if(Math.abs(R)<=this._tol)return D=v.resetAsVertex(X),D.setITag(1),D;if(R>this._tol)return D=v.resetAsVertex(E.node),D;if(Y>this._tol)return D=v.resetAsFace(X,X),D}else if(O<-this._tol&&Y>this._tol)return D=v.resetAsFace(X,X),D;X=X.vertexSuccessor}while(X!==E);return this.panic()}reAimAroundFace(v,M,b,E,D){E.resetAsUndefinedWithTag(-Number.MAX_VALUE),D.resetAsUndefinedWithTag(Number.MAX_VALUE);const X=xs.createNodeAndRayOrigin(v,M);let z,R=v;do{const v=R.faceSuccessor;z=xs.createNodeAndRayOrigin(v,M,z);const O=X.u,Y=z.u,N=X.v,B=z.v;if(Math.abs(B)<this._tol){const M=ys.createVertex(v);if(M.setDTag(Y),Math.abs(Y-b)<this._tol)return D.setFrom(M),E.setFrom(M),Qr.RC_TargetOnVertex;Y>b&&Y<D.getDTag()&&D.setFrom(M),Y<b&&Y>E.getDTag()&&E.setFrom(M)}else if(N*B<0){const v=-N/(B-N),M=K.interpolate(O,v,Y),z=ys.createEdgeAtFraction(X.node,v);if(z.setDTag(M),Math.abs(M-b)<=this._tol)return D.setFrom(z),E.setFrom(z),Qr.RC_TargetOnEdge;M>b&&M<D.getDTag()&&(D.setFrom(z),D.setITag(N>0?-1:1)),M<b&&M>E.getDTag()&&(E.setFrom(z),E.setDTag(M))}X.setFrom(z),R=R.faceSuccessor}while(R!==v);const O=D.getITag();return D.setITag(0),E.setITag(0),E.isUnclassified?D.isUnclassified?Qr.RC_NoHits:Qr.RC_TargetBefore:D.isUnclassified||D.isEdge&&O&&O<0?Qr.RC_TargetAfter:Qr.RC_Bracket}setSearchRay(v,M,b){b.origin.setFromPoint3d(v),$.createStartEnd(b.origin,M,b.direction),b.direction.z=0;const E=b.direction.magnitudeXY();return b.a=b.direction.magnitude(),b.direction.scaleInPlace(1/b.a),E>=this._tol}}class vs{constructor(v){this._graph=v,this._edgeSet=ps.create(v),this._searcher=ys.create()}static create(v){return new vs(v)}get graph(){return this._graph}retriangulateFromBaseVertex(v){const M=v.countEdgesAroundFace();if(this._edgeSet.addAroundFace(v),M<4||v.signedFaceArea()<=0)return;const b=M-3;let E=v.faceSuccessor,D=v;for(let X=0;X<b;X++)E=E.faceSuccessor,D=this._graph.createEdgeHalfEdgeHalfEdge(D,0,E,0),E=D.faceSuccessor,this._edgeSet.addToSet(D)}reset(){this._searcher=ys.create()}get currentPosition(){return this._searcher}searchForNearestEdgeOrVertex(v){const M=ys.create();M.setDTag(Number.MAX_VALUE);const b=Q.create();let E,D;for(const X of this._graph.allHalfEdges){const z=X.faceSuccessor;E=Ft.lineSegment3dXYClosestPointUnbounded(X,z,v),void 0!==E&&(E>1?(D=v.distanceXY(z),D<M.getDTag()&&(M.resetAsVertex(z),M.setDTag(D))):E<0?(D=v.distanceXY(X),D<M.getDTag()&&(M.resetAsVertex(X),M.setDTag(D))):(X.fractionToPoint3d(E,b),D=v.distanceXY(b),D<M.getDTag()&&M.resetAtEdgeAndFraction(X,E)))}return M}searchForNearestVertex(v){const M=ys.create();let b;M.setDTag(Number.MAX_VALUE);for(const E of this._graph.allHalfEdges)b=v.distanceXY(E),b<M.getDTag()&&(M.resetAsVertex(E),M.setDTag(b));return M}resetSearch(v,M){this._searcher=M>0?this.searchForNearestEdgeOrVertex(v):this.searchForNearestVertex(v)}insertAndRetriangulate(v,M){this.moveToPoint(this._searcher,v);const b=this._searcher.node;let E=!1;if(void 0===b);else if(this._searcher.isFace){if(!b.isMaskSet(Rr.EXTERIOR)){const M=this._graph.createEdgeXYZHalfEdge(v.x,v.y,v.z,0,b,0);this.retriangulateFromBaseVertex(M),Ps.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(M)}E=!0}else if(this._searcher.isEdge){const v=this._graph.splitEdgeAtFraction(b,this._searcher.edgeFraction),M=v.vertexPredecessor;this.retriangulateFromBaseVertex(v),this.retriangulateFromBaseVertex(M),Ps.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(v),E=!0}else this._searcher.isVertex?(M&&b.setXYZAroundVertex(v.x,v.y,v.z),E=!0):E=!1;return E}moveToPoint(v,M,b){const E=_s.create();if(v.setITag(0),v.isUnclassified&&(function(v,M,b,E){for(const D of v.allHalfEdges)if(!D.isMaskSet(0))return M.resetAtEdgeAndFraction(D,.5),!0}(this.graph,v),v.isUnclassified))return!1;let D=0;const X=Mt.createXAxis();for(;0===v.getITag()&&D<2&&(void 0===b||b(v));){if(!E.setSearchRay(v,M,X))return!1;if(v.isFace){const b=ys.create(),z=ys.create();switch(E.reAimAroundFace(v.node,X,X.a,b,z)){case Qr.RC_NoHits:v.resetAsUnknown();break;case Qr.RC_TargetOnVertex:case Qr.RC_TargetOnEdge:v.setFrom(b),v.setITag(1);break;case Qr.RC_Bracket:v.resetAsFace(b.node,M),v.setITag(1);break;case Qr.RC_TargetBefore:v.resetAsFace(v.node,M),v.setITag(1);break;case Qr.RC_TargetAfter:v.node===b.node&&v.isFace&&(b.isEdge||b.isVertex)?D++:D=0,v.setFrom(b)}}else if(v.isEdge){if(E.reAimFromEdge(v,X,X.a),v.isUnclassified)break}else if(v.isVertex&&(E.reAimFromVertex(v,X,X.a),v.isUnclassified))break}return!!v.isAtXY(M.x,M.y)||D>1&&(void 0!==v.node&&v.setIsExteriorTarget(!0),!1)}}class Ps{static flipEdgeBetweenTriangles(v,M,b,E,D,X){Zi.pinch(v,D),Zi.pinch(b,E),Zi.pinch(X,b),Zi.pinch(D,M),D.x=M.x,D.y=M.y,D.z=M.z,D.i=M.i,b.i=X.i,b.x=X.x,b.y=X.y,b.z=X.z}static computeInCircleDeterminantIsStrongPositive(v){const M=v.faceSuccessor,b=M.faceSuccessor;if(b.faceSuccessor!==v)return!1;const E=v.edgeMate,D=E.faceSuccessor.faceSuccessor;if(D.faceSuccessor!==E)return!1;const X=M.x-v.x,z=M.y-v.y,R=b.x-v.x,O=b.y-v.y;if(K.crossProductXYXY(X,z,R,O)<0)return!1;const Y=D.x-v.x,N=D.y-v.y,B=Y*Y+N*N,V=R*R+O*O,L=X*X+z*z,U=K.tripleProduct(Y,N,B,R,O,V,X,z,L);return!(U<0)&&U>1e-12*(Math.abs(Y*O*L)+Math.abs(N*V*X)+Math.abs(B*R*z)+Math.abs(Y*V*z)+Math.abs(N*R*L)+Math.abs(B*O*X))}static flipTriangles(v){const M=ps.create(v);for(const E of v.allHalfEdges)M.addToSet(E);const b=this.flipTrianglesInEdgeSet(v,M);return M.teardown(),b}static flipTrianglesInEdgeSet(v,M){const b=Rr.EXTERIOR|Rr.PRIMARY_EDGE|Rr.BOUNDARY_EDGE,E=10*v.allHalfEdges.length;let D,X=0,z=0;for(;void 0!==(D=M.chooseAndRemoveAny())&&(D.isMaskSet(b)||(Ps.computeInCircleDeterminantIsStrongPositive(D)?(Ps.flipEdgeBetweenTriangles(D.edgeMate.faceSuccessor,D.edgeMate.facePredecessor,D.edgeMate,D.faceSuccessor,D,D.facePredecessor),M.addAroundFace(D),M.addAroundFace(D.edgeMate),X++):z++,!(X+z>E))););return X}static createTriangulatedGraphFromPoints(v){if(v.length<3)return;const M=[],b=[];de.computeConvexHullXY(v,M,b,!0);const E=new qi,D=vs.create(E);Ps.createFaceLoopFromCoordinates(E,M,!0,!0);let X=0;for(const z of b)D.insertAndRetriangulate(z,!0),X++,X>16&&(X=0);return E}static createTriangulatedGraphFromLoops(v){if(v.length<1)return;const M=Rr.BOUNDARY_EDGE|Rr.PRIMARY_EDGE,b=new qi,E=[];let D=-1e4,X=-1;for(let O=0;O<v.length;O++){let z=Ps.directCreateFaceLoopFromCoordinates(b,v[O]);if(z){z=z.faceSuccessor;const v=z.vertexSuccessor;z.setMaskAroundFace(M),v.setMaskAroundFace(M);const b=z.signedFaceArea(),R=Math.abs(b);E.push(b>=0?z:v),(0===O||R>D)&&(D=R,X=O)}}if(0===E.length)return;const z=E[X];E[X]=E[E.length-1],E.pop(),z.vertexSuccessor.setMaskAroundFace(Rr.EXTERIOR);for(let O=0;O<E.length;O++){const v=E[O];v.setMaskAroundFace(Rr.EXTERIOR),E[O]=this.getLeftmost(v.vertexSuccessor)}const R=Ps.spliceLeftMostNodesOfHoles(b,z,E);return R&&Ps.triangulateSingleFace(b,R)?b:void 0}static triangulateAllPositiveAreaFaces(v){const M=v.collectFaceLoops();let b=0;for(const E of M)E.countEdgesAroundFace()>3&&E.signedFaceArea()>0&&(Ps.triangulateSingleFace(v,E)||b++);return 0===b}static createTriangulatedGraphFromSingleLoop(v){const M=new qi,b=Ps.createFaceLoopFromCoordinates(M,v,!0,!0);if(b&&!(M.countNodes()<6)&&Ps.triangulateSingleFace(M,b))return Ps.flipTriangles(M),M}static interiorEdgeSplit(v,M,b){let E=0,D=0,X=0;if(Array.isArray(b))E=b[0],D=b[1],X=b.length>2?b[3]:0;else{const v=b;v.hasOwnProperty("x")&&(E=v.x),v.hasOwnProperty("y")&&(D=v.y),v.hasOwnProperty("z")&&(X=v.z)}return M&&Ps.isAlmostEqualXAndYXY(M,E,D)?M:v.splitEdge(M,E,D,X)}static getUnwrappedLength(v){let M,b,E,D,X=v.length;for(;X>1&&(v instanceof it?(M=v.getXAtUncheckedPointIndex(0),b=v.getYAtUncheckedPointIndex(0),E=v.getXAtUncheckedPointIndex(X-1),D=v.getYAtUncheckedPointIndex(X-1)):K.isArrayOfNumberArray(v,X,2)?(M=v[0][0],b=v[0][1],E=v[X-1][0],D=v[X-1][1]):(M=v[0].x,b=v[0].y,E=v[X-1].x,D=v[X-1].y),K.isAlmostEqualNumber(M,E)&&K.isAlmostEqualNumber(b,D));)--X;return X}static directCreateFaceLoopFromCoordinates(v,M){const b=this.getUnwrappedLength(M);let E;if(M instanceof it){const D=Q.create();for(let X=0;X<b;X++)M.getPoint3dAtCheckedPointIndex(X,D),E=Ps.interiorEdgeSplit(v,E,D)}else for(let D=0;D<b;D++)E=Ps.interiorEdgeSplit(v,E,M[D]);return E}static directCreateChainsFromCoordinates(v,M,b=0){const E=new Is(v,b);return lt.streamXYZ(M,E),E.claimSeeds()}static maskAndOrientNewFaceLoop(v,M,b,E,D){if(M){const v=(M=M.faceSuccessor).signedFaceArea(),X=M.edgeMate;E!==Rr.NULL_MASK&&(M.setMaskAroundFace(E),X.setMaskAroundFace(E));let z=M;b&&v<0&&(z=X);const R=z.vertexSuccessor;return D!==Rr.NULL_MASK&&R.setMaskAroundFace(D),z}}static createFaceLoopFromCoordinates(v,M,b,E){const D=Ps.directCreateFaceLoopFromCoordinates(v,M);return Ps.maskAndOrientNewFaceLoop(v,D,b,Rr.BOUNDARY_EDGE|Rr.PRIMARY_EDGE,E?Rr.EXTERIOR:Rr.NULL_MASK)}static createFaceLoopFromCoordinatesAndMasks(v,M,b,E,D){const X=Ps.directCreateFaceLoopFromCoordinates(v,M);return Ps.maskAndOrientNewFaceLoop(v,X,b,E,D)}static joinNeighborsOfEar(v,M){const b=v.createEdgeXYZXYZ(M.facePredecessor.x,M.facePredecessor.y,M.facePredecessor.z,M.facePredecessor.i,M.faceSuccessor.x,M.faceSuccessor.y,M.faceSuccessor.z,M.faceSuccessor.i),E=b.edgeMate;Zi.pinch(M.faceSuccessor,E),Zi.pinch(M.facePredecessor,b),M.setMaskAroundFace(Rr.TRIANGULATED_FACE)}static isInteriorTriangle(v){if(!v.isMaskSet(Rr.TRIANGULATED_FACE)||v.isMaskSet(Rr.EXTERIOR))return!1;const M=v.faceSuccessor;if(!M.isMaskSet(Rr.TRIANGULATED_FACE)||M.isMaskSet(Rr.EXTERIOR))return!1;const b=M.faceSuccessor;return!(!b.isMaskSet(Rr.TRIANGULATED_FACE)||b.isMaskSet(Rr.EXTERIOR))&&b.faceSuccessor===v}static doPostCutFlips(v){let M=v,b=M.facePredecessor,E=b.edgeMate;for(;Ps.isInteriorTriangle(b)&&Ps.isInteriorTriangle(E)&&Ps.computeInCircleDeterminantIsStrongPositive(b);){const v=E.faceSuccessor;Ps.flipEdgeBetweenTriangles(v,v.faceSuccessor,v.facePredecessor,M,M.facePredecessor,M.faceSuccessor),M=b,b=M.facePredecessor,E=b.edgeMate}return M}static triangulateSingleFace(v,M){if(!M)return Ps.setDebugGraph(v),!1;let b,E,D,X=M.countEdgesAroundFace(),z=0;for(M.clearMaskAroundFace(Rr.TRIANGULATED_FACE);!M.isMaskSet(Rr.TRIANGULATED_FACE);){if(D=M?.facePredecessor,b=M.faceSuccessor,E=b.faceSuccessor,b===M||E===M)return!0;if(E.faceSuccessor===M)return M.setMaskAroundFace(Rr.TRIANGULATED_FACE),!0;if(!K.isAlmostEqualXAndY(E,D)||E.findAroundVertex(D)){if(++z>X)return Ps.setDebugGraph(v),!1;Ps.isEar(M)?(X--,z=0,M.faceSuccessor.faceSuccessor!==M.facePredecessor?(Ps.joinNeighborsOfEar(v,M),M=(M=Ps.doPostCutFlips(M)).faceSuccessor.edgeMate.faceSuccessor):(M.setMaskAroundFace(Rr.TRIANGULATED_FACE),M=b.faceSuccessor)):M=b}else{const v=E.faceSuccessor;if(this.nodeInTriangle(D,M,b,v)){const v=E.vertexPredecessor;Zi.pinch(D.vertexSuccessor,v)}else Zi.pinch(D,E),M.setMaskAroundFace(Rr.TRIANGULATED_FACE);M=E}}return!0}static claimDebugGraph(){const v=Ps.sDebugGraph;return Ps.sDebugGraph=void 0,Ps.sEnableDebugGraphCapture=!1,v}static setDebugGraph(v){Ps.sEnableDebugGraphCapture&&(Ps.sDebugGraph=v)}static clearAndEnableDebugGraphCapture(v){Ps.sEnableDebugGraphCapture=v,Ps.sDebugGraph=void 0}static findAroundOrAtVertex(v,M){return!!v.findAroundVertex(M)||K.isAlmostEqualXAndY(v,M)}static isEar(v){const M=v.facePredecessor,b=v,E=v.faceSuccessor,D=Ps.signedTolerancedCCWTriangleArea(M,b,E);if(D<=0)return!1;const X=this._planes;if(!yt.createOriginAndTargetXY(M,b,X[0])||!yt.createOriginAndTargetXY(b,E,X[1])||!yt.createOriginAndTargetXY(E,M,X[2]))return!1;const z=this._earRange,R=this._edgeRange,O=this._edgeInterval;gt.createXYXYXY(M.x,M.y,b.x,b.y,E.x,E.y,z),z.expandInPlace(K.smallMetricDistance);let Y=E;const N=1e-10*D;for(;Y!==M;){const v=Y.faceSuccessor;if(gt.createXYXY(Y.x,Y.y,v.x,v.y,R),z.intersectsRange(R)&&(ft.createXX(-1e-8,1.00000001,O),ds.clipSegmentBelowPlanesXY(X,Y,v,O,N),!O.isNull))if(O.low>.99999999){if(!this.findAroundOrAtVertex(M,v)&&!this.findAroundOrAtVertex(b,v)&&!this.findAroundOrAtVertex(E,v))return!1}else if(O.high<1e-8){if(!this.findAroundOrAtVertex(M,Y)&&!this.findAroundOrAtVertex(b,Y)&&!this.findAroundOrAtVertex(E,Y))return!1}else if(this.findAroundOrAtVertex(b,v)&&this.findAroundOrAtVertex(E,Y));else if(!this.findAroundOrAtVertex(M,v)||!this.findAroundOrAtVertex(b,Y))return!1;Y=Y.faceSuccessor}return!0}static spliceLeftMostNodesOfHoles(v,M,b){b.sort(((v,M)=>Ps.compareX(v,M)));let E=0;for(const D of b)Ps.eliminateHole(v,D,M)||E++;return 0===E?M:void 0}static compareX(v,M){return v.x-M.x}static eliminateHole(v,M,b){const E=Ps.findHoleBridge(M,b);return!!E&&void 0!==Ps.splitFace(v,E,M)}static findHoleBridge(v,M){let b=M;if(!b)return;const E=v.x,D=v.y;let X,z=-1/0;do{if(D<=b.y&&D>=b.faceSuccessor.y&&b.faceSuccessor.y!==b.y){const v=b.x+(D-b.y)*(b.faceSuccessor.x-b.x)/(b.faceSuccessor.y-b.y);if(v<=E&&v>z){if(z=v,v===E){if(D===b.y)return b;if(D===b.faceSuccessor.y)return b.faceSuccessor}X=b.x<b.faceSuccessor.x?b:b.faceSuccessor}}b=b.faceSuccessor}while(b!==M);if(!X)return;if(E===z)return X.facePredecessor;const R=X,O=X.x,Y=X.y;let N,B=1/0;for(b=X.faceSuccessor;b!==R;)E>=b.x&&b.x>=O&&E!==b.x&&Ps.pointInTriangle(D<Y?E:z,D,O,Y,D<Y?z:E,D,b.x,b.y)&&(N=Math.abs(D-b.y)/(E-b.x),(N<B||N===B&&b.x>X.x)&&Ps.locallyInside(b,v)&&(X=b,B=N)),b=b.faceSuccessor;return X}static getLeftmost(v){let M=v,b=v;do{M.x<b.x&&(b=M),M=M.faceSuccessor}while(M!==v);return b}static pointInTriangle(v,M,b,E,D,X,z,R){return(D-z)*(M-R)-(v-z)*(X-R)>=0&&(v-z)*(E-R)-(b-z)*(M-R)>=0&&(b-z)*(X-R)-(D-z)*(E-R)>=0}static nodeInTriangle(v,M,b,E){return Ps.signedTolerancedCCWTriangleArea(v,M,E)>0&&Ps.signedTolerancedCCWTriangleArea(M,b,E)>0&&Ps.signedTolerancedCCWTriangleArea(b,v,E)>0}static signedCWTriangleArea(v,M,b){return.5*((M.y-v.y)*(b.x-M.x)-(M.x-v.x)*(b.y-M.y))}static signedTolerancedCCWTriangleArea(v,M,b,E=1e-12){const D=M.x-v.x,X=M.y-v.y,z=b.x-v.x,R=b.y-v.y,O=.5*(D*R-X*z);return O<0?O:O<E*(D*D+X*X+(z*z+R*R))?0:O}static isAlmostEqualXAndYXY(v,M,b){return K.isAlmostEqualNumber(v.x,M)&&K.isAlmostEqualNumber(v.y,b)}static locallyInside(v,M){return Ps.signedCWTriangleArea(v.facePredecessor,v,v.faceSuccessor)<0?Ps.signedCWTriangleArea(v,M,v.faceSuccessor)>=0&&Ps.signedCWTriangleArea(v,v.facePredecessor,M)>=0:Ps.signedCWTriangleArea(v,M,v.facePredecessor)<0||Ps.signedCWTriangleArea(v,v.faceSuccessor,M)<0}static splitFace(v,M,b){if(Zi.isNodeVisibleInSector(M,b)&&Zi.isNodeVisibleInSector(b,M)){const E=v.createEdgeXYZXYZ(M.x,M.y,M.z,M.i,b.x,b.y,b.z,b.i),D=E.faceSuccessor;return Zi.pinch(M,E),Zi.pinch(b,D),E}}static triangulateSingleMonotoneFace(v,M){let b,E=M.facePredecessor,D=M.faceSuccessor;for(;E!==D&&D!==M&&D.faceSuccessor!==E;){if(Zi.crossProductXYAlongChain(E,M,D)<=0)return!1;if(!M.belowYX(E))return!1;if(!M.belowYX(D))return!1;if(E.belowYX(D)){let X=E,z=M,R=D;for(;X!==R&&X.belowYX(D);){for(;R!==D&&R!==X&&R!==z&&Zi.crossProductXYAlongChain(X,z,R)>0;){if(b=Ps.splitFace(v,X,R),void 0===b)return!1;X=b,z=X.faceSuccessor,R=z.faceSuccessor}R=z,z=X,X=X.facePredecessor}for(E=z,R=D,z=R.facePredecessor,X=z.facePredecessor;R.faceSuccessor!==X&&X!==E;){if(b=Ps.splitFace(v,X,R),void 0===b)return!1;z=b,X=z.facePredecessor}if(R.faceSuccessor!==X){if(b=Ps.splitFace(v,X,R),void 0===b)return!1;X=b}D=(M=X).faceSuccessor,E=M.facePredecessor}else{let X=E,z=M,R=D;for(;X!==R&&R.belowYX(E);){for(;X!==E&&R!==X&&R!==z&&Zi.crossProductXYAlongChain(X,z,R)>0;){if(b=Ps.splitFace(v,X,R),void 0===b)return!1;X=b.facePredecessor,z=b}X=z,z=R,R=R.faceSuccessor}for(D=z,X=E,z=X.faceSuccessor,R=z.faceSuccessor;R.faceSuccessor!==X&&R!==D;){if(b=Ps.splitFace(v,X,R),void 0===b)return!1;X=b,R=R.faceSuccessor}if(R.faceSuccessor!==X&&void 0===Ps.splitFace(v,X,R))return!1;D=(M=D).faceSuccessor,E=M.facePredecessor}}return!0}}Ps.sEnableDebugGraphCapture=!1,Ps._edgeInterval=ft.createNull(),Ps._earRange=gt.createNull(),Ps._edgeRange=gt.createNull(),Ps._planes=[yt.createXYPlane(),yt.createXYPlane(),yt.createXYPlane()];class Is extends ot{constructor(v,M){super(),this._graph=v,this._id=M}startChain(v,M){super.startChain(v,M),this._baseNode=void 0,this._nodeB=void 0}handleXYZXYZ(v,M,b,E,D,X){this._nodeC=this._graph.createEdgeXYZXYZ(v,M,b,this._id,E,D,X,this._id),void 0===this._baseNode?(this._baseNode=this._nodeC,this._nodeB=this._baseNode.faceSuccessor):(Zi.pinch(this._nodeB,this._nodeC),this._nodeB=this._nodeC.faceSuccessor)}endChain(v,M){super.endChain(v,M),void 0!==this._baseNode&&(void 0===this._seeds&&(this._seeds=[]),this._seeds.push(this._baseNode)),this._baseNode=void 0,this._nodeB=void 0,this._nodeC=void 0}claimSeeds(){return void 0===this._seeds?[]:this._seeds}}class As{constructor(){this.numUpEdge=0,this.numIntersectionTest=0,this.numSplit=0,this.numPopOut=0,this.numA0B0=0,this.numA0B1=0}}class Ss{constructor(v,M,b,E){this.index=v,this.radiusOfCurvature=M,this.node=b,this.radians=E}}class ws{static compareNodesYXUp(v,M){return v.y<M.y?-1:v.y>M.y?1:v.x<M.x?-1:v.x>M.x?1:0}static isDownPeak(v){const M=v.facePredecessor,b=v.faceSuccessor;return this.compareNodesYXUp(v,M)<0&&this.compareNodesYXUp(v,b)<0&&this.crossProductToTargets(v,M,b)>0}static crossProductToTargets(v,M,b){return K.crossProductXYXY(M.x-v.x,M.y-v.y,b.x-v.x,b.y-v.y)}static graphRange(v){const M=ut.create();for(const b of v.allHalfEdges)M.extendXYZ(b.x,b.y,b.z);return M}static segmentArrayToGraphEdges(v,M,b){const E=[];let D=0;for(const X of v){const v=M.createEdgeXYZXYZ(X.point0Ref.x,X.point0Ref.y,X.point0Ref.z,D,X.point1Ref.x,X.point1Ref.y,X.point1Ref.z,D+1),z=v.edgeMate;D+=2,v.setMaskAroundFace(b),E.push(v),E.push(z)}return E}static isolateAllEdges(v){for(const M of v.allHalfEdges){const v=M.vertexPredecessor;Zi.pinch(M,v)}}static isSectorConvexAfterEdgeRemoval(v,M,b,E=0){let D=v;do{if(D.isMaskSet(b)||D.edgeMate.isMaskSet(b))break;D=D.vertexSuccessor}while(D!==v&&D.isMaskSet(M));if(D===v)return!1;let X=v;do{if(X.isMaskSet(b)||X.edgeMate.isMaskSet(b))break;X=X.vertexPredecessor}while(X!==v&&X.isMaskSet(M));return X!==v&&Zi.isSectorConvex(D.edgeMate,v,X.faceSuccessor,E)}static markRemovableEdgesToExpandConvexFaces(v,M,b=Rr.BOUNDARY_EDGE){if(Rr.NULL_MASK===M)return 0;const E=v.grabMask(!0);let D=0;for(const X of v.allHalfEdges){if(!X.isMaskSet(E)&&!X.isMaskSet(b)&&!X.edgeMate.isMaskSet(b)){const v=K.smallMetricDistanceSquared*(X.signedFaceArea()+X.edgeMate.signedFaceArea());this.isSectorConvexAfterEdgeRemoval(X,M,b,v)&&this.isSectorConvexAfterEdgeRemoval(X.edgeMate,M,b,v)&&(X.setMaskAroundEdge(M),++D)}X.setMaskAroundEdge(E)}return v.dropMask(E),D}static collectRemovableEdgesToExpandConvexFaces(v,M=Rr.BOUNDARY_EDGE){const b=[],E=v.grabMask(!0);if(0<this.markRemovableEdgesToExpandConvexFaces(v,E,M)){const M=v.grabMask(!0);for(const D of v.allHalfEdges)D.isMaskSet(E)&&!D.isMaskSet(M)&&(D.setMaskAroundEdge(M),b.push(D));v.dropMask(M)}return v.dropMask(E),b}static expandConvexFaces(v,M=Rr.BOUNDARY_EDGE){const b=v.grabMask(!0),E=this.markRemovableEdgesToExpandConvexFaces(v,b,M);return E>0&&e(.5*v.yankAndDeleteEdges((v=>v.getMask(b)))===E),v.dropMask(b),E}static isEveryFaceConvex(v,M=Rr.EXTERIOR){const b=v.collectFaceLoops();for(const E of b)if(!E.isMaskedAroundFace(M)&&!E.isFaceConvex())return!1;return!0}}class Cs{static getCommonThetaEndIndex(v,M,b,E){let D=b+1;const X=v.getExtraData(M[b],0);for(;D<E;){const b=v.getExtraData(M[D],0);if(!W.isAlmostEqualRadiansAllowPeriodShift(X,b))return D;D++}return D}static set announceVertexNeighborhoodFunction(v){this._announceVertexNeighborhoodFunction=v}static doAnnounceVertexNeighborhood(v,M,b,E,D){if(this._announceVertexNeighborhoodFunction){const X=[];for(let z=E;z<D;z++){const E=v.getExtraData(M[z],1),D=v.getExtraData(M[z],0),R=b[E],O=this.curvatureSortKey(R);X.push(new Ss(M[z],O,R,D))}this._announceVertexNeighborhoodFunction(X)}}static secondarySortAroundVertex(v,M,b,E,D){const X=[];for(let z=E;z<D;){const E=this.getCommonThetaEndIndex(v,M,z,D);if(z+1<E){X.length=0;for(let D=z;D<E;D++){const E=b[v.getExtraData(M[D],1)],z=this.curvatureSortKey(E);X.push(new Ss(M[D],z,E))}X.sort(((v,M)=>v.radiusOfCurvature-M.radiusOfCurvature));for(let v=0;v<X.length;v++)M[z+v]=X[v].index}z=E}}static curvatureSortKey(v){const M=v.edgeTag;if(void 0!==M){const b=M.fraction,E=M.curve;if(E){let M=E.fractionToSignedXYRadiusOfCurvature(b);return void 0!==v.sortData&&v.sortData<0&&(M=-M),M}}return 0}static isNullFace(v){return v.isMaskSet(Rr.NULL_FACE)&&v.faceSuccessor.isMaskSet(Rr.NULL_FACE)&&v===v.faceSuccessor.faceSuccessor}static clusterAndMergeXYTheta(v,M){const b=v.allHalfEdges,E=b.length;v.clearMask(Rr.NULL_FACE);const D=new li(2,2,E);for(let V=0;V<E;V++){const v=b[V],M=v.x,E=v.y;Zi.pinch(v,v.vertexSuccessor),D.addDirect(M,E,0,V)}const X=K.smallMetricDistance,z=D.clusterIndicesLexical(X);let R=0;const O=z.length;for(let V=0;V<O;V++)if(z[V]===li.clusterTerminator){if(V>R){const v=b[D.getExtraData(z[R],1)];for(let M=R+1;M<V;M++){const E=b[D.getExtraData(z[M],1)];E.x=v.x,E.y=v.y}}R=V+1}for(const V of z)if(V!==li.clusterTerminator){const v=b[V],E=v.faceSuccessor;let X=M;if(X){const M=v.edgeTag;(void 0===M||void 0===M.curve||M.curve instanceof we)&&(X=void 0)}let z=X?X(v):Math.atan2(E.y-v.y,E.x-v.x);W.isAlmostEqualRadiansAllowPeriodShift(z,-Math.PI)&&(z=Math.PI),D.setExtraData(V,0,z)}D.sortSubsetsBySingleKey(z,2);const Y=[];let N,B;R=0;for(let V=0;V<O;V++)if(z[V]===li.clusterTerminator){if(V>R){V>R+1&&this.secondarySortAroundVertex(D,z,b,R,V),this.doAnnounceVertexNeighborhood(D,z,b,R,V);const v=D.getExtraData(z[R],1);N=D.getExtraData(z[R],0);let M=b[v];for(let E=R+1;E<V;E++){const v=D.getExtraData(z[E],1);B=D.getExtraData(z[E],0);const R=b[v];if(M.isMaskSet(Rr.NULL_FACE)){const v=Y.findIndex((v=>M===v));v>=0&&(Y[v]=Y[Y.length-1],Y.pop()),M=R,N=B}else if(R.isMaskSet(Rr.NULL_FACE)){const v=Y.findIndex((v=>R===v));v>=0&&(Y[v]=Y[Y.length-1],Y.pop())}else{if(Zi.pinch(M,R),W.isAlmostEqualRadiansAllowPeriodShift(N,B)){const v=M.faceSuccessor,b=R.edgeMate;if(v.isEqualXY(b)){const E=this.curvatureSortKey(M),D=this.curvatureSortKey(R);K.isSameCoordinate(E,D,X)&&(Zi.pinch(v,b),M.setMask(Rr.NULL_FACE),b.setMask(Rr.NULL_FACE),Y.push(b))}}M=R,N=B}}}R=V+1}}static buildVerticalSweepPriorityQueue(v){const M=new Gi;for(const b of v.allHalfEdges)ws.compareNodesYXUp(b,b.faceSuccessor)<0&&M.priorityQueue.push(b);return M}static snapFractionToNode(v,M,b,E){return K.isSameCoordinate(v.x,b.x)&&K.isSameCoordinate(v.y,b.y)?E:M}static computeIntersectionFractionsOnEdges(v,M,b,E,D){const X=v.faceSuccessor,z=v.x,R=v.y,O=X.x-z,Y=X.y-R,N=M.faceSuccessor,B=M.x,V=M.y,L=N.x-B,U=N.y-V;return!!Ft.lineSegmentXYUVTransverseIntersectionUnbounded(z,R,O,Y,B,V,L,U,b)&&(E.x=z+b.x*O,E.y=R+b.x*Y,D.x=B+b.y*L,D.y=V+b.y*U,b.x=this.snapFractionToNode(E,b.x,v,0),b.x=this.snapFractionToNode(E,b.x,X,1),b.y=this.snapFractionToNode(D,b.y,M,0),b.y=this.snapFractionToNode(D,b.y,N,1),K.isIn01(b.x)&&K.isIn01(b.y))}static splitIntersectingEdges(v){const M=new As,b=this.buildVerticalSweepPriorityQueue(v);let E,D;const X=.99999999;let z;const R=J.create(),O=H.create(),Y=H.create();let N;const B=K.smallMetricDistance;for(;void 0!==(E=b.priorityQueue.pop());){M.numUpEdge++;const V=b.activeEdges.length;for(b.removeArrayMembersWithY1Below(E.y-B),M.numPopOut+=V-b.activeEdges.length,z=0;z<b.activeEdges.length;z++)if(N=b.activeEdges[z],D=N.faceSuccessor,K.isSameCoordinateXY(E.x,E.y,N.x,N.y))M.numA0B0++;else if(K.isSameCoordinateXY(D.x,D.y,E.x,E.y))M.numA0B1++;else if(M.numIntersectionTest++,this.computeIntersectionFractionsOnEdges(E,N,R,O,Y)){if(R.x>1e-8&&R.x<X){const D=v.splitEdgeAtFraction(E,R.x);b.priorityQueue.push(D),M.numSplit++}if(R.y>1e-8&&R.y<X){const E=v.splitEdgeAtFraction(N,R.y);b.priorityQueue.push(E),M.numSplit++}}b.activeEdges.push(E)}return M}static formGraphFromSegments(v){const M=new qi;return ws.segmentArrayToGraphEdges(v,M,Rr.BOUNDARY_EDGE),this.splitIntersectingEdges(M),this.clusterAndMergeXYTheta(M),M}static formGraphFromChains(v,M=!0,b=Rr.PRIMARY_EDGE){if(v.length<1)return;const E=new qi,D=Ps.directCreateChainsFromCoordinates(E,v);for(const X of D)X.setMaskAroundFace(b);return this.splitIntersectingEdges(E),this.clusterAndMergeXYTheta(E),M&&new Hi(E).regularizeGraph(!0,!0),E}}class Ts{static createPrimarySortVector(v){return void 0===v&&(v=this._defaultPrimarySortDirection.clone()),v.normalizeWithDefault(Ts._defaultPrimarySortDirection.x,Ts._defaultPrimarySortDirection.y,Ts._defaultPrimarySortDirection.z)}constructor(v,M){this.tolerance=v,this.primarySortDirection=M}static createFromUnValidated(v){const M=new Ts(K.smallMetricDistance,Ts.createPrimarySortVector());return void 0!==v&&(void 0!==v.tolerance&&(M.tolerance=v.tolerance),void 0!==v.primarySortDirection&&(M.primarySortDirection=Ts.createPrimarySortVector())),M}clone(){return new Ts(this.tolerance,this.primarySortDirection)}}Ts._defaultPrimarySortDirection=$.create(.294234298,.72391399,.45234328798);class Fs{constructor(v){this._graph=new qi,this._options=v}set plane(v){this._plane=v}get plane(){return this._plane}set convexClipper(v){this._convexClipper=v}get convexClipper(){return this._convexClipper}static create(v){const M=Ts.createFromUnValidated(v);return new Fs(M)}addSegment(v,M){this._graph.createEdgeXYZXYZ(v.x,v.y,v.z,0,M.x,M.y,M.z,0)}addLineSegment3dArray(v){for(const M of v)this.addSegment(M.point0Ref,M.point1Ref)}addSegmentsOnPlane(v,M=!1){if(!this._plane)return;const b=this._plane;let E,D=M?v.length-1:0,X=v.evaluateUncheckedIndexPlaneAltitude(D,b),z=M?0:1;for(;z<v.length;D=z++,X=E)E=v.evaluateUncheckedIndexPlaneAltitude(z,b),K.isSmallMetricDistance(X)&&K.isSmallMetricDistance(E)&&this._graph.createEdgeXYZXYZ(v.getXAtUncheckedPointIndex(D),v.getYAtUncheckedPointIndex(D),v.getZAtUncheckedPointIndex(D),0,v.getXAtUncheckedPointIndex(z),v.getYAtUncheckedPointIndex(z),v.getZAtUncheckedPointIndex(z),0)}primarySortKey(v){return this._options.primarySortDirection.dotProductXYZ(v.x,v.y,v.z)}static nodeCompareSortData(v,M){return v.sortData-M.sortData}static isIsolatedEnd(v){return v.vertexSuccessor===v}static isChainInteriorVertex(v){const M=v.vertexSuccessor;return M!==v&&M.vertexSuccessor===v}clusterAndMergeVerticesXYZ(){ws.isolateAllEdges(this._graph);for(const E of this._graph.allHalfEdges)E.sortData=this.primarySortKey(E);const v=this._graph.allHalfEdges.slice();v.sort(((v,M)=>Fs.nodeCompareSortData(v,M)));const M=this._options.tolerance,b=v.length;for(let E=0;E<b;E++){const D=v[E],X=D.sortData+M;if(Fs.isIsolatedEnd(D))for(let z=E+1;z<b;z++){const b=v[z];if(Fs.isIsolatedEnd(b)){if(b.sortData>X)break;D.distanceXYZ(b)<=M&&(Zi.pinch(D,b),b.setXYZFrom(D))}}}}collectMaximalLineString3dFromStartNode(v,M,b){if(!M.isMaskSet(b)){const E=ke.create();for(E.addPointXYZ(M.x,M.y,M.z);M.setMask(b),M.edgeMate.setMask(b),M=M.faceSuccessor,E.addPointXYZ(M.x,M.y,M.z),!M.isMaskSet(b)&&Fs.isChainInteriorVertex(M););v.push(E)}}collectMaximalGrowableXYXArrayFromStartNode(v,M,b){if(!M.isMaskSet(b)){const E=new nt;for(E.pushXYZ(M.x,M.y,M.z);M.setMask(b),M.edgeMate.setMask(b),M=M.faceSuccessor,E.pushXYZ(M.x,M.y,M.z),!M.isMaskSet(b)&&Fs.isChainInteriorVertex(M););E.length>0&&v.push(E)}}exciseAndMarkSlingEdges(v){let M=0;for(const b of this._graph.allHalfEdges)if(b.distanceXYZ(b.edgeMate)<this._options.tolerance&&!b.isMaskSet(v)){const E=b.edgeMate;Zi.pinch(b,b.vertexPredecessor),Zi.pinch(E,E.vertexPredecessor),b.setMask(v),E.setMask(v),M++}return M}collectMaximalChains(){const v=[],M=Rr.VISITED;this.exciseAndMarkSlingEdges(M),this._graph.clearMask(M);for(const b of this._graph.allHalfEdges)Fs.isChainInteriorVertex(b)||this.collectMaximalLineString3dFromStartNode(v,b,M);for(const b of this._graph.allHalfEdges)this.collectMaximalLineString3dFromStartNode(v,b,M);return v}collectMaximalGrowableXYZArrays(){const v=[],M=Rr.VISITED;this.exciseAndMarkSlingEdges(M),this._graph.clearMask(M);for(const b of this._graph.allHalfEdges)Fs.isChainInteriorVertex(b)||this.collectMaximalGrowableXYXArrayFromStartNode(v,b,M);for(const b of this._graph.allHalfEdges)this.collectMaximalGrowableXYXArrayFromStartNode(v,b,M);return v}}class ks{constructor(){this._unmatchedEdges=new Map,this._graph=new qi,this._halfEdgesAroundCurrentLoop=[]}get graph(){return this._graph}indexPairToString(v,M){return`${v.toString()},${M.toString()}`}insertLoop(v,M){if(v.length>1){let b=v[v.length-1];this._halfEdgesAroundCurrentLoop.length=0;for(const D of v){const v=this.indexPairToString(b,D),E=this._unmatchedEdges.get(v);if(void 0===E){const v=this.indexPairToString(D,b),E=this._graph.createEdgeIdId(b,D);void 0!==M&&M(E),this._unmatchedEdges.set(v,E.edgeMate),this._halfEdgesAroundCurrentLoop.push(E),E.edgeMate.setMask(Rr.EXTERIOR)}else this._halfEdgesAroundCurrentLoop.push(E),E.clearMask(Rr.EXTERIOR);b=D}let E=this._halfEdgesAroundCurrentLoop[this._halfEdgesAroundCurrentLoop.length-1];for(const v of this._halfEdgesAroundCurrentLoop){const M=E.faceSuccessor;Zi.pinch(v,M),E=v}return this._halfEdgesAroundCurrentLoop[0]}}}class Ms{constructor(v){this.positiveSum=this.negativeSum=0,this.numPositive=this.numNegative=this.numZero=0,this.largestPositiveValue=this.largestNegativeValue=0,v&&(this.negativeItemArray=[],this.positiveItemArray=[],this.zeroItemArray=[])}announceItem(v,M){M<0?(this.numNegative++,this.negativeSum+=M,this.negativeItemArray&&this.negativeItemArray.push(v),M<this.largestNegativeValue&&(this.largestNegativeValue=M,this.largestNegativeItem=v)):M>0?(this.numPositive++,this.positiveSum+=M,this.positiveItemArray&&this.positiveItemArray.push(v),M>this.largestPositiveValue&&(this.largestPositiveValue=M,this.largestPositiveItem=v)):(this.numZero++,this.zeroItemArray&&this.zeroItemArray.push(v))}}class bs{constructor(v,M=!0){this._targetMask=v,this._targetValue=M}testEdge(v){return v.isMaskSet(this._targetMask)===this._targetValue}}class Es{static pushAndMaskAllNodesInFace(v,M,b,E){E.push(v),v.collectAroundFace((v=>{v.setMask(M),b.push(v)}))}static findMinimumAreaFace(v,M){return Es.collectFaceAreaSummary(v,!1,M).largestNegativeItem}static signedFaceArea(v){return v.signedFaceArea()}static collectFaceAreaSummary(v,M=!1,b=(v=>Es.signedFaceArea(v))){const E=new Ms(M);let D;D=v instanceof qi?v.collectFaceLoops():v;for(const X of D){const v=b(X);E.announceItem(X,v)}return E}static isTriangulatedCCW(v,M=!0,b=0){let E;E=v instanceof qi?v.collectFaceLoops():v;let D=0,X=0;for(const z of E){const v=z.countEdgesAroundFace();if(v>=3)if(z.signedFaceArea()>0){if(v>3&&(X++,X>b))return!1}else if(D++,D>1&&!M)return!1}return!0}static parityFloodFromSeed(v,M,b,E){const D=[];if(v.isMaskSet(M))return D;const X=E|M,z=[];for(Es.pushAndMaskAllNodesInFace(v,X,z,D);z.length>0;){const v=z.pop(),R=v.edgeMate;if(R&&!R.isMaskSet(M)){let O=v.isMaskSet(E);b&&!b.testEdge(v)||(O=!O),Es.pushAndMaskAllNodesInFace(R,O?X:M,z,D)}}return D}static correctParityInSingleComponent(v,M,b){const E=Es.findMinimumAreaFace(b);if(E)if(E.isMaskSet(M));else for(const D of b)D.isMaskSet(M)?D.clearMaskAroundFace(M):D.setMaskAroundFace(M)}static correctParityInComponentArrays(v,M,b){if(M!==Rr.NULL_MASK)for(const E of b)Es.correctParityInSingleComponent(v,M,E)}static collectConnectedComponentsWithExteriorParityMasks(v,M,b=Rr.NULL_MASK){const E=[],D=Rr.VISITED,X=b|D;v.clearMask(X);for(const z of v.allHalfEdges)if(!z.isMaskSet(Rr.VISITED)){const v=Es.parityFloodFromSeed(z,D,M,b);E.push(v)}return Es.correctParityInComponentArrays(v,b,E),E}static pointInOrOnFaceXY(v,M,b){const E=new Rt(M,b);let D=v,X=v.faceSuccessor;for(;!E.tryStartEdge(D.x,D.y,X.x,X.y);D=X){if(X===v)return E.classifyCounts();X=D.faceSuccessor}let z=X.faceSuccessor;for(;;){if(!E.advance(z.x,z.y))return E.classifyCounts();if(z===X)break;z=z.faceSuccessor}return E.classifyCounts()}static collectExtendedBoundaryLoopFromSeed(v,M,b,E){let D=0;for(;!v.getMask(M)&&b(v);){E(v,D++),v.setMask(M);const X=v.faceSuccessor;let z=X;for(;;){if(z.getMask(M))return;if(b(z)){v=z;break}if(z=z.vertexPredecessor,z===X)break}}}static collectExtendedBoundaryLoopsInGraph(v,M){const b=[],E=v.grabMask(!0),n=v=>0===v.getMask(M)&&0!==v.edgeMate.getMask(M),r=(v,M)=>{0===M&&b.push([]),b[b.length-1].push(v)};for(const D of v.allHalfEdges)this.collectExtendedBoundaryLoopFromSeed(D,E,n,r);return v.dropMask(E),b}}class Ds{static spaceTriangleAspectRatio(v,M,b){const E=.5*v.crossProductToPoints(M,b).magnitude(),D=v.distanceSquared(M)+M.distanceSquared(b)+b.distanceSquared(v);return K.safeDivideFraction(E,D,0)}static spaceQuadDiagonalAspectRatio(v,M,b,E){const D=this.spaceTriangleAspectRatio(v,M,b),X=this.spaceTriangleAspectRatio(v,b,E);return Math.max(D,X)}static triangulateGreedyEarCut(v,M){const b=vr.areaNormal(v),E=[],D=v.slice();for(oi.removeClosurePoint(D);D.length>2;){let v,M=-1,X=0,z=D.length-2,R=D.length-1;for(v=0;v<D.length;z=R,R=v,v++){const E=this.spaceTriangleAspectRatio(D[z],D[R],D[v]);D[z].crossProductToPoints(D[R],D[v]).dotProduct(b)>0&&E>M&&(M=E,X=z)}if(M<=0)return!1;z=X,R=(z+1)%D.length,v=(R+1)%D.length;const O=[];O.push(D[z],D[R],D[v]),D.splice(R,1),E.push(O)}return M(v,E),!0}static triangulateSimplestSpaceLoopGo(v,M,b){const E=de.countNonDuplicates(v);if(void 0!==b&&de.sumEdgeLengths(v,!0,E)>b)return!1;if(E<3)return!1;if(3===E)return 0!==this.spaceTriangleAspectRatio(v[0],v[1],v[2])&&(M(v,[v.slice()]),!0);if(4===E){const b=this.spaceQuadDiagonalAspectRatio(v[0],v[1],v[2],v[3]),E=this.spaceQuadDiagonalAspectRatio(v[1],v[2],v[3],v[0]);return!(0===b&&0===E||(b>E?(M(v,[[v[0],v[1],v[2]],[v[2],v[3],v[0]]]),0):(M(v,[[v[0],v[1],v[3]],[v[3],v[1],v[2]]]),0)))}return this.triangulateGreedyEarCut(v,M)}static triangulateSimplestSpaceLoop(v,M,b){return v instanceof ke?this.triangulateSimplestSpaceLoopGo(v.points,M,b):this.triangulateSimplestSpaceLoopGo(v,M,b)}}class Xs{constructor(v=-1,M){this._facetIndex=v,this._detail=M||Bi.create()}invalidate(v=!0){this._facetIndex=-1,v&&this._detail.invalidate(),this._normal=void 0,this._param=void 0,this._color=void 0}static create(v,M,b){return void 0===b?new Xs(v,M):(b.invalidate(!1),b._facetIndex=v,void 0!==M&&b._detail.copyContentsFrom(M),b)}get facetIndex(){return this._facetIndex}get edgeCount(){return 3}get point(){return this._detail.world}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!0}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.classify}clone(){const v=new Xs;return v.copyContentsFrom(this),v}copyContentsFrom(v){this._facetIndex=v._facetIndex,this._detail.copyContentsFrom(v._detail),this._normal=v._normal?.clone(),this._param=v._param?.clone(),this._color=v._color}getNormal(v){if(this._detail.isValid&&void 0===this._normal&&void 0!==v){this._normal=$.create();const M=[this._detail.local.x,this._detail.local.y,this._detail.local.z];v.linearCombination(M,this._normal)}return this._normal}getParam(v){if(this._detail.isValid&&void 0===this._param&&void 0!==v){this._param=H.create();const M=[this._detail.local.x,this._detail.local.y,this._detail.local.z];v.linearCombination(M,this._param)}return this._param}getColor(v){if(this._detail.isValid&&void 0===this._color&&void 0!==v){const M=[this._detail.local.x,this._detail.local.y,this._detail.local.z];this._color=he.linearCombinationOfColors(v,M)}return this._color}getBarycentricCoordinates(){return[this._detail.local.x,this._detail.local.y,this._detail.local.z]}}class Rs{constructor(v=-1,M=0,b){this._facetIndex=v,this._edgeCount=M,this._detail=b||xr.create()}invalidate(v=!0){this._facetIndex=-1,this._edgeCount=0,v&&this._detail.invalidate()}static create(v,M,b,E){return void 0===E?new Rs(v,M,b):(E.invalidate(!1),E._facetIndex=v,E._edgeCount=M,void 0!==b&&E._detail!==b&&E._detail.copyContentsFrom(b),E)}get facetIndex(){return this._facetIndex}get edgeCount(){return this._edgeCount}get point(){return this._detail.point}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0&&this._edgeCount>=3}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!1}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.code}clone(){const v=new Rs;return v.copyContentsFrom(this),v}copyContentsFrom(v){this._facetIndex=v._facetIndex,this._edgeCount=v._edgeCount,this._detail.copyContentsFrom(v._detail)}getNormal(){}getParam(){}getColor(){}getBarycentricCoordinates(){}}class zs extends Rs{constructor(v=-1,M=0,b){super(v,M,b)}invalidate(v=!0){super.invalidate(v),this._normal=void 0,this._param=void 0,this._color=void 0,this._barycentricCoordinates=void 0}static create(v,M,b,E){return void 0===E?new zs(v,M,b):super.create(v,M,b,E)}get isConvex(){return!0}clone(){const v=new zs;return v.copyContentsFrom(this),v}copyContentsFrom(v){super.copyContentsFrom(v),this._normal=v._normal?.clone(),this._param=v._param?.clone(),this._color=v._color,this._barycentricCoordinates=v._barycentricCoordinates?.slice()}getNormal(v,M,b=K.smallMetricDistance){if(this._detail.isValid&&void 0===this._normal&&void 0!==v){const E=this.getBarycentricCoordinates(M,b);void 0!==E&&(this._normal=$.create(),v.linearCombination(E,this._normal))}return this._normal}getParam(v,M,b=K.smallMetricDistance){if(this._detail.isValid&&void 0===this._param&&void 0!==v){const E=this.getBarycentricCoordinates(M,b);void 0!==E&&(this._param=H.create(),v.linearCombination(E,this._param))}return this._param}getColor(v,M,b=K.smallMetricDistance){if(this._detail.isValid&&void 0===this._color&&void 0!==v){const E=this.getBarycentricCoordinates(M,b);void 0!==E&&(this._color=he.linearCombinationOfColors(v,E))}return this._color}getBarycentricCoordinates(v,M=K.smallMetricDistance){return this._detail.isValid&&void 0===this._barycentricCoordinates&&void 0!==v&&(this._barycentricCoordinates=vr.convexBarycentricCoordinates(v,this._detail.point,M)),this._barycentricCoordinates}}class Ns extends Float64Array{get vertexIndexA(){return this[0]}get vertexIndexB(){return this[1]}get facetIndex(){return this[2]}get isLowHigh(){return this[0]<this[1]}get lowVertexIndex(){return this[0]<this[1]?this[0]:this[1]}get highVertexIndex(){return this[0]>this[1]?this[0]:this[1]}static areDirectedPartners(v,M){return v[0]===M[1]&&v[1]===M[0]}static areUndirectedPartners(v,M){return v[0]===M[0]&&v[1]===M[1]||v[0]===M[1]&&v[1]===M[0]}static relativeOrientation(v,M){return v[0]===M[0]&&v[1]===M[1]?1:v[0]===M[1]&&v[1]===M[0]?-1:0}get isNullEdge(){return this[0]===this[1]}static lessThan(v,M){const b=v.lowVertexIndex,E=M.lowVertexIndex;if(b<E)return-1;if(E<b)return 1;const D=v.highVertexIndex,X=M.highVertexIndex;return D<X?-1:X<D?1:v.vertexIndexA-M.vertexIndexA}constructor(v,M,b){super(3),this[0]=v,this[1]=M,this[2]=b}toJSON(){return[this[0],this[1],this[2]]}static clusterToJSON(v){if(v instanceof Ns)return v.toJSON();const M=[];for(const b of v)M.push(b.toJSON())}static clusterArrayToJSON(v){const M=[];for(const b of v)M.push(Ns.clusterToJSON(b));return M}}class Ys{constructor(){this.edges=[]}addEdge(v,M,b){const E=new Ns(v,M,b);return this.edges.push(E),E}addPath(v,M,b=!0){if(0===v.length)return;const E=v.length-1;for(let D=0;D<E;D++)this.addEdge(v[D],v[D+1],M);b&&this.addEdge(v[E],v[0],M)}sort(){this.edges.sort(((v,M)=>Ns.lessThan(v,M)))}collectSortableEdgeCluster(v,M,b){if(void 0!==b&&M>v)if(M===v+1)b.push(this.edges[v]);else{const E=[];for(let b=v;b<M;b++)E.push(this.edges[b]);b.push(E)}}sortAndCollectClusters(v,M,b,E){this.sort(),v&&(v.length=0),M&&(M.length=0),b&&(b.length=0),E&&(E.length=0);const D=this.edges.length;let X;for(let z=0;z<D;z+=X){const R=this.edges[z];X=1;for(let v=z+1;v<D&&Ns.areUndirectedPartners(R,this.edges[v]);v++)X++;this.edges[z].isNullEdge?this.collectSortableEdgeCluster(z,z+X,b):2===X&&Ns.areDirectedPartners(R,this.edges[z+1])?this.collectSortableEdgeCluster(z,z+X,v):1===X?this.collectSortableEdgeCluster(z,z+1,M):this.collectSortableEdgeCluster(z,z+X,E)}}}class Os{constructor(v){this.numPositive=this.numNegative=0,this.firstEdgeIndex=v}recordOrientation(v){v>0?this.numPositive++:v<0&&this.numNegative++}}class Bs{constructor(v){this._workArray=[],this._visitor=v.createVisitor(1),this._edges=on.createIndexedEdges(this._visitor),this._edgeToPartnerEdge=[],this._edgeToEdgeInComponent=[],this._facetToFirstEdgeInComponent=[],this._facetOrientation=[],this._components=[],this._mesh=v}edgeIdToFacetOrientation(v){const M=this._edges.edges[v].facetIndex;return this._facetOrientation[M]}setupUnoriented(){this._edges.sort();const v=this._edges.edges;let M=-1;const b=this._edges.edges.length;for(let E=0;E<b;E++){const v=this._edges.edges[E].facetIndex;v>M&&(M=v),this._edgeToEdgeInComponent.push(E),this._edgeToPartnerEdge.push(E)}for(let E=0;E<=M;E++)this._facetToFirstEdgeInComponent.push(-1),this._facetOrientation.push(0);for(let E=0;E<b;E++){const v=this._edges.edges[E].facetIndex,M=this._facetToFirstEdgeInComponent[v];-1===M?this._facetToFirstEdgeInComponent[v]=E:Bs.swapEntries(this._edgeToEdgeInComponent,E,M)}for(let E=0;E<b;E++){let M=E+1;for(;M<b&&Ns.areUndirectedPartners(v[E],v[M]);)Bs.swapEntries(this._edgeToPartnerEdge,E,M),M++;if(M>E+2)return!1}return!0}recordFacetInComponent(v,M){const b=this._components[this._components.length-1];this._facetOrientation[v]=M,b.recordOrientation(M)}initializeComponent(v){const M=this._edges.edges[v].facetIndex;this._components.push(new Os(v)),this.recordFacetInComponent(M,1)}pushFacetEdgesOnStack(v,M){Bs.extractCyclicIndices(this._edgeToEdgeInComponent,v,this._workArray);for(const b of this._workArray)M.push(b)}doFlood(){const v=[],M=this._edges.edges,b=M.length,E=[];for(let D=0;D<b;D++)if(0===this.edgeIdToFacetOrientation(D)){let b;for(v.length=0,this.initializeComponent(D),this.pushFacetEdgesOnStack(D,v);void 0!==(b=v.pop());){const D=M[b].facetIndex,X=this._facetOrientation[D];Bs.extractCyclicIndices(this._edgeToPartnerEdge,b,E);for(const z of E)if(z!==b){const E=M[z].facetIndex,D=this._facetOrientation[E];if(0===D){const D=Ns.areDirectedPartners(M[b],M[z])?X:-X;this.recordFacetInComponent(E,D),this.pushFacetEdgesOnStack(z,v),Bs.swapEntries(this._edgeToEdgeInComponent,b,z)}else if(Ns.relativeOrientation(M[b],M[z])*X*D>0)return!1}}}return!0}doFacetReversals(){let v=0;for(this._visitor.reset();this._visitor.moveToNextFacet();){const M=this._visitor.currentReadIndex();this._facetOrientation[M]<0&&(v++,this._mesh.reverseSingleFacet(M))}return v}static doFixup(v){const M=new Bs(v);if(!M.setupUnoriented())return!1;const b=M.doFlood();return b&&M.doFacetReversals(),b}static swapEntries(v,M,b){const E=v[M];v[M]=v[b],v[b]=E}static extractCyclicIndices(v,M,b){b.length=0;let E=M;do{b.push(E),E=v[E]}while(E!==M)}}class Vs{constructor(v,M,b){this.index=v,this.area=M,this.normal=b}addWeightedNormal(v,M){this.area+=v,this.normal.addScaledInPlace(M,v)}divideNormalByArea(){this.normal.scaleInPlace(1/this.area)}}class Ls{constructor(v,M,b){this.facetData=v,this.sectorClusterData=void 0,this.sectorIndex=M,this.vertexIndex=b}static cbSectorSort(v,M){return v.sectorIndex-M.sectorIndex}static cbVertexSort(v,M){return v.vertexIndex-M.vertexIndex}static pushToArray(v,M,b,E){v.push(new Ls(M,b,E))}}class Us{static buildFastAverageNormals(v,M){const b=v.createVisitor(0),E=$.create(0,0,1),D=K.smallMetricDistanceSquared,X=[];let z=0,R=0;for(;b.moveToNextFacet();){const v=vr.areaNormalGo(b.point);let M=v.magnitude();M<D?(v.setFromVector3d(E),M=0):v.scaleInPlace(1/M);const O=new Vs(z++,M,v);for(let E=0;E<b.pointCount;E++)Ls.pushToArray(X,O,R++,b.clientPointIndex(E))}X.sort(((v,M)=>Ls.cbVertexSort(v,M)));const O=[];let Y=M.radians;Y<1e-4&&(Y=1e-4);let N=0;for(let B=0;B<X.length;B++){const v=X[B],M=v.vertexIndex,b=v.facetData;if(void 0===v.sectorClusterData){const E=new Vs(N++,0,$.createZero());O.push(E),E.addWeightedNormal(1,v.facetData.normal.clone());for(let v=B;v<X.length;v++){const D=X[v];if(D.vertexIndex!==M)break;D.facetData.normal.angleTo(b.normal).radians>Y||void 0===D.sectorClusterData&&(E.addWeightedNormal(1,D.facetData.normal),D.sectorClusterData=E)}}}X.sort(((v,M)=>Ls.cbSectorSort(v,M))),v.data.normalIndex=[],v.data.normal=new nt(X.length);for(const B of O)B.divideNormalByArea(),B.index=v.data.normal.length,v.data.normal.push(B.normal);for(const B of X)v.data.normalIndex.push(B.sectorClusterData.index)}static buildPerFaceNormals(v){const M=v.createVisitor(0),b=$.create(0,0,1),E=$.create(0,0,1),D=new nt(v.faceCount),X=[];for(;M.moveToNextFacet();){const v=D.length;vr.unitNormal(M.point,b)?D.push(b):D.push(E);for(let b=0;b<M.pointCount;b++)X.push(v)}v.data.normalIndex=X,v.data.normal=D}}function Zs(v){return void 0!==v&&v}class qs{constructor(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal=$.create(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}clear(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal.setZero(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}accumulateNormal(v,M,b){if(v.isMaskSet(b))this.numInactiveSectors++;else{const b=Zi.sectorSweepRadiansXYZ(v,M);this.averageNormal.addScaledInPlace(M,b),this.radiansSum+=b,this.numActiveSectors++}}finishNormalAveraging(){return!!(this.numActiveSectors>0&&this.averageNormal.normalizeInPlace())}recordDeviation(v,M){if(M){const M=this.averageNormal.radiansTo(v);this.maxDeviationRadiansFromAverage=Math.max(Math.abs(this.maxDeviationRadiansFromAverage),M)}}get maxDeviationRadians(){return this.maxDeviationRadiansFromAverage}}function Ws(v){void 0!==Js.stringDebugFunction&&(Js.stringDebugFunction(`    Sector xyz    ${v.xyz.x},${v.xyz.y},${v.xyz.z} `),Js.stringDebugFunction(`           normal ${v.normal.x},${v.normal.y},${v.normal.z} `))}class Gs{constructor(v,M){this.facetIndex=v,this.facetNormal=M}}class Hs{constructor(v,M){this.xyz=M,this.normal=v,this.count=0}static edgeHasLargeExteriorAngleBetweenNormals(v,M,b,E,D=.5*Math.PI){const X=v.edgeTag,z=v.edgeMate.edgeTag;if(void 0!==X&&void 0!==z){v.vectorToFaceSuccessor(M);const R=X.normal.signedRadiansTo(z.normal,M);if(K.split3WaySign(E,-1,1,1)*R>=D&&($.createAdd2Scaled(X.normal,1,z.normal,1,b),b.normalizeInPlace()))return!0}return!1}static almostEqualNormals(v,M,b=K.smallAngleRadians){return v.normal.radiansTo(M.normal)<=b}static radiansBetweenNormals(v,M){return v.normal.radiansTo(M.normal)}setOffsetPointAtDistanceAtHalfEdge(v,M){v.getPoint3d(this.xyz),this.xyz.addScaledInPlace(this.normal,M)}static setXYZAtHalfEdge(v,M){const b=v.edgeTag;void 0!==b&&void 0!==M&&b.xyz.set(M.x,M.y,M.z)}setXYAndZ(v){this.xyz.set(v.x,v.y,v.z)}static setNormalAtHalfEdge(v,M,b){const E=v.edgeTag;void 0!==E&&(E.normal.set(M.x,M.y,M.z),void 0!==b&&E.setOffsetPointAtDistanceAtHalfEdge(v,b))}static sweepRadiansAroundNormal(v,M){const b=v.edgeTag,E=v.vertexSuccessor.edgeTag;if(void 0!==b&&void 0!==E)return b.normal.planarRadiansTo(E.normal,M)}static getSectorPointAtHalfEdge(v,M,b){const E=v.edgeTag;return void 0!==E&&(void 0!==M&&M.setFromPoint3d(E.xyz),void 0!==b&&b.push(E.xyz),!0)}static pushXYZ(v,M){const b=M.edgeTag;return void 0!==b&&v.push(b.xyz),b}static accumulateScaledNormalAtHalfEdge(v,M,b){const E=v.edgeTag;void 0!==E&&b.addScaledInPlace(E.normal,M)}}class Js{constructor(v,M,b){this._basePolyface=v,this._baseGraph=M,this._breakMaskA=M.grabMask(),this._breakMaskB=M.grabMask(),this._insideOfChamferFace=M.grabMask(),this._outsideOfChamferFace=M.grabMask(),this._insideChamferSling=M.grabMask(),this._outsideEndOfChamferFace=M.grabMask(),this._exteriorMask=Rr.EXTERIOR,this._offsetCoordinatesReassigned=M.grabMask(),this._smoothRadiansBetweenNormals=b.smoothSingleAngleBetweenNormals.radians,this._chamferTurnRadians=b.chamferAngleBetweenNormals.radians,this._smoothAccumulatedRadiansBetweenNormals=b.smoothAccumulatedAngleBetweenNormals.radians}get exteriorMask(){return this._exteriorMask}get breakMaskA(){return this._breakMaskA}get breakMaskB(){return this._breakMaskB}get insideOfChamferFace(){return this._insideOfChamferFace}get outsideOfChamferFace(){return this._outsideOfChamferFace}get insideChamferSling(){return this._insideChamferSling}get outsideEndOfChamferFace(){return this._outsideEndOfChamferFace}applyFaceNormalOffsetsToSectorData(v){this._baseGraph.announceNodes(((M,b)=>{const E=b.edgeTag;return void 0!==E&&E.setOffsetPointAtDistanceAtHalfEdge(b,v),!0}))}static buildOffsetMeshWithEdgeChamfers(v,M,b,E){const D=this.buildBaseGraph(v);if(void 0!==D){const X=new Js(v,D,E);X.applyFaceNormalOffsetsToSectorData(b),void 0!==Js.graphDebugFunction&&Js.graphDebugFunction("BaseGraph",D,X._breakMaskA,X._breakMaskB);const z=E.outputSelector?E.outputSelector:{outputOffsetsFromFaces:!0,outputOffsetsFromEdges:!0,outputOffsetsFromVertices:!0};Zs(z.outputOffsetsFromFacesBeforeChamfers)&&X.announceFacetsWithSectorCoordinatesAroundFaces(M),X.addChamferTopologyToAllEdges(E,b),X.computeOffsetFacetIntersections(b),void 0!==Js.graphDebugFunction&&Js.graphDebugFunction("after computeEdgeChamfers",D,X._breakMaskA,X._breakMaskB),Zs(z.outputOffsetsFromFaces)&&X.announceFacetsWithSectorCoordinatesAroundFaces(M),Zs(z.outputOffsetsFromEdges)&&X.announceFacetsWithSectorCoordinatesAroundEdges(M),Zs(z.outputOffsetsFromVertices)&&X.announceFacetsWithSectorCoordinatesAroundVertices(M)}}announceSimpleOffsetFromFaces(v,M){const b=new nt,E=Q.create(),D=$.create(),r=v=>(v.getPoint3d(E),E.addInPlace(D),b.push(E),0);this._baseGraph.announceFaceLoops(((E,X)=>{if(!X.isMaskSet(Rr.EXTERIOR)){const E=X.faceTag;D.setFromVector3d(E.facetNormal.direction),D.scaleInPlace(M),b.length=0,X.sumAroundFace(r),v.addPolygonGrowableXYZArray(b)}return!0}))}announceFacetsWithSectorCoordinatesAroundFaces(v){const M=new nt,i=v=>{const b=v.edgeTag;return void 0!==b&&M.push(b.xyz),0};this._baseGraph.announceFaceLoops(((b,E)=>(E.isMaskSet(Rr.EXTERIOR)||(M.length=0,E.sumAroundFace(i),M.length>2&&v.addPolygonGrowableXYZArray(M)),!0)))}countBits(v){let M=0,b=v;for(;0!==b;)1&b&&M++,b>>=1;return M}announceFacetsWithSectorCoordinatesAroundEdges(v){const M=new nt,b=K.smallMetricDistance,E=this._exteriorMask|this._outsideEndOfChamferFace|this._outsideOfChamferFace|this._insideOfChamferFace|this._insideChamferSling;this._baseGraph.announceEdges(((D,X)=>{if(void 0!==X.findMaskAroundEdge(this._exteriorMask))return!0;if(X.isMaskSet(E))return!0;{const D=X.faceSuccessor,z=X.edgeMate;if(!z.isMaskSet(E)){const E=z.faceSuccessor;M.clear(),Hs.getSectorPointAtHalfEdge(X,void 0,M),Hs.getSectorPointAtHalfEdge(D,void 0,M),Hs.getSectorPointAtHalfEdge(z,void 0,M),Hs.getSectorPointAtHalfEdge(E,void 0,M),si.compressInPlaceByShortEdgeLength(M,b),M.length>2&&v.addPolygonGrowableXYZArray(M)}}return!0}))}getCoordinateString(v,M=!0,b=!1){return M?b?`${Zi.nodeToIdXYZString(v)} ==> ${Zi.nodeToIdXYZString(v.faceSuccessor)}`:`${Zi.nodeToIdXYZString(v)}`:b?`==> ${Zi.nodeToIdXYZString(v.faceSuccessor)}`:""}inspectMasks(v,M=!0,b=!1){return"[".concat(v.id.toString(),v.isMaskSet(this._exteriorMask)?"X":"",v.isMaskSet(this.breakMaskA)?"A":"",v.isMaskSet(this.breakMaskB)?"B":"",v.isMaskSet(this.insideChamferSling)?"(sling)":"",v.isMaskSet(this.insideOfChamferFace)?"(in chamfer)":"",v.isMaskSet(this.outsideEndOfChamferFace)?"(@sling)":"",v.isMaskSet(this.outsideOfChamferFace)?"(@chamfer)":"",this.getCoordinateString(v,M,b),"]")}announceFacetsWithSectorCoordinatesAroundVertices(v){const M=new nt,b=K.smallMetricDistance;this._baseGraph.announceVertexLoops(((E,D)=>(D.findMaskAroundVertex(this._exteriorMask)||(M.length=0,D.sumAroundVertex((v=>(v.isMaskSet(this._insideChamferSling)||Hs.getSectorPointAtHalfEdge(v,void 0,M),0))),si.compressInPlaceByShortEdgeLength(M,b),M.length>2&&v.addPolygonGrowableXYZArray(M)),!0)))}static buildBaseGraph(v){const M=new ks,b=v.createVisitor(),E=Q.create(),D=Q.create();for(b.reset();b.moveToNextFacet();){const X=vr.centroidAreaNormal(b.point);if(void 0!==X){const z=M.insertLoop(b.pointIndex,(M=>{const b=M.edgeMate;v.data.getPoint(M.i,E),M.setXYZ(E),v.data.getPoint(b.i,D),b.setXYZ(D)})),R=new Gs(b.currentReadIndex(),X);void 0!==z&&z.sumAroundFace((v=>(v.faceTag=R,v.edgeTag=new Hs(X.direction.clone(),v.getPoint3d()),0)))}}return M.graph}setOffsetAtDistanceAroundVertex(v,M,b=!1){v.sumAroundVertex((E=>{const D=E.edgeTag;return void 0!==D&&(b&&this.isInsideChamferOrSling(v)||D.setOffsetPointAtDistanceAtHalfEdge(E,M)),0}))}setOffsetXYAndZAroundVertex(v,M){v.sumAroundVertex((v=>{const b=v.edgeTag;return void 0!==b&&(b.setXYAndZ(M),v.setMask(this._offsetCoordinatesReassigned)),0}))}announceNodeAndSectorPropertiesInSmoothSector(v,M){let b=0;for(let E=v;;E=E.vertexSuccessor){const D=E.edgeTag;if(void 0!==D&&(M(E,D),b++),E.isMaskSet(this._breakMaskB))return b;if(E.isMaskSet(this._exteriorMask))return b;if(E===v&&0===b)return b}}computeAverageNormalAndMaxDeviationAroundVertex(v,M){M.clear();const b=this._exteriorMask|this._insideChamferSling;if(v.sumAroundVertex((v=>{const E=v.edgeTag;return E&&M.accumulateNormal(v,E.normal,b),0})),M.finishNormalAveraging())return v.sumAroundVertex((v=>{const E=v.edgeTag;return E&&M.recordDeviation(E.normal,!v.isMaskSet(b)),0})),M.maxDeviationRadians}assignOffsetByAverageNormalAroundVertex(v,M,b,E){const D=this.computeAverageNormalAndMaxDeviationAroundVertex(v,b);return Js.stringDebugFunction&&(Js.stringDebugFunction(`XYZ ${Zi.nodeToIdXYZString(v)} Average Normal ${b.averageNormal.toJSON()}`),Js.stringDebugFunction(`           angle ratio ${b.radiansSum/(2*Math.PI)}   maxDeviation ${b.maxDeviationRadiansFromAverage}`)),void 0!==D&&D<=M&&(v.sumAroundVertex((v=>(Hs.setNormalAtHalfEdge(v,b.averageNormal,E),0))),!0)}markBreakEdgesAndSaveAverageNormalsAroundVertex(v){v.clearMaskAroundVertex(this._breakMaskA),v.clearMaskAroundVertex(this._breakMaskB);const M=this._smoothRadiansBetweenNormals,b=this._smoothAccumulatedRadiansBetweenNormals;let E=0,D=v,X=0;do{const v=D.edgeMate,b=v.faceSuccessor;D.isMaskSet(this._exteriorMask)?v.isMaskSet(this._exteriorMask)||(b.setMask(this._breakMaskB),E++):D.isMaskSet(this._outsideOfChamferFace)?D.setMask(this._breakMaskA):D.isMaskSet(this._outsideEndOfChamferFace)?(D.setMask(this._breakMaskA),D.setMask(this._breakMaskB)):D.isMaskSet(this._insideChamferSling)||(D.isMaskSet(this._insideOfChamferFace)?(D.setMask(this._breakMaskA),D.setMask(this._breakMaskB),b.setMask(this._breakMaskB)):v.isMaskSet(this._exteriorMask)?(E++,D.setMask(this._breakMaskA)):Hs.almostEqualNormals(D.edgeTag,b.edgeTag,M)?X++:(D.setMask(this._breakMaskA),E++,b.setMask(this._breakMaskB))),D=D.vertexSuccessor}while(D!==v);void 0!==Js.stringDebugFunction&&Js.stringDebugFunction(`   numSkip   ${X} `),0===E&&(v.setMask(this._breakMaskA),v.vertexPredecessor.setMask(this._breakMaskB),E=1);const z=D.findMaskAroundVertex(this._breakMaskA);if(void 0!==z){D=z;do{if(D.isMaskSet(this._breakMaskA)&&!D.isMaskSet(this._breakMaskB)){let v=0;do{const M=D.vertexSuccessor;v+=Hs.radiansBetweenNormals(D.edgeTag,M.edgeTag),v>b&&(D.setMask(this._breakMaskB),M.setMask(this._breakMaskA),E++,v=0),D=M}while(!D.isMaskSet(this._breakMaskB))}else D=D.vertexSuccessor}while(D!==z)}if(E>0&&void 0!==z){D=z;const v=$.create(),M=$.create(),b=$.create();v.setZero();do{if(D.isMaskSet(this._breakMaskA)&&!D.isMaskSet(this._breakMaskB)){let E=D;for(v.setZero();;){E.vectorToFaceSuccessor(M),E.vectorToFacePredecessor(b);let D=M.signedRadiansTo(b,E.faceTag.facetNormal.direction);if(D<0&&(D+=2*Math.PI),Hs.accumulateScaledNormalAtHalfEdge(E,D,v),E.isMaskSet(this._breakMaskB))break;E=E.vertexSuccessor}if(v.normalizeInPlace())for(E=D;Hs.setNormalAtHalfEdge(E,v),!E.isMaskSet(this._breakMaskB);)E=E.vertexSuccessor}D=D.vertexSuccessor}while(D!==z)}}compute3SectorIntersection(v,M,b,E){const D=v.edgeTag,X=M.edgeTag,z=b.edgeTag;return Ft.intersect3Planes(D.xyz,D.normal,X.xyz,X.normal,z.xyz,z.normal,E)}compute3SectorIntersectionDebug(v,M,b,E){const D=v.edgeTag,X=M.edgeTag,z=b.edgeTag;if(void 0!==Js.stringDebugFunction){Js.stringDebugFunction(`compute3${this.inspectMasks(v)}${this.inspectMasks(M)}${this.inspectMasks(b)} `);for(const v of[D,X,z])Ws(v)}const R=Ft.intersect3Planes(D.xyz,D.normal,X.xyz,X.normal,z.xyz,z.normal,E);return void 0!==Js.stringDebugFunction&&(void 0===R?Js.stringDebugFunction(" NO INTERSECTION"):Js.stringDebugFunction(` ComputedVector ${R.x},${R.y},${R.z} `)),R}compute2SectorIntersection(v,M,b){const E=v.edgeTag,D=M.edgeTag,X=E.normal.crossProduct(D.normal);return Ft.intersect3Planes(E.xyz,E.normal,D.xyz,D.normal,D.xyz,X,b)}addChamferTopologyToAllEdges(v,M){const b=[],E=v.chamferAngleBetweenNormals.radians,D=Q.create(),X=$.create(),z=$.create(),R=$.create();this._baseGraph.announceEdges(((v,D)=>!Hs.edgeHasLargeExteriorAngleBetweenNormals(D,X,R,M,E)||(b.push(D),!0)));for(const O of b)if(Hs.edgeHasLargeExteriorAngleBetweenNormals(O,X,R,E)){const v=this._baseGraph.splitEdgeCreateSliverFace(O),b=v.facePredecessor,E=v.getPoint3d();E.addScaledInPlace(R,M);const Y=Mt.createCapture(E,R.clone()),N=new Gs(-1,Y);let B=-1;for(const M of[v,b]){X.scale(B,z),M.getPoint3d(D),M.setMask(this._insideOfChamferFace),M.edgeMate.setMask(this._outsideOfChamferFace),M.faceTag=N;const v=this._baseGraph.splitEdge(void 0,D.x,D.y,D.z,M.i),b=v.edgeMate;v.setMask(this._outsideEndOfChamferFace),v.faceTag=N,b.setMask(this._insideChamferSling),Zi.pinch(M,v);const O=Mt.create(D,z),Y=new Gs(-1,O);b.faceTag=Y,M.edgeTag=new Hs(R.clone(),E.clone()),v.edgeTag=new Hs(R.clone(),E.clone()),b.edgeTag=new Hs(z.clone(),D.clone());const V=this.compute3SectorIntersection(M,M.edgeMate,b),L=this.compute3SectorIntersection(v,v.vertexSuccessor,b);Hs.setXYZAtHalfEdge(M,V),Hs.setXYZAtHalfEdge(v,L),B*=-1}}}computeOffsetFacetIntersections(v){void 0!==Js.stringDebugFunction&&Js.stringDebugFunction("*****                                 recompute intersections");const M=[],b=Q.create(),E=Q.create(),D=2*v,X=new qs,z=W.degreesToRadians(25);this._baseGraph.announceVertexLoops(((R,O)=>{let Y=O.findMaskAroundVertex(this._outsideEndOfChamferFace);if(void 0===Y&&(Y=O.findMaskAroundVertex(this._breakMaskA)),void 0===Y&&(Y=O),void 0!==Js.stringDebugFunction&&(Js.stringDebugFunction(""),Js.stringDebugFunction(` VERTEX LOOP   ${Y.getPoint3d().toJSON()} `),Y.sumAroundVertex((v=>(Js.stringDebugFunction(this.inspectMasks(v,!1,!0)),0)))),this.assignOffsetByAverageNormalAroundVertex(Y,z,X,v))return!0;if(this.markBreakEdgesAndSaveAverageNormalsAroundVertex(Y),this.setOffsetAtDistanceAroundVertex(Y,v,!0),Y.collectMaskedEdgesAroundVertex(this._breakMaskA,!0,M),void 0!==Js.stringDebugFunction){Js.stringDebugFunction(` BREAK EDGES from ${this.inspectMasks(Y,!0,!1)}`);for(const v of M)Js.stringDebugFunction(this.inspectMasks(v,!1,!0))}if(M.length<=1);else if(2===M.length){const v=this.compute2SectorIntersection(M[0],M[1]);void 0!==v&&this.setOffsetXYAndZAroundVertex(Y,v)}else if(3===M.length){void 0!==Js.stringDebugFunction&&Js.stringDebugFunction(` Vertex Update just ${M.length} `);const v=this.compute3SectorIntersection(M[0],M[1],M[2]);void 0!==v&&this.setOffsetXYAndZAroundVertex(Y,v)}else{void 0!==Js.stringDebugFunction&&Js.stringDebugFunction(` Vertex Update breakEdges ${M.length} `),Y.getPoint3d(b);for(let v=0;v<M.length;v++){const b=v,E=(b+1)%M.length,D=(E+1)%M.length;if(M[b].isMaskSet(this._outsideEndOfChamferFace)&&M[E].isMaskSet(this._outsideOfChamferFace)&&M[D].isMaskSet(this._insideOfChamferFace)){void 0!==Js.stringDebugFunction&&Js.stringDebugFunction(`    ChamferChamfer Fixup ${this.inspectMasks(M[b])} ${this.inspectMasks(M[E])} ${this.inspectMasks(M[D])} `);const X=this.compute3SectorIntersection(M[b],M[E],M[D]);if(void 0!==X){for(const v of[b,E,D])this.announceNodeAndSectorPropertiesInSmoothSector(M[v],((v,M)=>{M.setXYAndZ(X),v.setMask(this._offsetCoordinatesReassigned)}));v+=2}}}for(let v=0;v<M.length;v++){const b=v,D=(b+1)%M.length;this.isInsideSling(M[b],M[D])||(!this.isOffsetAssigned(M[b])&&M[D].isMaskSet(this.insideOfChamferFace)?this.transferXYZFromNodeToSmoothSector(M[D],M[b],"push left from chamfer",E):!this.isOffsetAssigned(M[D])&&M[b].isMaskSet(this.outsideEndOfChamferFace)&&this.transferXYZFromNodeToSmoothSector(M[b],M[D],"push right from chamfer",E))}for(let v=0;v<M.length;v++){const E=v,X=(E+1)%M.length,z=(X+1)%M.length;if(this.isInsideSling(M[E],M[X],M[z]))continue;if(this.isOffsetAssigned(M[X]))continue;void 0!==Js.stringDebugFunction&&Js.stringDebugFunction(`    Intersection Fixup ${this.inspectMasks(M[E])} ${this.inspectMasks(M[X])} ${this.inspectMasks(M[z])} `);const R=this.compute3SectorIntersection(M[E],M[X],M[z]);void 0!==R&&b.distance(R)<D&&this.announceNodeAndSectorPropertiesInSmoothSector(M[X],((v,M)=>{M.setXYAndZ(R),v.setMask(this._offsetCoordinatesReassigned)}))}}if(void 0!==Js.stringDebugFunction){const v=Y.countMaskAroundVertex(this._offsetCoordinatesReassigned,!1),M=`   **** Vertex offset mask counts(TRUE ${Y.countMaskAroundVertex(this._offsetCoordinatesReassigned,!0)})(FALSE ${v})`;Js.stringDebugFunction(M)}return!0}))}isInsideSling(v,M,b){return v.isMaskSet(this._insideChamferSling)||void 0!==M&&M.isMaskSet(this._insideChamferSling)||void 0!==b&&b.isMaskSet(this._insideChamferSling)}isInsideChamferOrSling(v){return v.isMaskSet(this._insideChamferSling)||v.isMaskSet(this._insideOfChamferFace)||v.isMaskSet(this._outsideEndOfChamferFace)}isOffsetAssigned(v,M,b){return v.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==M&&M.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==b&&b.isMaskSet(this._offsetCoordinatesReassigned)}transferXYZFromNodeToSmoothSector(v,M,b,E){void 0!==Js.stringDebugFunction&&Js.stringDebugFunction(`    ${b} ${this.inspectMasks(v)} to ${this.inspectMasks(M)}} `),Hs.getSectorPointAtHalfEdge(v,E,void 0),this.announceNodeAndSectorPropertiesInSmoothSector(M,((v,M)=>{M.setXYAndZ(E),v.setMask(this._offsetCoordinatesReassigned)}))}}class Ks{constructor(v){this._segmentPoint0=Q.create(),this._segmentPoint1=Q.create(),this._localSegmentPoint0=Q.create(),this._localSegmentPoint1=Q.create(),this._clipFractions=We.create(0,1),this._localFrame=pt.createIdentity(),this._polygonRange=ut.create(),this._spacePoints=v,this._spacePointsRange=new ut,v.setRange(this._spacePointsRange),this._numSpacePoints=this._spacePoints.length}static create(v){if(v.length>1)return new Ks(v.clone())}projectToPolygon(v,M,b,E){v.setRange(this._polygonRange);let D=0;if(!this._polygonRange.intersectsRangeXY(this._spacePointsRange))return D;for(let X=1;X+1<v.length;X++){D++;const z=v.fillLocalXYTriangleFrame(0,X,X+1,this._localFrame);if(z)for(let v=1;v<this._numSpacePoints;v++)if(D++,this._spacePoints.getPoint3dAtCheckedPointIndex(v-1,this._segmentPoint0),this._spacePoints.getPoint3dAtCheckedPointIndex(v,this._segmentPoint1),z.multiplyInversePoint3d(this._segmentPoint0,this._localSegmentPoint0),z.multiplyInversePoint3d(this._segmentPoint1,this._localSegmentPoint1),this._clipFractions.set(0,1),this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.x,this._localSegmentPoint1.x)&&this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.y,this._localSegmentPoint1.y)&&this._clipFractions.clipBy01FunctionValuesPositive(1-this._localSegmentPoint0.x-this._localSegmentPoint0.y,1-this._localSegmentPoint1.x-this._localSegmentPoint1.y)){D++;const X=this._localSegmentPoint0.interpolate(this._clipFractions.x0,this._localSegmentPoint1),z=this._localSegmentPoint0.interpolate(this._clipFractions.x1,this._localSegmentPoint1),R=this._localFrame.multiplyPoint3d(X),O=this._localFrame.multiplyPoint3d(z),Y=this._localFrame.multiplyXYZ(X.x,X.y,0),N=this._localFrame.multiplyXYZ(z.x,z.y,0),B=K.inverseInterpolate01(this._localSegmentPoint0.z,this._localSegmentPoint1.z);if(void 0!==B&&B>this._clipFractions.x0&&B<this._clipFractions.x1){D++;const X=this._segmentPoint0.interpolate(B,this._segmentPoint1),z=X.clone();M(this._spacePoints,v-1,b,E,[R,X,Y],2,1),M(this._spacePoints,v-1,b,E,[O,z,N],1,2)}else this._localSegmentPoint0.z>0?M(this._spacePoints,v-1,b,E,[R,O,N,Y],3,2):M(this._spacePoints,v-1,b,E,[O,R,Y,N],2,3)}}return D}}class js{constructor(v,M){this.edgePlane=v,this.clip=M,this._crossingPoints=[]}static createPointPointSweep(v,M,b){const E=$.createStartEnd(v,M),D=E.fractionOfProjectionToVector(b),X=E.plusScaled(b,-D),z=Ar.createNormalAndPoint(X,v),R=Ar.createNormalAndPoint(X,M),O=Ar.createOriginAndVectors(v,E,b);if(void 0!==z&&void 0!==R&&void 0!==O){R.negateInPlace();const v=an.createPlanes([z,R]);return new js(O,v)}}processPolygon(v,M){this._crossingPoints.length=0,Array.isArray(v)?Ir.polygonPlaneCrossings(this.edgePlane,v,this._crossingPoints):Pr.polygonPlaneCrossings(this.edgePlane,v,this._crossingPoints),2===this._crossingPoints.length&&this.clip.announceClippedSegmentIntervals(0,1,this._crossingPoints[0],this._crossingPoints[1],((v,b)=>{M(this._crossingPoints[0].interpolate(v,this._crossingPoints[1]),this._crossingPoints[0].interpolate(b,this._crossingPoints[1]))}))}}class Qs{constructor(v,M){this._edgeClippers=v,void 0!==M&&(this._localToWorld=M.localToWorld,this._worldToLocal=M.worldToLocal,this._localRange=M.localRange)}static create(v,M){if(void 0===M&&(M=$.create(0,0,1)),v.length>1){const b=Q.createZero(),E=Q.createZero(),D=[];v.getPoint3dAtUncheckedPointIndex(0,b);let X=xt.createRigidHeadsUp(M);void 0===X&&(X=xt.createIdentity());const z=pt.createOriginAndMatrix(b,X),R=z.inverse(),O=v.getRange(R);for(let Y=1;Y<v.length;Y++){v.getPoint3dAtUncheckedPointIndex(Y,E);const X=js.createPointPointSweep(b,E,M);void 0!==X&&(b.setFrom(E),D.push(X))}return new Qs(D,{localToWorld:z,worldToLocal:R,localRange:O})}}processPolygon(v,M){if(void 0===this._worldToLocal||void 0===this._localRange||ut.createTransformedArray(this._worldToLocal,v).intersectsRangeXY(this._localRange))for(const b of this._edgeClippers)b.processPolygon(v,M)}}class $s{constructor(v,M,b){this._range=v,this._numXEdge=Math.max(M,1),this._numYEdge=Math.max(b,1),this._data=[];for(let E=0;E<b;E++){const v=[];for(let b=0;b<M;b++)v.push(void 0);this._data.push(v)}}get numXEdge(){return this._numXEdge}get numYEdge(){return this._numYEdge}xIndex(v){const M=(v-this._range.low.x)/(this._range.high.x-this._range.low.x),b=Math.floor(M*this._numXEdge);return b<0?0:b>this._numXEdge-1?this._numXEdge-1:b}yIndex(v){const M=(v-this._range.low.y)/(this._range.high.y-this._range.low.y),b=Math.floor(M*this._numYEdge);return b<0?0:b>this._numYEdge-1?this._numYEdge-1:b}static createWithEstimatedCounts(v,M,b){if(v.low.x>=v.high.x||v.low.y>=v.high.y)return;const E=gt.createXYXY(v.low.x,v.low.y,v.high.x,v.high.y),D=E.xLength(),X=E.yLength();let z,R;return X>D?(R=Math.ceil(Math.sqrt(X*M/(b*D))),z=Math.ceil(M/R)):(z=Math.ceil(Math.sqrt(D*M/(b*X))),R=Math.ceil(M/(z*b))),new $s(E,z,R)}addDataAtXY(v,M,b){const E=this.xIndex(v),D=this.yIndex(M);let X=this._data[D][E];X||(X=[],this._data[D][E]=X),X.push(b)}getDataAtXY(v,M){const b=this.xIndex(v),E=this.yIndex(M);return this._data[E][b]}getDataAtIndex(v,M){if(!(v<0||v>=this._numXEdge||M<0||M>=this._numYEdge))return this._data[M][v]}isValidIndex(v,M){return!(v<0||v>=this._numXEdge||M<0||M>=this._numYEdge)}}class tn{get indexGrid(){return this._buckets}constructor(v,M){this._points=v,this._buckets=M}static create(v,M){const b=v.length;if(v.length<1)return;const E=v.getRange();E.expandInPlace(1e3*K.smallMetricDistance);const D=$s.createWithEstimatedCounts(E,v.length,M);if(void 0===D)return;const X=new tn(v,D),z=Q.create();for(let R=0;R<b;R++)v.getPoint3dAtUncheckedPointIndex(R,z),D.addDataAtXY(z.x,z.y,R);return X}announcePointsInRange(v,M){const b=this._buckets.xIndex(v.low.x),E=this._buckets.xIndex(v.high.x),D=this._buckets.yIndex(v.low.y),X=this._buckets.yIndex(v.high.y),z=this._points.length;for(let R=b;R<=E;R++)for(let b=D;b<=X;b++){const E=this._buckets.getDataAtIndex(R,b);if(void 0!==E)for(const b of E)if(b<z){const E=this._points.getXAtUncheckedPointIndex(b),D=this._points.getYAtUncheckedPointIndex(b),X=this._points.getZAtUncheckedPointIndex(b);if(v.containsXY(E,D)&&!M(b,E,D,X))return}}}}class en{constructor(v=0){this._minMax=ft.createNull(),this._count=this._sumX=this._sumXX=0,this._origin=v}get count(){return this._count}get mean(){return this._count>0?this._sumX/this._count:0}get meanSquare(){return this._count>0?this._sumXX/this._count:0}get minMax(){return this._minMax.clone()}get standardDeviation(){if(this._count<1)return 0;const v=this.mean,M=this._sumXX,b=this._sumX;return Math.sqrt((M-2*v*b+this._count*v*v)/this._count)}clearSums(){this._count=this._sumX=this._sumXX=0,this._minMax.setNull()}get origin(){return this._origin}setOrigin(v){this._origin=v}shiftOriginAndSums(v){const M=v-this._origin;this._origin=v,this._sumXX=this._sumXX-2*M*this._sumX+this._count*M*M,this._sumX=this._sumX-this._count*M,this._minMax.cloneTranslated(-M,this._minMax)}accumulate(v){v-=this._origin,this._count+=1,this._sumX+=v,this._sumXX+=v*v,this._minMax.extendX(v)}accumulateArray(v){for(const M of v)this.accumulate(M)}clone(v){return v||(v=new en),this._minMax.clone(v._minMax),v._count=this._count,v._origin=this._origin,v._sumX=this._sumX,v._sumXX=this._sumXX,v}isAlmostEqual(v){return K.isAlmostEqualNumber(this._sumX,v._sumX)&&K.isAlmostEqualNumber(this._sumXX,v._sumXX)&&K.isAlmostEqualNumber(this._origin,v._origin)&&this._count===v._count&&this._minMax.isAlmostEqual(v._minMax)}}class sn{constructor(){this.range=ut.createNull(),this.xSums=new en,this.ySums=new en,this.zSums=new en,this._workRange=ut.createNull()}accumulateGrowableXYZArrayRange(v){v.setRange(this._workRange),this.range.extendRange(this._workRange),this.xSums.accumulate(this._workRange.xLength()),this.ySums.accumulate(this._workRange.yLength()),this.zSums.accumulate(this._workRange.zLength())}}class nn{constructor(v,M,b,E,D,X){this.vectorToEye=v,this.sideAngle=M,this.assembleChains=b,this.collectOnForwardFacets=E,this.collectOnSideFacets=D,this.collectOnRearFacets=X}static create(v,M,b,E,D,X){return new nn(void 0===v?$.unitZ():v.clone(),void 0===M?W.createRadians(K.smallAngleRadians):M.clone(),K.resolveValue(b,!0),K.resolveValue(E,!0),K.resolveValue(D,!0),K.resolveValue(X,!0))}get collectAll(){return!0===this.collectOnForwardFacets&&!0===this.collectOnRearFacets&&!0===this.collectOnRearFacets}collectFromThisFacetNormal(v){return void 0!==v&&(v.angleFromPerpendicular(this.vectorToEye).isMagnitudeLessThanOrEqual(this.sideAngle)?this.collectOnSideFacets:v.dotProduct(this.vectorToEye)>0?this.collectOnForwardFacets:this.collectOnRearFacets)}}class rn{constructor(v=W.createDegrees(25),M=W.createDegrees(60),b=W.createDegrees(90)){this.smoothSingleAngleBetweenNormals=v.clone(),this.smoothAccumulatedAngleBetweenNormals=M.clone(),this.chamferAngleBetweenNormals=b.clone()}static create(v=W.createDegrees(25),M=W.createDegrees(60),b=W.createDegrees(120)){const E=v.clone(),D=M.clone(),X=b.clone();return E.degrees<1&&D.setDegrees(1),D.degrees<1&&D.setDegrees(1),D.degrees<15&&D.setDegrees(15),new rn(E,D,X)}}!function(v){v[v.SelectNone=0]="SelectNone",v[v.SelectAny=1]="SelectAny",v[v.SelectAll=2]="SelectAll",v[v.SelectOneByParity=3]="SelectOneByParity"}(eo||(eo={}));class on{static visitorToLoop(v){const M=ke.createPoints(v.point.getPoint3dArray());return Oe.create(M)}static indexedPolyfaceToLoops(v){const M=Ye.create(),b=v.createVisitor(1);for(;b.moveToNextFacet();){const v=on.visitorToLoop(b);M.tryAddChild(v)}return M}static sumFacetAreas(v,M){let b=0;if(void 0!==v){if(v instanceof wi)return on.sumFacetAreas(v.createVisitor(1),M);let E;for(void 0!==M&&(E=M.normalize()),v.reset();v.moveToNextFacet();){const M=vr.areaNormal(v.point.getPoint3dArray());b+=E?M.dotProduct(E):M.magnitude()}}return b}static sumTetrahedralVolumes(v,M){let b=0;if(v instanceof wi)return on.sumTetrahedralVolumes(v.createVisitor(0),M);let E=M;const D=Q.create(),X=Q.create(),z=Q.create();for(v.reset();v.moveToNextFacet();){void 0===E&&(E=v.point.getPoint3dAtUncheckedPointIndex(0)),v.point.getPoint3dAtUncheckedPointIndex(0,D);for(let M=1;M+1<v.point.length;M++)v.point.getPoint3dAtUncheckedPointIndex(M,X),v.point.getPoint3dAtUncheckedPointIndex(M+1,z),b+=E.tripleProductToPoints(D,X,z)}return b/6}static sumVolumeBetweenFacetsAndPlane(v,M){if(v instanceof wi)return on.sumVolumeBetweenFacetsAndPlane(v.createVisitor(0),M);const b=Q.create(),E=Q.create(),D=Q.create(),X=$.create(),z=M.getNormalRef();let R,O,Y,N,B,V=0;const L=ni.create(void 0,!0),U=ni.create(void 0,!0),Sr=Xt.createZero(),Cr=M.getProjectionToPlane();for(v.reset();v.moveToNextFacet();){v.point.getPoint3dAtUncheckedPointIndex(0,b),R=M.altitude(b),B=0;for(let L=1;L+1<v.point.length;L++)v.point.getPoint3dAtUncheckedPointIndex(L,E),v.point.getPoint3dAtUncheckedPointIndex(L+1,D),b.crossProductToPoints(E,D,X),O=M.altitude(E),Y=M.altitude(D),N=z.dotProduct(X),B+=N,V+=N*(R+O+Y);Sr.setZero(),v.point.multiplyTransformInPlace(Cr),vr.addSecondMomentAreaProducts(v.point,b,Sr),B>0?L.accumulateProductsFromOrigin(b,Sr,1):U.accumulateProductsFromOrigin(b,Sr,1)}return L.shiftOriginAndSumsToCentroidOfSums(),U.shiftOriginAndSumsToCentroidOfSums(),{volume:V/6,positiveProjectedFacetAreaMoments:ni.inertiaProductsToPrincipalAxes(L.origin,L.sums),negativeProjectedFacetAreaMoments:ni.inertiaProductsToPrincipalAxes(U.origin,U.sums)}}static sumFacetSecondAreaMomentProducts(v,M){if(v instanceof wi)return on.sumFacetSecondAreaMomentProducts(v.createVisitor(0),M);const b=Xt.createZero();for(v.reset();v.moveToNextFacet();)vr.addSecondMomentAreaProducts(v.point,M,b);return b}static sumFacetSecondVolumeMomentProducts(v,M){if(v instanceof wi)return on.sumFacetSecondVolumeMomentProducts(v.createVisitor(0),M);const b=Xt.createZero();for(v.reset();v.moveToNextFacet();)vr.addSecondMomentVolumeProducts(v.point,M,b);return b}static computePrincipalAreaMoments(v){const M=v.data.getPoint(0);if(!M)return;const b=on.sumFacetSecondAreaMomentProducts(v,M);return ni.inertiaProductsToPrincipalAxes(M,b)}static computePrincipalVolumeMoments(v){const M=v.data.getPoint(0);if(!M)return;const b=on.sumFacetSecondVolumeMomentProducts(v,M);return ni.inertiaProductsToPrincipalAxes(M,b)}static isConvexByDihedralAngleCount(v,M=!1){return this.dihedralAngleSummary(v,M)>0}static dihedralAngleSummary(v,M=!1){const b=new Ys,E=v.createVisitor(1);E.reset();const D=[];let X=0;for(;E.moveToNextFacet();){const v=E.pointCount-1,M=vr.centroidAreaNormal(E.point);if(void 0===M)return 0;D.push(M);for(let D=0;D<v;D++)b.addEdge(E.clientPointIndex(D),E.clientPointIndex(D+1),X);X++}const z=[],R=[];if(b.sortAndCollectClusters(R,M?void 0:z,void 0,z),z.length>0)return 0;let O=0,Y=0,N=0;const B=$.create();for(const V of R){const M=V[0],b=V[1];if(M instanceof Ns&&b instanceof Ns&&v.data.point.vectorIndexIndex(M.vertexIndexA,M.vertexIndexB,B)){const v=D[M.facetIndex].direction.signedAngleTo(D[b.facetIndex].direction,B);v.isAlmostZero?Y++:v.radians>0?O++:N++}}return O>0&&0===N?1:N>0&&0===O?-1:Y>0&&0===O&&0===N?1:0}static isPolyfaceClosedByEdgePairing(v){return this.isPolyfaceManifold(v,!1)}static isPolyfaceManifold(v,M=!1){const b=new Ys,E=v.createVisitor(1);for(E.reset();E.moveToNextFacet();){const v=E.pointCount-1;for(let M=0;M<v;M++)b.addEdge(E.clientPointIndex(M),E.clientPointIndex(M+1),E.currentReadIndex())}const D=[];return b.sortAndCollectClusters(void 0,M?void 0:D,void 0,D),0===D.length}static boundaryEdges(v,M=!0,b=!0,E=!0){const D=new Ye;if(on.announceBoundaryEdges(v,((v,M,b,E,X)=>{D.tryAddChild(we.create(v,M))}),M,b,E),0!==D.children.length)return D}static collectBoundaryEdges(v,M=!0,b=!0,E=!0){const D=new Ri(K.smallMetricDistance,K.smallMetricDistance);return on.announceBoundaryEdges(v,((v,M)=>D.captureCurve(we.create(v,M))),M,b,E),D.grabResult(!0)}static announceBoundaryEdges(v,M,b=!0,E=!0,D=!0){if(void 0===v)return;const X=new Ys,z=v instanceof wi?v.createVisitor(1):v;for(z.setNumWrap(1),z.reset();z.moveToNextFacet();){const v=z.pointCount-1;for(let M=0;M<v;M++)X.addEdge(z.clientPointIndex(M),z.clientPointIndex(M+1),z.currentReadIndex())}const R=[],O=[],Y=[];X.sortAndCollectClusters(void 0,R,Y,O);const N=[];if(b&&R.length>0&&N.push(R),E&&O.length>0&&N.push(O),D&&Y.length>0&&N.push(Y),0===N.length)return;const B=z.clientPolyface(),V=Q.create(),L=Q.create();for(const U of N)for(const v of U){const b=v instanceof Ns?v:v[0],E=b.vertexIndexA,D=b.vertexIndexB;B.data.getPoint(E,V)&&B.data.getPoint(D,L)&&M(V,L,E,D,b.facetIndex)}}static announceSilhouetteEdges(v,M,b,E=W.createSmallAngle()){if(v instanceof wi)return this.announceSilhouetteEdges(v.createVisitor(1),M,b,E);const D=v.clientPolyface();if(void 0===D)return;v.setNumWrap(1);const X=[];this.createIndexedEdges(v).sortAndCollectClusters(X);const z=E.radians<0?-E.radians:E.radians,R=Q.create(),O=Q.create(),Y=$.create(),l=M=>{if(!on.computeFacetUnitNormal(v,M,Y))return{isSideFace:!1,perpAngle:0};const E=Y.radiansFromPerpendicular(b);return{isSideFace:Math.abs(E)<=z,perpAngle:E}};for(const N of X){if(!Array.isArray(N)||2!==N.length)continue;const v=N[0].vertexIndexA,b=N[0].vertexIndexB;if(!D.data.getPoint(v,R)||!D.data.getPoint(b,O))continue;const E=l(N[0].facetIndex);if(E.isSideFace){M(R,O,v,b,N[0].facetIndex);continue}const X=l(N[1].facetIndex);X.isSideFace?M(O,R,b,v,N[1].facetIndex):E.perpAngle*X.perpAngle<0&&M(R,O,v,b,N[0].facetIndex)}}static collectSilhouetteEdges(v,M,b=W.createSmallAngle()){const E=new Ri(K.smallMetricDistance,K.smallMetricDistance);return on.announceSilhouetteEdges(v,((v,M)=>E.captureCurve(we.create(v,M))),M,b),E.grabResult(!0)}static announceSweepLinestringToConvexPolyfaceXY(v,M,b){const E=Ks.create(v);if(E){const v=M.createVisitor(0);for(v.reset();v.moveToNextFacet();)E.projectToPolygon(v.point,b,M,v.currentReadIndex())}}static async continueAnnounceSweepLinestringToConvexPolyfaceXY(v,M,b){let E=0;for(;E<this.asyncWorkLimit&&M.moveToNextFacet();)E+=v.projectToPolygon(M.point,b,M.clientPolyface(),M.currentReadIndex());return E}static setAsyncWorkLimit(v){const M=this._asyncWorkLimit;return this._asyncWorkLimit=v,M}static get asyncWorkLimit(){return this._asyncWorkLimit}static async asyncAnnounceSweepLinestringToConvexPolyfaceXY(v,M,b){const E=Ks.create(v);this.awaitBlockCount=0;let D=0;if(E){const v=M.createVisitor(0);let X;for(;0<(X=await Promise.resolve(on.continueAnnounceSweepLinestringToConvexPolyfaceXY(E,v,b)));)D+=X,this.awaitBlockCount++}return D}static partitionFacetIndicesByVertexConnectedComponent(v){if(v instanceof wi)return this.partitionFacetIndicesByVertexConnectedComponent(v.createVisitor(0));const M=new Li(this.visitorClientPointCount(v));for(v.reset();v.moveToNextFacet();){const b=v.pointIndex[0];for(const E of v.pointIndex)M.mergeSubsets(b,E)}const b=M.collectRootIndices(),E=[],D=b.length;for(let X=0;X<D;X++)E.push([]);for(v.reset();v.moveToNextFacet();){const X=v.pointIndex[0],z=M.findRoot(X);for(let M=0;M<D;M++)if(b[M]===z){E[M].push(v.currentReadIndex());break}}return E}static partitionFacetIndicesByVisibilityVector(v,M,b){if(v instanceof wi)return this.partitionFacetIndicesByVisibilityVector(v.createVisitor(0),M,b);const E=[];for(let O=0;O<3;O++)E.push([]);const D=E[0],X=E[1],z=E[2],R=Math.max(b.radians,1e-8);for(v.reset();v.moveToNextFacet();){const b=vr.areaNormalGo(v.point),E=v.currentReadIndex();if(b){const v=b.angleFromPerpendicular(M);Math.abs(v.radians)<R?z.push(E):b.dotProduct(M)<0?X.push(E):D.push(E)}}return E}static boundaryOfVisibleSubset(v,M,b,E=W.createDegrees(.001)){const D=this.partitionFacetIndicesByVisibilityVector(v,b,E);if(0===D[M].length)return;const X=Ai.createSubsetVisitor(v,D[M],1);return this.boundaryEdges(X,!0,!1,!1)}static announceBoundaryChainsAsLineString3d(v,M){const b=new Ri(K.smallMetricDistance,1e3);on.announceBoundaryEdges(v,((v,M,E,D)=>b.captureCurve(we.create(v,M))),!0,!1,!1),b.announceChainsAsLineString3d(M)}static cloneWithMaximalPlanarFacets(v,M){if(v instanceof wi)return this.cloneWithMaximalPlanarFacets(v.createVisitor(0),M);const b=on.visitorClientFacetCount(v),E=on.collectEdgesByDihedralAngle(v,M),D=on.partitionFacetIndicesBySortableEdgeClusters(E,b),X=On.create(),z=v,R=[];for(const Y of D)1===Y.length?z.moveToReadIndex(Y[0])&&X.addFacetFromVisitor(z):R.push(Y);const O=on.clonePartitions(v,R);for(const Y of O){const v=[],M=[];on.announceBoundaryEdges(Y,((b,E,D,X)=>{v.push(we.create(b,E)),M.push([b.clone(),E.clone()])}));const b=Oi.collectChains(v,1e-4,1e-4);if(b){const v=new ei;v.announce(b);const E=v.getValidatedFrame(!1);if(void 0!==E){const v=E.inverse();if(void 0!==v){v.multiplyPoint3dArrayArrayInPlace(M);const b=Cs.formGraphFromChains(M,!0,Rr.BOUNDARY_EDGE);if(b){Es.collectConnectedComponentsWithExteriorParityMasks(b,new bs(Rr.BOUNDARY_EDGE),Rr.EXTERIOR);const v=On.graphToPolyface(b);X.addIndexedPolyface(v,!1,E)}}}}}return X.claimPolyface(!0)}static fillSimpleHoles(v,M,b){if(v instanceof wi)return this.fillSimpleHoles(v.createVisitor(0),M,b);const E=On.create(),D=[];on.announceBoundaryChainsAsLineString3d(v,(v=>{v.reverseInPlace(),D.push(v)}));for(const X of D){const v=X.points;let D=!1;X.isPhysicallyClosed?(void 0!==M.maxEdgesAroundHole&&v.length>M.maxEdgesAroundHole||void 0!==M.maxPerimeter&&de.sumEdgeLengths(v,!1)>M.maxPerimeter||void 0!==M.upVector&&vr.sumTriangleAreasPerpendicularToUpVector(v,M.upVector)<=0)&&(D=!0):D=!0,!D&&Ds.triangulateSimplestSpaceLoop(v,((v,M)=>{for(const b of M)E.addPolygon(b)}))||(D=!0),D&&void 0!==b&&b.push(X)}if(void 0!==M.includeOriginalMesh&&M.includeOriginalMesh)for(v.reset();v.moveToNextFacet();)E.addFacetFromVisitor(v);return E.claimPolyface(!0)}static clonePartitions(v,M){if(v instanceof wi)return this.clonePartitions(v.createVisitor(0),M);v.setNumWrap(0);const b=[],E=Ie.createForFacets();E.needNormals=void 0!==v.normal,E.needParams=void 0!==v.param,E.needColors=void 0!==v.color,E.needTwoSided=v.twoSided;for(const D of M){const M=On.create(E);v.reset();for(const b of D)v.moveToReadIndex(b),M.addFacetFromVisitor(v);b.push(M.claimPolyface(!0))}return b}static cloneFiltered(v,M){if(v instanceof wi)return this.cloneFiltered(v.createVisitor(0),M);v.setNumWrap(0);const b=Ie.createForFacets();b.needNormals=void 0!==v.normal,b.needParams=void 0!==v.param,b.needColors=void 0!==v.color,b.needTwoSided=v.twoSided;const E=On.create(b);for(v.reset();v.moveToNextFacet();)M(v)&&E.addFacetFromVisitor(v);return E.claimPolyface(!0)}static cloneWithDanglingEdgesRemoved(v){if(v instanceof wi)return this.cloneWithDanglingEdgesRemoved(v.createVisitor(0));const M=Ie.createForFacets();M.needNormals=void 0!==v.normal,M.needParams=void 0!==v.param,M.needColors=void 0!==v.color,M.needTwoSided=v.twoSided;const b=On.create(M),s=(v,M)=>{const b=v.length;for(let E=0;E<b;++E){let D=1,X=E,z=E;for(;D+2<=b;){const E=0===X?b-1:X-1,R=z===b-1?0:z+1;if(M[v[E]]!==M[v[R]])break;X=E,z=R,D+=2}if(D>1)return X<z?v.splice(X,D-1):X>z&&(v.splice(X),v.splice(0,z)),!0}return!1};for(v.setNumWrap(0),v.reset();v.moveToNextFacet();){const M=[...Array(v.pointIndex.length).keys()];for(;s(M,v.pointIndex););b.addFacetFromIndexedVisitor(v,M)}return b.claimPolyface(!0)}static visitorClientPointCount(v){const M=v.clientPolyface();if(void 0!==M)return M.data.point.length;v.reset();let b=-1;for(;v.moveToNextFacet();)for(const M of v.pointIndex)M>b&&(b=M);return b+1}static visitorClientFacetCount(v){const M=v.clientPolyface();if(void 0!==M&&void 0!==M.facetCount)return M.facetCount;let b=0;for(v.reset();v.moveToNextFacet();)++b;return b}static partitionFacetIndicesBySortableEdgeClusters(v,M){const b=new Li(M);for(const z of v)if(z instanceof Ns);else{const v=z[0];for(let M=1;M<z.length;M++)b.mergeSubsets(v.facetIndex,z[M].facetIndex)}const E=b.collectRootIndices(),D=[],X=E.length;for(let z=0;z<X;z++)D.push([]);for(let z=0;z<M;z++){const v=b.findRoot(z);for(let M=0;M<X;M++)if(E[M]===v){D[M].push(z);break}}return D}static partitionFacetIndicesByEdgeConnectedComponent(v,M=!1){if(v instanceof wi)return this.partitionFacetIndicesByEdgeConnectedComponent(v.createVisitor(0),M);v.setNumWrap(1);const b=new Ys;v.reset();let E=0;for(;v.moveToNextFacet();){const D=v.pointCount-1;E++;for(let E=0;E<D;E++)M&&v.edgeVisible[E]||b.addEdge(v.clientPointIndex(E),v.clientPointIndex(E+1),v.currentReadIndex())}const D=[];return b.sortAndCollectClusters(D,D,D,D),this.partitionFacetIndicesBySortableEdgeClusters(D,E)}static sweepLineStringToFacetsXYReturnSweptFacets(v,M){const b=On.create();return this.announceSweepLinestringToConvexPolyfaceXY(v,M,((v,M,E,D,X)=>{4===X.length?b.addQuadFacet(X):3===X.length&&b.addTriangleFacet(X)})),b.claimPolyface(!0)}static sweepLinestringToFacetsXYreturnSweptFacets(v,M){return this.sweepLineStringToFacetsXYReturnSweptFacets(v,M)}static sweepLineStringToFacets(v,M,b){let E,D=[];void 0===b&&(b=nn.create($.unitZ(),W.createRadians(K.smallAngleRadians),!0,!0,!0,!0)),b.assembleChains&&(E=Fs.create());const X=Qs.create(v,b.vectorToEye);if(X){let v;v=M instanceof wi?M.createVisitor(0):M;const z=$.createZero();for(v.reset();v.moveToNextFacet();)b.collectFromThisFacetNormal(vr.areaNormalGo(v.point,z))&&X.processPolygon(v.point.getArray(),((v,M)=>{void 0!==E?E.addSegment(v,M):D.push(we.create(v,M))}));void 0!==E&&(E.clusterAndMergeVerticesXYZ(),D=E.collectMaximalChains())}return D}static sweepLineStringToFacetsXY(v,M,b){const E=Fs.create(),D=$.create(0,0,1),X=ut.create();let z,R;z=M instanceof wi?M.createVisitor(0):M,R=Array.isArray(v)?new ae(v):v;for(let O=1;O<R.length;O++){const v=R.getPoint3dAtUncheckedPointIndex(O-1),M=R.getPoint3dAtUncheckedPointIndex(O),Y=js.createPointPointSweep(v,M,D);void 0!==Y&&(ut.createNull(X),X.extendPoint(v),X.extendPoint(M),b.searchRange2d(X,((v,M)=>(z.moveToReadIndex(M)&&Y.processPolygon(z.point,((v,M)=>E.addSegment(v,M))),!0))))}return E.clusterAndMergeVerticesXYZ(),E.collectMaximalChains()}static sweepLinestringToFacetsXYReturnLines(v,M){const b=nn.create($.unitZ(),W.createSmallAngle(),!1,!0,!0,!0);return on.sweepLineStringToFacets(v,M,b)}static sweepLinestringToFacetsXYReturnChains(v,M){const b=nn.create($.unitZ(),W.createSmallAngle(),!0,!0,!0,!0);return on.sweepLineStringToFacets(v,M,b)}static async asyncSweepLinestringToFacetsXYReturnChains(v,M){const b=Fs.create();return await Promise.resolve(this.asyncAnnounceSweepLinestringToConvexPolyfaceXY(v,M,((v,M,E,D,X,z,R)=>{b.addSegment(X[z],X[R])}))),b.clusterAndMergeVerticesXYZ(),b.collectMaximalChains()}static collectRangeLengthData(v){if(v instanceof wi)return this.collectRangeLengthData(v.createVisitor(0));const M=new sn;for(v.reset();v.moveToNextFacet();)M.accumulateGrowableXYZArrayRange(v.point);return M}static cloneWithTVertexFixup(v){const M=v.createVisitor(1),b=v.createVisitor(0),E=tn.create(v.data.point,30),D=On.create(),X=ut.createNull(),z=Q.create(),R=Q.create(),O=Q.create(),Y=we.create(z,R);for(M.reset();M.moveToNextFacet();){b.clearArrays();for(let D=0;D+1<M.point.length;D++){let N;if(M.point.getPoint3dAtUncheckedPointIndex(D,z),M.point.getPoint3dAtUncheckedPointIndex(D+1,R),b.pushDataFrom(M,D),X.setNull(),we.create(z,R,Y),X.extend(z),X.extend(R),X.ensureMinLengths(K.smallMetricDistance),E.announcePointsInRange(X,((M,b,E,D)=>{v.data.point.getPoint3dAtUncheckedPointIndex(M,O);const X=Y.closestPoint(O,!1);return void 0!==X&&X.fraction>0&&X.fraction<1&&!X.point.isAlmostEqual(z)&&!X.point.isAlmostEqual(R)&&O.isAlmostEqual(X.point)&&(void 0===N&&(N=[]),X.a=M,N.push(X)),!0})),void 0!==N){N.sort(((v,M)=>v.fraction-M.fraction));for(const v of N)b.pushInterpolatedDataFrom(M,D,v.fraction,D+1)}}D.addFacetFromGrowableArrays(b.point,b.normal,b.param,b.color,b.edgeVisible)}return D.claimPolyface()}static compareFacetIndexAndVertexIndices(v,M){if(v.length!==M.length)return v.length-M.length;for(let b=1;b<v.length;b++)if(v[b]!==M[b])return v[b]-M[b];return 0}static collectDuplicateFacetIndices(v,M=!1){const b=[];return this.announceDuplicateFacetIndices(v,(v=>{(M||v.length>1)&&b.push(v.slice())})),b}static announceDuplicateFacetIndices(v,M){const b=v.createVisitor(0),E=[];for(b.reset();b.moveToNextFacet();){const v=[b.currentReadIndex()],M=b.pointIndex,D=M.length;let X=0;for(let E=1;E<b.pointIndex.length;E++)M[E]<M[X]&&(X=E);if(M[(X+1)%D]<M[(X+D-1)%D])for(let b=0;b<D;b++)v.push(M[(X+b)%D]);else for(let b=0;b<D;b++)v.push(M[(X+D-b)%D]);E.push(v)}let D,X;E.sort(((v,M)=>this.compareFacetIndexAndVertexIndices(v,M)));const z=E.length,R=[];for(D=0;D<z;D=X){for(X=D+1,R.length=0,R.push(E[D][0]);X<z&&0===this.compareFacetIndexAndVertexIndices(E[D],E[X]);)R.push(E[X][0]),X++;M(R)}}static cloneByFacetDuplication(v,M,b){const E=On.create(),D=v.createVisitor(0);return this.announceDuplicateFacetIndices(v,(v=>{let X=0;1===v.length?M&&(X=1):v.length>1&&(b===eo.SelectAny?X=1:b===eo.SelectAll?X=v.length:b===eo.SelectOneByParity&&(X=1==(1&v.length)?1:0));for(let M=0;M<X;M++)D.moveToReadIndex(v[M]),E.addFacetFromVisitor(D)})),E.claimPolyface()}static cloneWithColinearEdgeFixup(v){const M=v.createVisitor(2),b=v.createVisitor(0),E=On.create(),D=$.create(),X=$.create(),z=v.data.point.length,R=new Int32Array(z);for(M.reset();M.moveToNextFacet();)for(let v=0;v+2<M.point.length;v++){M.point.vectorIndexIndex(v,v+1,D),M.point.vectorIndexIndex(v+1,v+2,X);const b=M.clientPointIndex(v+1);R[b]>=0&&(D.angleTo(X).isAlmostZero?R[b]++:R[b]=-1)}for(M.reset();M.moveToNextFacet();){b.clearArrays();for(let v=0;v+2<M.point.length;v++)R[M.clientPointIndex(v)]<0&&b.pushDataFrom(M,v);b.point.length>2&&E.addFacetFromGrowableArrays(b.point,b.normal,b.param,b.color,b.edgeVisible)}return E.claimPolyface()}static setEdgeVisibility(v,M,b){for(const E of M)if(E instanceof Ns)this.setSingleEdgeVisibility(v,E.facetIndex,E.vertexIndexA,b);else if(Array.isArray(E))for(const M of E)this.setSingleEdgeVisibility(v,M.facetIndex,M.vertexIndexA,b)}static setSingleEdgeVisibility(v,M,b,E){const D=v.data,X=v.facetIndex0(M),z=v.facetIndex1(M);for(let R=X;R<z;R++)D.pointIndex[R]===b&&(D.edgeVisible[R]=E)}static getSingleEdgeVisibility(v,M,b){const E=v.data,D=v.facetIndex0(M),X=v.facetIndex1(M);for(let z=D;z<X;z++)if(E.pointIndex[z]===b)return E.edgeVisible[z]}static createIndexedEdges(v){if(v instanceof wi)return this.createIndexedEdges(v.createVisitor(1));const M=new Ys;for(v.reset();v.moveToNextFacet();){const b=v.pointCount-1;for(let E=0;E<b;E++)M.addEdge(v.clientPointIndex(E),v.clientPointIndex(E+1),v.currentReadIndex())}return M}static collectEdgesByDihedralAngle(v,M,b=!1){if(v instanceof wi)return this.collectEdgesByDihedralAngle(v.createVisitor(1),M,b);v.setNumWrap(1);const E=[];this.createIndexedEdges(v).sortAndCollectClusters(E),(void 0===M||M.radians<0)&&(M=W.createRadians(K.smallAngleRadians));const D=[],X=$.create(),z=$.create();for(const R of E)if(Array.isArray(R)&&2===R.length){const E=R[0],O=R[1];if(void 0!==on.computeFacetUnitNormal(v,E.facetIndex,X)&&void 0!==on.computeFacetUnitNormal(v,O.facetIndex,z)){const v=X.smallerUnorientedAngleTo(z);b?v.radians>M.radians&&D.push(R):v.radians<=M.radians&&D.push(R)}}return D}static markPairedEdgesInvisible(v,M){const b=v.createVisitor(1),E=[],D=[];if(this.createIndexedEdges(b).sortAndCollectClusters(E,D,D,D),this.markAllEdgeVisibility(v,!1),this.setEdgeVisibility(v,D,!0),void 0!==M){const D=$.create(),X=$.create();for(const z of E)if(Array.isArray(z)&&2===z.length){const E=z[0],R=z[1];void 0!==on.computeFacetUnitNormal(b,E.facetIndex,D)&&void 0!==on.computeFacetUnitNormal(b,R.facetIndex,X)&&D.smallerUnorientedAngleTo(X).radians>M.radians&&(this.setSingleEdgeVisibility(v,E.facetIndex,E.vertexIndexA,!0),this.setSingleEdgeVisibility(v,R.facetIndex,R.vertexIndexA,!0))}}}static computeFacetUnitNormal(v,M,b){if(b||(b=$.create()),v.moveToReadIndex(M)&&vr.unitNormal(v.point,b))return b}static markAllEdgeVisibility(v,M){const b=v.data;for(let E=0;E<b.edgeVisible.length;E++)b.edgeVisible[E]=M}static convertToHalfEdgeGraph(v){const M=new ks,b=v.createVisitor(0);for(b.reset();b.moveToNextFacet();)M.insertLoop(b.pointIndex);const E=M.graph,D=Q.create();return E.announceNodes(((M,b)=>{const E=b.i;return v.data.getPoint(E,D),b.setXYZ(D),!0})),E}static reorientVertexOrderAroundFacetsForConsistentOrientation(v){return Bs.doFixup(v)}static buildPerFaceNormals(v){Us.buildPerFaceNormals(v)}static buildAverageNormals(v,M=W.createDegrees(31)){Us.buildFastAverageNormals(v,M)}static cloneOffset(v,M,b=rn.create()){const E=Ie.createForFacets(),D=On.create(E);return Js.buildOffsetMeshWithEdgeChamfers(v,D,M,b),D.claimPolyface()}static intersectRay3d(v,M,b){if(v instanceof wi)return on.intersectRay3d(v.createVisitor(0),M,b);let E;for(v.setNumWrap(0);v.moveToNextFacet();){const D=v.pointCount,X=v.point;if(3===D){const D=this._workTriangle=Vi.create(X.getPoint3dAtUncheckedPointIndex(0),X.getPoint3dAtUncheckedPointIndex(1),X.getPoint3dAtUncheckedPointIndex(2),this._workTriangle),z=this._workTriDetail=D.intersectRay3d(M,this._workTriDetail);D.snapLocationToEdge(z,b?.distanceTolerance,b?.parameterTolerance),E=this._workFacetDetail3=Xs.create(v.currentReadIndex(),z,this._workFacetDetail3)}else{const z=this._workPolyDetail=vr.intersectRay3d(X,M,b?.distanceTolerance,this._workPolyDetail);E=vr.isConvex(X)?this._workFacetDetailC=zs.create(v.currentReadIndex(),D,z,this._workFacetDetailC):this._workFacetDetailNC=Rs.create(v.currentReadIndex(),D,z,this._workFacetDetailNC)}if(E.isInsideOrOn){if(b?.needNormal&&v.normal&&E.getNormal(v.normal,X,b?.distanceTolerance),b?.needParam&&v.param&&E.getParam(v.param,X,b?.distanceTolerance),b?.needColor&&v.color&&E.getColor(v.color,X,b?.distanceTolerance),b?.needBarycentricCoordinates&&E.getBarycentricCoordinates(X,b?.distanceTolerance),b?.acceptIntersection&&!b.acceptIntersection(E,v))continue;return E}}}}on._asyncWorkLimit=1e6,on.awaitBlockCount=0;class an{constructor(v){this._planes=v||[]}toJSON(){const v=[];for(const M of this._planes)v.push(M.toJSON());return v}static fromJSON(v,M){if((M=M||new an)._planes.length=0,!Array.isArray(v))return M;for(const b of v){const v=Ar.fromJSON(b);v&&M._planes.push(v)}return M}isAlmostEqual(v){if(this._planes.length!==v._planes.length)return!1;for(let M=0;M<this._planes.length;M++)if(!this._planes[M].isAlmostEqual(v._planes[M]))return!1;return!0}static createPlanes(v,M){M=M||new an;for(const b of v)if(b instanceof Ar)M._planes.push(b);else if(b instanceof yt){const v=Ar.createPlane(b);M._planes.push(v)}return M}static createRange3dPlanes(v,M=!0,b=!0,E=!0,D=!0,X=!0,z=!0){const R=an.createEmpty();return M&&R.planes.push(Ar.createNormalAndPointXYZXYZ(1,0,0,v.low.x,0,0)),b&&R.planes.push(Ar.createNormalAndPointXYZXYZ(-1,0,0,v.high.x,0,0)),E&&R.planes.push(Ar.createNormalAndPointXYZXYZ(0,1,0,0,v.low.y,0)),D&&R.planes.push(Ar.createNormalAndPointXYZXYZ(0,-1,0,0,v.high.y,0)),X&&R.planes.push(Ar.createNormalAndPointXYZXYZ(0,0,1,0,0,v.low.z)),z&&R.planes.push(Ar.createNormalAndPointXYZXYZ(0,0,-1,0,0,v.high.z)),R}static createEmpty(v){return v?(v._planes.length=0,v):new an}negateAllPlanes(){for(const v of this._planes)v.negateInPlace()}static createXYBox(v,M,b,E,D){(D=D||new an)._planes.length=0;const X=Ar.createNormalAndDistance($.create(-1,0,0),-b,!1,!0),z=Ar.createNormalAndDistance($.create(1,0,0),v,!1,!0),R=Ar.createNormalAndDistance($.create(0,-1,0),-E,!1,!0),O=Ar.createNormalAndDistance($.create(0,1,0),M,!1,!0);return X&&z&&R&&O&&D._planes.push(X,z,R,O),D}static createXYPolyLine(v,M,b,E){(E=E||new an)._planes.length=0;for(let D=0;D+1<v.length;D++){const X=$.createStartEnd(v[D],v[D+1]).unitPerpendicularXY();if(X.z=0,b||X.scaleInPlace(-1),X.normalize()){const b=void 0!==M&&M[D],z=Ar.createNormalAndPoint(X,v[D],b,b);z&&E._planes.push(z)}}return E}static createXYPolyLineInsideLeft(v,M){(M=M||new an)._planes.length=0;for(let b=0;b+1<v.length;b++){const E=$.createStartEnd(v[b],v[b+1]).unitPerpendicularXY();if(E.z=0,E.normalize()){const D=Ar.createNormalAndPoint(E,v[b],!1,!1);D&&M._planes.push(D)}}return M}static setPlaneAndXYLoopCCW(v,M,b){const E=v.length-1,D=v.length;let X,z,R,O,Y=v.getXAtUncheckedPointIndex(E),N=v.getYAtUncheckedPointIndex(E);b._planes.length=0;const B=v.getZAtUncheckedPointIndex(E),V=v.crossProductIndexIndexIndex(0,2,1);if(Ar.createNormalAndPointXYZXYZ(V.x,V.y,V.z,Y,N,B,!1,!1,M),V.normalizeInPlace())for(let L=0;L<D;L++,Y=X,N=z){X=v.getXAtUncheckedPointIndex(L),z=v.getYAtUncheckedPointIndex(L),R=-(z-N),O=X-Y;const M=Ar.createNormalAndPointXYZXYZ(R,O,0,X,z,B);M&&b._planes.push(M)}}clone(v){(v=v||new an)._planes.length=0;for(const M of this._planes)v._planes.push(M.clone());return v}get planes(){return this._planes}hasIntersectionWithRay(v,M,b=K.smallMetricDistance){let E=-K.largeCoordinateResult,D=K.largeCoordinateResult;M&&M.setNull();for(const X of this._planes){const M=X.velocity(v.direction),z=X.altitude(v.origin);if(Math.abs(M)<=1e-13){if(z<-b)return!1}else{const v=-z/M;M<0?v<D&&(D=v):v>E&&(E=v)}}return!(D<E||(M&&(M.extendX(E),M.extendX(D)),0))}multiplyPlanesByMatrix4d(v,M=!0,b=!0){if(M){const M=v.createInverse();return!!M&&this.multiplyPlanesByMatrix4d(M,!1,b)}for(const E of this._planes)E.multiplyPlaneByMatrix4d(v,!1,b);return!0}isPointInside(v){for(const M of this._planes)if(!M.isPointInside(v))return!1;return!0}isPointOnOrInside(v,M=K.smallMetricDistance){const b=Math.abs(M);for(const E of this._planes)if(!E.isPointOnOrInside(v,E.interior?b:M))return!1;return!0}isSphereInside(v,M){const b=Math.abs(M)+K.smallMetricDistance;for(const E of this._planes)if(!E.isPointOnOrInside(v,b))return!1;return!0}announceClippedSegmentIntervals(v,M,b,E,D){let X;if(M<v)return!1;for(const z of this._planes){const D=-z.altitude(b),R=-z.altitude(E);if(X=K.conditionalDivideFraction(-D,R-D),void 0===X){if(D>0)return!1}else if(R>D){if(X<v)return!1;X<M&&(M=X)}else if(D>R){if(X>M)return!1;X>v&&(v=X)}else if(D>0)return!1}return M>=v&&(D&&D(v,M),!0)}announceClippedArcIntervals(v,M){const b=an._clipArcFractionArray;b.clear();for(const E of this.planes)E.appendIntersectionRadians(v,b);return v.sweep.radiansArrayToPositivePeriodicFractions(b),ds.selectIntervals01(v,b,this,M)}clipUnboundedSegment(v,M,b){return this.announceClippedSegmentIntervals(-Number.MAX_VALUE,Number.MAX_VALUE,v,M,b)}transformInPlace(v){for(const M of this._planes)M.transformInPlace(v)}clipConvexPolygonInPlace(v,M,b=K.smallMetricDistance){for(const E of this._planes)if(E.clipConvexPolygonInPlace(v,M,!0,b),v.length<3)return}clipInsidePushOutside(v,M,b){const E=ft.createNull();let D=b.grabFromCache(),X=b.grabFromCache(),z=b.grabFromCache();z.pushFrom(v);for(const R of this._planes)if(Pr.splitConvexPolygonInsideOutsidePlane(R,z,D,X,E),X.length>0){if(M&&ds.captureOrDrop(X,3,M,b),X=b.grabFromCache(),0===D.length){z.length=0;break}b.dropToCache(z),z=D,D=b.grabFromCache()}if(b.dropToCache(D),b.dropToCache(X),z.length>0)return z;b.dropToCache(z)}classifyPointContainment(v,M){let b=!0;const E=M?1e-8:-1e-8;for(const D of this._planes){let M=0;for(const X of v)D.altitude(X)<(D.interior?1e-8:E)&&(M++,b=!1);if(M===v.length)return Nr.StronglyOutside}return b?Nr.StronglyInside:Nr.Ambiguous}static createSweptPolyline(v,M,b){const E=an.createEmpty();let D=!1;v.length>3&&v[0].isAlmostEqual(v[v.length-1])&&vr.areaNormal(v).dotProduct(M)>0&&(D=!0);for(let X=0;X+1<v.length;X++)if(D){const D=Ar.createEdgeAndUpVector(v[X+1],v[X],M,b);if(!D)return;E.addPlaneToConvexSet(D)}else{const D=Ar.createEdgeAndUpVector(v[X],v[X+1],M,b);if(!D)return;E.addPlaneToConvexSet(D)}return E}addPlaneToConvexSet(v){v instanceof Ar?this._planes.push(v):v instanceof yt&&this._planes.push(Ar.createPlane(v))}clipPointsOnOrInside(v,M,b){M.length=0,b.length=0;for(const E of v)this.isPointOnOrInside(E,0)?M.push(E):b.push(E)}polygonClip(v,M,b,E){v instanceof nt?v.clone(M):nt.create(v,M);for(const D of this._planes)if(E!==D){if(0===M.length)break;D.clipConvexPolygonInPlace(M,b)}}reloadSweptPolygon(v,M,b){this._planes.length=0;const E=v.length;if(E<=2)return 0;const D=vr.areaNormal(v),X=M.dotProduct(D)>0,z=X?1:E-1;for(let R=0;R<E;R++){const b=(R+z)%E,D=v[R],X=v[b];if(D.isAlmostEqual(X))continue;const O=$.createStartEnd(D,X),Y=$.createCrossProduct(M.x,M.y,M.z,O.x,O.y,O.z).normalize();let N;if(Y){N=Y.dotProduct(D);const v=Ar.createNormalAndDistance(Y,N,!1,!1);v&&this._planes.push(v)}}if(0!==b){let E=D.normalize();if(E){M.dotProduct(E)*b<0&&(E=E.negate());const D=v[0],X=E.dotProduct(D),z=Ar.createNormalAndDistance(E,X,!1,!1);z&&this._planes.push(z)}}return X?1:-1}computePlanePlanePlaneIntersections(v,M,b,E=!0){const D=xt.createIdentity(),X=this._planes,z=X.length;let R=0;for(let O=0;O<z;O++)for(let Y=O+1;Y<z;Y++)for(let N=Y+1;N<z;N++)if(xt.createRowValues(X[O].inwardNormalRef.x,X[O].inwardNormalRef.y,X[O].inwardNormalRef.z,X[Y].inwardNormalRef.x,X[Y].inwardNormalRef.y,X[Y].inwardNormalRef.z,X[N].inwardNormalRef.x,X[N].inwardNormalRef.y,X[N].inwardNormalRef.z,D),D.computeCachedInverse(!1)){const z=D.multiplyInverseXYZAsPoint3d(X[O].distance,X[Y].distance,X[N].distance);E&&!this.isPointOnOrInside(z,K.smallMetricDistance)||(R++,b&&b.multiplyPoint3d(z,z),v&&v.push(z),M&&M.extendPoint(z))}return R}setInvisible(v){for(const M of this._planes)M.setInvisible(v)}addZClipPlanes(v,M,b){void 0!==M&&this._planes.push(Ar.createNormalAndDistance($.create(0,0,1),M,v)),void 0!==b&&this._planes.push(Ar.createNormalAndDistance($.create(0,0,-1),-b,v))}appendPolygonClip(v,M,b,E){const D=this.clipInsidePushOutside(v,b,E);D&&M.push(D)}static createConvexPolyface(v,M){M=this.createEmpty(M);let b,E,D=0;if(v instanceof wi?(b=v,E=v.createVisitor(0)):(b=v.clientPolyface(),E=v),b&&E){on.isPolyfaceClosedByEdgePairing(b)&&(D=on.sumTetrahedralVolumes(E));const v=D>0?-1:1,X=$.create(),z=yt.createXYPlane();for(E.reset();E.moveToNextFacet();)void 0!==vr.areaNormalGo(E.point,X)&&(X.scaleInPlace(v),void 0!==yt.create(E.point.front(),X,z)&&M.addPlaneToConvexSet(z))}return{clipper:M,volume:D}}}an.hugeVal=1e37,an._clipArcFractionArray=new At;class cn{constructor(v,M,b){if(v instanceof oe){const M=v;(v=v.startPoint().isAlmostEqual(v.endPoint())?new Oe:new Ve).tryAddChild(M)}this.curves=v,this.localToWorld=M,this.axis=b}static createForLinearSweep(v,M){const b=ei.createRightHandedFrame(M,v);if(b)return new cn(v,b,void 0)}static createForPolygon(v,M){const b=ei.createRightHandedFrame(M,v);if(b){void 0!==M&&b.matrix.dotColumnZ(M)&&b.matrix.scaleColumnsInPlace(1,-1,-1);const E=ke.createArrayOfLineString3d(v),D=[];for(const v of E)v.addClosurePoint(),D.push(Oe.create(v));if(1===D.length)return new cn(D[0],b,void 0);if(D.length>1)return new cn(ii.createLoops(D),b,void 0)}}static createForRotation(v,M){const b=ei.createRightHandedFrame(void 0,v,M);if(b)return new cn(v,b,M.clone())}getCurves(){return this.curves}tryTransformInPlace(v){if(this.curves.tryTransformInPlace(v)){this.axis&&this.axis.transformInPlace(v);const M=void 0!==this.axis?ei.createRightHandedFrame(void 0,this.curves,this.axis):ei.createRightHandedFrame(void 0,this.curves);if(M)return this.localToWorld.setFrom(M),this._xyStrokes=void 0,!0}return!1}clone(){return new cn(this.curves.clone(),this.localToWorld.clone(),this.axis)}cloneTransformed(v){const M=this.clone();if(M.tryTransformInPlace(v))return M}isAlmostEqual(v){if(!(v instanceof cn))return!1;if(!this.curves.isAlmostEqual(v.curves))return!1;if(!this.localToWorld.isAlmostEqual(v.localToWorld))return!1;if(this.axis&&v.axis){if(!this.axis.isAlmostEqual(v.axis))return!1}else if(this.axis||v.axis)return!1;return!0}computeXYStrokes(v){this._xyStrokes=void 0;const M=this.localToWorld.inverse();if(M){const b=this.curves.cloneStroked(v);b.tryTransformInPlace(M)&&(this._xyStrokes=b)}}get xyStrokes(){return this._xyStrokes}buildFacets(v){if(this._facets)return;if(!this.curves.isAnyRegion())return;const M=this.localToWorld.inverse();if(!M)return;const b=this.curves.cloneTransformed(M);b&&(this._facets=lr.facetRegionXY(b,v))&&this._facets.tryTransformInPlace(this.localToWorld)}purgeFacets(){this._facets=void 0}emitFacets(v,M,b){this.buildFacets(v.options),this._facets&&v.addIndexedPolyface(this._facets,M,b)}announceFacets(v,M){this.buildFacets(M),this._facets&&v(this._facets)}sweepToUnionOfConvexClipPlaneSets(v,M=!1,b=!1,E){E||(E=Ie.createForFacets()),v||(M=b=!1,v=this.localToWorld.matrix.columnZ()),E.maximizeConvexFacets=!0,this.buildFacets(E);const D=this._facets;if(D){const E=Q.create(),X=Q.create(),z=Qi.createEmpty(),R=D.createVisitor(1);for(R.reset();R.moveToNextFacet();){const M=R.point.length-1,b=an.createEmpty();for(let D=0;D<M;D++){R.point.getPoint3dAtUncheckedPointIndex(D,E),R.point.getPoint3dAtUncheckedPointIndex(D+1,X);const M=Ar.createEdgeAndUpVector(X,E,v),z=R.edgeVisible[D];M?.setFlags(!z,!z),b.addPlaneToConvexSet(M)}z.addConvexSet(b)}if(M||b){const E=this.localToWorld.matrix.columnZ(),D=this.localToWorld.getOrigin(),X=D.plus(v),R=E.clone(),O=E.negate(),Y=an.createEmpty();M&&Y.addPlaneToConvexSet(Ar.createNormalAndPoint(R,D)),b&&Y.addPlaneToConvexSet(Ar.createNormalAndPoint(O,X)),z.addConvexSet(Y)}return z}}}class hn extends ai{constructor(v,M){super(M),this.solidPrimitiveType="ruledSweep",this._contours=v}static create(v,M){const b=[];for(const E of v){const v=cn.createForLinearSweep(E);if(void 0===v)return;b.push(v)}return new hn(b,M)}sweepContoursRef(){return this._contours}cloneSweepContours(){const v=[];for(const M of this._contours)v.push(M.clone());return v}cloneContours(){const v=[];for(const M of this._contours)v.push(M.curves.clone());return v}clone(){return new hn(this.cloneSweepContours(),this.capped)}tryTransformInPlace(v){if(v.matrix.isSingular())return!1;for(const M of this._contours)M.tryTransformInPlace(v);return!0}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}getConstructiveFrame(){if(0!==this._contours.length)return this._contours[0].localToWorld.cloneRigid()}isSameGeometryClass(v){return v instanceof hn}isAlmostEqual(v){if(v instanceof hn){if(this.capped!==v.capped)return!1;if(this._contours.length!==v._contours.length)return!1;for(let M=0;M<this._contours.length;M++)if(!this._contours[M].isAlmostEqual(v._contours[M]))return!1;return!0}return!1}dispatchToGeometryHandler(v){return v.handleRuledSweep(this)}constantVSection(v){const M=this._contours.length;if(M<2)return;const b=v*M;let E=0;E=v>=1?M-1:Math.floor(b),E+1>=M&&(E=M-2);const D=E+1,X=K.clampToStartEnd(b-E,0,1);return hn.mutatePartners(this._contours[E].curves,this._contours[D].curves,((v,M)=>{const b=ri.interpolateBetween(v,X,M);if(b instanceof oe)return b}))}extendRange(v,M){for(const b of this._contours)b.curves.extendRange(v,M)}static mutatePartners(v,M,b){if(v.isSameGeometryClass(M)){if(v instanceof Ne&&M instanceof Ne){const E=v,D=M,X=E.cloneEmptyPeer(),z=E.children,R=D.children;if(z.length!==R.length)return;for(let v=0;v<z.length;v++){const M=b(z[v],R[v]);if(!M)return;X.children.push(M)}return X}if(v instanceof ze&&M instanceof ze){const E=v.cloneEmptyPeer(),D=v.children,X=M.children,z=E.children;if(void 0===D||void 0===X||void 0===z||D.length!==X.length)return;for(let v=0;v<D.length;v++){const M=D[v],E=X[v];if(M instanceof oe&&E instanceof oe){const v=b(M,E);if(!v)return;z.push(v)}else if(M instanceof ze&&E instanceof ze){const v=this.mutatePartners(M,E,b);if(!v)return;v instanceof ze&&z.push(v)}}return E}}}get isClosedVolume(){const v=this._contours.length;return v>1&&(this.capped||this._contours[0].isAlmostEqual(this._contours[v-1]))}}class ln extends ai{constructor(v,M,b,E,D){super(D),this.solidPrimitiveType="torusPipe",this._localToWorld=v,this._radiusA=M,this._radiusB=b,this._sweep=E,this._isReversed=!1}clone(){const v=new ln(this._localToWorld.clone(),this._radiusA,this._radiusB,this._sweep.clone(),this.capped);return v._isReversed=this._isReversed,v}tryTransformInPlace(v){return!v.matrix.isSingular()&&(v.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(v){const M=this.clone();if(M.tryTransformInPlace(v))return M}static createInFrame(v,M,b,E,D){if((M=Math.abs(K.correctSmallMetricDistance(M)))<(b=Math.abs(K.correctSmallMetricDistance(b))))return;if(0===M)return;if(0===b)return;if(E.isAlmostZero)return;let X=1,z=1,R=!1;v.matrix.determinant()<0&&(z*=-1);const O=E.clone();E.radians<0&&(O.setRadians(-E.radians),z*=-1,X*=-1,R=!0);const Y=v.clone();Y.matrix.scaleColumnsInPlace(1,X,z);const N=new ln(Y,M,b,O,D);return N._isReversed=R,N}static createDgnTorusPipe(v,M,b,E,D,X,z){const R=M.unitCrossProductWithDefault(b,0,0,1),O=pt.createOriginAndMatrixColumns(v,M,b,R);return ln.createInFrame(O,E,D,X,z)}static createAlongArc(v,M,b){W.isAlmostEqualRadiansAllowPeriodShift(0,v.sweep.startRadians)||(v=v.cloneInRotatedBasis(v.sweep.startAngle));const E=v.sweep.sweepRadians,D=v.toScaledMatrix3d(),X=pt.createOriginAndMatrix(D.center,D.axes);return ln.createInFrame(X,D.r0,M,W.createRadians(E),b)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){const v=this._localToWorld.matrix.columnX();return v.normalizeWithDefault(1,0,0,v)}cloneVectorY(){const v=this._localToWorld.matrix.columnY();return v.normalizeWithDefault(0,1,0,v)}cloneVectorZ(){const v=this._localToWorld.matrix.columnZ();return v.normalizeWithDefault(0,0,1,v)}getMajorRadius(){return this._radiusA*this._localToWorld.matrix.columnXMagnitude()}getMinorRadius(){return this._radiusB*this._localToWorld.matrix.columnZMagnitude()}getSweepAngle(){return this._sweep.clone()}getIsReversed(){return this._isReversed}getThetaFraction(){return this._sweep.radians/(2*Math.PI)}cloneLocalToWorld(){return this._localToWorld.clone()}isSameGeometryClass(v){return v instanceof ln}isAlmostEqual(v){return!!(v instanceof ln&&(this._sweep.isFullCircle||this.capped===v.capped)&&this.cloneCenter().isAlmostEqual(v.cloneCenter())&&this.cloneVectorX().isAlmostEqual(v.cloneVectorX())&&this.cloneVectorY().isAlmostEqual(v.cloneVectorY())&&this.cloneVectorZ().isAlmostEqual(v.cloneVectorZ())&&K.isSameCoordinate(this.getMinorRadius(),v.getMinorRadius())&&K.isSameCoordinate(this.getMajorRadius(),v.getMajorRadius())&&this.getSweepAngle().isAlmostEqualNoPeriodShift(v.getSweepAngle()))}vFractionToRadians(v){return this._sweep.radians*v}dispatchToGeometryHandler(v){return v.handleTorusPipe(this)}constantVSection(v){const M=this.vFractionToRadians(v),b=Math.cos(M),E=Math.sin(M),D=this._radiusA,X=this._radiusB,z=this._localToWorld.multiplyXYZ(D*b,D*E,0),R=this._localToWorld.multiplyVectorXYZ(X*b,X*E,0),O=this._localToWorld.multiplyVectorXYZ(0,0,X);return Oe.create(ti.create(z,R,O))}constantUSection(v){const M=this._sweep.radians,b=2*v*Math.PI,E=this._radiusA,D=this._radiusB,X=this._localToWorld.matrix,z=this._localToWorld.multiplyXYZ(0,0,D*Math.sin(b)),R=E+D*Math.cos(b),O=X.multiplyXYZ(R,0,0),Y=X.multiplyXYZ(0,R,0);return Ve.create(ti.create(z,O,Y,It.createStartEndRadians(0,M)))}extendRange(v,M){const b=this._sweep.radians,E=this._radiusA,D=this._radiusB,X=this._localToWorld,z=Math.ceil(b/(Math.PI/16));let R=0,O=0,Y=0,N=0,B=0,V=0,L=0,U=0,Sr=0;const Cr=b/z;for(let kr=0;kr<=z;kr++)if(N=kr*Cr,B=Math.cos(N),V=Math.sin(N),0===kr||kr===z?(R=-Math.PI,O=2*Math.PI/16,Y=16):(R=-.5*Math.PI,O=Math.PI/16,Y=31),M)for(Sr=0;Sr<=Y;Sr++)U=R+Sr*O,L=E+D*Math.cos(U),v.extendTransformTransformedXYZ(M,X,B*L,V*L,Math.sin(U)*D);else for(Sr=0;Sr<=Y;Sr++)U=R+Sr*O,L=E+D*Math.cos(U),v.extendTransformedXYZ(X,B*L,V*L,Math.sin(U)*D)}uvFractionToPoint(v,M,b){const E=M*this._sweep.radians,D=v*Math.PI*2,X=Math.cos(E),z=Math.sin(E),R=this._radiusA,O=this._radiusB,Y=R+Math.cos(D)*O;return this._localToWorld.multiplyXYZ(Y*X,Y*z,O*Math.sin(D),b)}uvFractionToPointAndTangents(v,M,b){const E=M*this._sweep.radians,D=v*Math.PI*2,X=this._sweep.radians,z=2*Math.PI,R=Math.cos(E),O=Math.sin(E),Y=Math.sin(D),N=Math.cos(D),B=this._radiusA,V=this._radiusB,L=B+Math.cos(D)*V,U=V*Y,Sr=V*N;return bt.createOriginAndVectors(this._localToWorld.multiplyXYZ(R*L,O*L,U),this._localToWorld.multiplyVectorXYZ(-R*U*z,-O*U*z,Sr*z),this._localToWorld.multiplyVectorXYZ(-L*O*X,L*R*X,0),b)}maxIsoParametricDistance(){const v=Math.abs(this.getMajorRadius()),M=Math.abs(this.getMinorRadius());return J.create(M*Math.PI*2,(v+M)*this._sweep.radians)}get isClosedVolume(){return this.capped||this._sweep.isFullCircle}}class dn extends oe{get activeFractionInterval(){return this._activeFractionInterval}get localToWorld(){return this._localToWorld}constructor(v,M,b,E){super(),this._spiralType=v||"unknownSpiralType",this._designProperties=E,this._localToWorld=M,this._activeFractionInterval=b||We.create(0,1)}get spiralType(){return this._spiralType}static radiusToCurvature(v){return 0===v?0:1/v}static curvatureToRadius(v){return Math.abs(v)<K.smallAngleRadians?0:1/v}clonePartialCurve(v,M){const b=this.clone(),E=this._activeFractionInterval.fractionToPoint(v),D=this._activeFractionInterval.fractionToPoint(M);return b._activeFractionInterval.set(E,D),b.refreshComputedProperties(),b}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}static averageCurvature(v){return.5*(dn.radiusToCurvature(v.x0)+dn.radiusToCurvature(v.x1))}static averageCurvatureR0R1(v,M){return.5*(dn.radiusToCurvature(v)+dn.radiusToCurvature(M))}static interpolateCurvatureR0R1(v,M,b){return K.interpolate(dn.radiusToCurvature(v),M,dn.radiusToCurvature(b))}static radiusRadiusSweepRadiansToArcLength(v,M,b){return Math.abs(b/dn.averageCurvatureR0R1(v,M))}static radiusRadiusLengthToSweepRadians(v,M,b){return dn.averageCurvatureR0R1(v,M)*b}static radius0LengthSweepRadiansToRadius1(v,M,b){return dn.curvatureToRadius(2*b/M-dn.radiusToCurvature(v))}static radius1LengthSweepRadiansToRadius0(v,M,b){return dn.curvatureToRadius(2*b/M-dn.radiusToCurvature(v))}get designProperties(){return this._designProperties}applyRigidPartOfTransform(v){const M=v.matrix.factorRigidWithSignedScale();if(void 0!==M){const b=v.multiplyTransformTransform(this.localToWorld),E=M.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);return this._localToWorld=pt.createOriginAndMatrix(b.origin,E),this.designProperties&&this.designProperties.applyScaleFactor(M.scale),M}}constructOffsetXY(v){const M=Se.create(v),b=new ye(this,M.leftOffsetDistance);return this.emitStrokableParts(b,M.strokeOptions),b.claimResult()}extendRange(v,M){const b=this.rangeBetweenFractions(0,1,M);v.extendRange(b)}rangeBetweenFractions(v,M,b){const E=this.activeStrokes;if(void 0===E)return ut.createNull();let D=Math.ceil(E.numPoints()*Math.abs(M-v));return D=K.clamp(5,D,30),this.rangeBetweenFractionsByCount(v,M,D,b,.5)}projectedParameterRange(v,M){return qe.findExtremeFractionsAlongDirection(this,v,M)}}class un{constructor(){}static findEvaluator(v){return"clothoid"===v?this._clothoidEvaluator?this._clothoidEvaluator:this._clothoidEvaluator=new fn:"bloss"===v?this._blossEvaluator?this._blossEvaluator:this._blossEvaluator=new gn:"biquadratic"===v?this._biquadraticEvaluator?this._biquadraticEvaluator:this._biquadraticEvaluator=new pn:"sine"===v?this._sineEvaluator?this._sineEvaluator:this._sineEvaluator=new mn:"cosine"===v?this._cosineEvaluator?this._cosineEvaluator:this._cosineEvaluator=new xn:void 0}}class fn extends un{constructor(){super()}fractionToCurvatureFraction(v){return v}fractionToCurvatureFractionDerivative(v){return 1}fractionToArea(v){return v*v*.5}}class gn extends un{constructor(){super()}fractionToCurvatureFraction(v){return v*v*(3-2*v)}fractionToCurvatureFractionDerivative(v){return 6*v*(1-v)}fractionToArea(v){return v*v*v*(1-.5*v)}}class pn extends un{constructor(){super()}integratedBasis(v){return v*v*v*(2/3)}basis(v){return 2*v*v}basisDerivative(v){return 4*v}fractionToCurvatureFraction(v){return v<=.5?this.basis(v):1-this.basis(1-v)}fractionToCurvatureFractionDerivative(v){return v<.5?this.basisDerivative(v):this.basisDerivative(1-v)}fractionToArea(v){if(v<=.5)return this.integratedBasis(v);const M=1-v;return.5-M+this.integratedBasis(M)}}class mn extends un{constructor(){super()}fractionToCurvatureFraction(v){const M=2*Math.PI;return v-Math.sin(v*M)/M}fractionToCurvatureFractionDerivative(v){const M=2*Math.PI;return 1-Math.cos(v*M)}fractionToArea(v){const M=2*Math.PI;return.5*v*v+(Math.cos(v*M)-1)/(M*M)}}class xn extends un{constructor(){super()}fractionToCurvatureFraction(v){const M=Math.PI;return.5*(1-Math.cos(v*M))}fractionToCurvatureFractionDerivative(v){const M=Math.PI;return.5*M*Math.sin(v*M)}fractionToArea(v){const M=Math.PI;return.5*v-.5*Math.sin(v*M)/M}}class yn{constructor(v,M,b,E,D){this.radius0=v,this.radius1=M,this.bearing0=b,this.bearing1=E,this.curveLength=D}numDefinedProperties(){return K.defined01(this.radius0)+K.defined01(this.radius1)+K.defined01(this.bearing0)+K.defined01(this.bearing1)+K.defined01(this.curveLength)}clone(){return new yn(this.radius0,this.radius1,void 0===this.bearing0?void 0:this.bearing0.clone(),void 0===this.bearing1?void 0:this.bearing1.clone(),this.curveLength)}getIsValidCompleteSet(){if(void 0!==this.curveLength&&void 0!==this.bearing0&&void 0!==this.bearing1&&void 0!==this.radius0&&void 0!==this.radius1){const v=dn.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,this.bearing1.radians-this.bearing0.radians);return K.isSameCoordinate(this.curveLength,v)}return!1}tryResolveAnySingleUnknown(){if(this.getIsValidCompleteSet())return!0;if(this.bearing0&&this.bearing1){const v=this.bearing1.radians-this.bearing0.radians;return void 0===this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1?(this.curveLength=dn.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,v),!0):void 0!==this.curveLength&&void 0===this.radius0&&void 0!==this.radius1?(this.radius0=dn.radius1LengthSweepRadiansToRadius0(this.radius1,this.curveLength,v),!0):void 0!==this.curveLength&&void 0!==this.radius0&&void 0===this.radius1&&(this.radius1=dn.radius0LengthSweepRadiansToRadius1(this.radius0,this.curveLength,v),!0)}return void 0!==this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1&&(this.bearing0?(this.bearing1=W.createRadians(this.bearing0.radians+dn.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0):!!this.bearing1&&(this.bearing0=W.createRadians(this.bearing1.radians-dn.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0))}almostEqualCoordinate(v,M){return void 0===v&&void 0===M||void 0!==v&&void 0!==M&&K.isSameCoordinate(v,M)}almostEqualBearing(v,M){return void 0===v&&void 0===M||void 0!==v&&void 0!==M&&v.isAlmostEqualNoPeriodShift(M)}isAlmostEqual(v){return!!(v&&this.almostEqualCoordinate(this.radius0,v.radius0)&&this.almostEqualCoordinate(this.radius1,v.radius1)&&this.almostEqualBearing(this.bearing0,v.bearing0)&&this.almostEqualBearing(this.bearing1,v.bearing1)&&this.almostEqualCoordinate(this.curveLength,v.curveLength))}applyScaleFactor(v){void 0!==this.radius0&&(this.radius0*=v),void 0!==this.radius1&&(this.radius1*=v),void 0!==this.curveLength&&(this.curveLength*=v)}static areAlmostEqual(v,M){return void 0===v?void 0===M:v.isAlmostEqual(M)}}class _n extends dn{get activeStrokes(){return void 0!==this._activeStrokes?this._activeStrokes:this._globalStrokes}constructor(v,M,b,E,D,X,z,R){super(v,X,D,R),this.curvePrimitiveType="transitionSpiral",this._evaluator=M,this.radius01=b,this.bearing01=E,this._arcLength01=z,this._globalStrokes=ke.create(),this._curvature01=We.create(0,1),this.refreshComputedProperties()}globalFractionToBearingRadians(v){const M=this._evaluator.fractionToArea(v),b=this._arcLength01;return this.bearing01.startRadians+M*b*this._curvature01.signedDelta()+v*this._curvature01.x0*b}globalFractionToCurvature(v){const M=this._evaluator.fractionToCurvatureFraction(v);return this._curvature01.fractionToPoint(M)}fractionToBearingRadians(v){const M=this.activeFractionInterval.fractionToPoint(v);return this.bearing01.startRadians+M*this._arcLength01*(this._curvature01.x0+.5*M*(this._curvature01.x1-this._curvature01.x0))}fractionToCurvature(v){return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(v))}static initWorkSpace(){_n._gaussFraction=new Float64Array(5),_n._gaussWeight=new Float64Array(5),_n._gaussMapper=(v,M,b,E)=>se.setupGauss5(v,M,b,E)}fullSpiralIncrementalIntegral(v,M,b,E){const D=_n._gaussFraction,X=_n._gaussWeight,z=_n._gaussMapper(M,b,D,X),R=this._arcLength01;let O=0,Y=0,N=0;for(let B=0;B<z;B++){const v=this.globalFractionToBearingRadians(D[B]);O=X[B]*R,Y+=O*Math.cos(v),N+=O*Math.sin(v)}E?xt.xyzPlusMatrixTimesXYZ(v,this.localToWorld.matrix,{x:Y,y:N,z:0},v):v.addXYZInPlace(Y,N,0)}refreshComputedProperties(){this._curvature01=We.create(dn.radiusToCurvature(this.radius01.x0),dn.radiusToCurvature(this.radius01.x1)),this._globalStrokes.clear();const v=Q.create();this._globalStrokes.appendStrokePoint(v);const M=1/16;for(let b=1;b<=16;b++){const E=(b-1)*M,D=b*M;this.fullSpiralIncrementalIntegral(v,E,D,!1),this._globalStrokes.appendStrokePoint(v)}if(this._globalStrokes.tryTransformInPlace(this.localToWorld),!this.activeFractionInterval.isExact01){void 0===this._activeStrokes&&(this._activeStrokes=ke.create()),this._activeStrokes.clear();for(let v=0;v<=16;v++){const b=v*M;this._activeStrokes.addPoint(this.fractionToPoint(b))}}}static createRadiusRadiusBearingBearing(v,M,b,E,D){const X=dn.radiusRadiusSweepRadiansToArcLength(v.x0,v.x1,M.sweepRadians);void 0===D&&(D="clothoid");const z=un.findEvaluator(D);if(z)return new _n(D,z,v.clone(),M.clone(),b.clone(),E.clone(),X,new yn(v.x0,v.x1,M.startAngle.clone(),M.endAngle.clone(),void 0))}static createFrom4OutOf5(v,M,b,E,D,X,z,R){void 0===v&&(v="clothoid");const O=un.findEvaluator(v);if(!O)return;const Y=new yn(M,b,E,D,X),N=Y.clone();return Y.tryResolveAnySingleUnknown()?(void 0===z&&(z=We.create(0,1)),new _n(v,O,We.create(Y.radius0,Y.radius1),It.createStartEnd(Y.bearing0,Y.bearing1),z?z.clone():We.create(0,1),R,Y.curveLength,N)):void 0}setFrom(v){return this.localToWorld.setFrom(v.localToWorld),this.radius01.setFrom(v.radius01),this._curvature01.setFrom(v._curvature01),this.bearing01.setFrom(v.bearing01),this.localToWorld.setFrom(v.localToWorld),this.activeFractionInterval.setFrom(v.activeFractionInterval),this._arcLength01=v._arcLength01,this}clone(){return new _n(this._spiralType,this._evaluator,this.radius01.clone(),this.bearing01.clone(),this.activeFractionInterval.clone(),this.localToWorld.clone(),this._arcLength01,this._designProperties?.clone())}tryTransformInPlace(v){const M=this.applyRigidPartOfTransform(v);return void 0!==M&&(this._curvature01.x0/=M.scale,this._curvature01.x1/=M.scale,this.radius01.x0*=M.scale,this.radius01.x1*=M.scale,this._arcLength01*=M.scale),this.refreshComputedProperties(),!0}startPoint(){return this.activeStrokes.startPoint()}endPoint(){return this.activeStrokes.endPoint()}isInPlane(v){return v.isPointInPlane(this.localToWorld.origin)&&K.isSameCoordinate(0,this.localToWorld.matrix.dotColumnX(v.getNormalRef()))&&K.isSameCoordinate(0,this.localToWorld.matrix.dotColumnY(v.getNormalRef()))}quickLength(){return this.curveLength()}curveLength(){return this._arcLength01*this._activeFractionInterval.absoluteDelta()}curveLengthBetweenFractions(v,M){return this._arcLength01*(this._activeFractionInterval.absoluteDelta()*Math.abs(M-v))}isSameGeometryClass(v){return v instanceof dn}emitStrokes(v,M){this.activeStrokes.emitStrokes(v,M)}emitStrokableParts(v,M){const b=this.computeStrokeCountForOptions(M);v.startParentCurvePrimitive(this);const E=this.activeStrokes;(void 0===v.needPrimaryGeometryForStrokes||!v.needPrimaryGeometryForStrokes())&&b<=E.numPoints()?this.activeStrokes.emitStrokableParts(v,M):v.announceIntervalForUniformStepStrokes(this,b,0,1),v.endParentCurvePrimitive(this)}computeStrokeCountForOptions(v){let M;if(v){const b=Math.min(Math.abs(this.radius01.x0),Math.abs(this.radius01.x1));M=v.applyTolerancesToArc(b,this.bearing01.sweepRadians),M=v.applyMaxEdgeLength(M,this.curveLength()),M=v.applyMinStrokesPerPrimitive(M)}else M=Ie.applyAngleTol(void 0,4,this.bearing01.sweepRadians);return M}reverseInPlace(){this.activeFractionInterval.reverseInPlace(),void 0===this._activeStrokes&&(this._activeStrokes=this._globalStrokes.clone()),this._activeStrokes.reverseInPlace()}fractionToPoint(v,M){const b=this.activeFractionInterval.fractionToPoint(v),E=this._globalStrokes.packedPoints.length-1;if(v>1){M=this._globalStrokes.packedPoints.back(M);const v=1/E;let D=1,X=D+v;for(;X<b;)this.fullSpiralIncrementalIntegral(M,D,X,!0),D=X,X+=v;this.fullSpiralIncrementalIntegral(M,D,b,!0)}else if(v<0){M=this._globalStrokes.packedPoints.front(M);const v=1/E;let D=0,X=D-v;for(;X>b;)this.fullSpiralIncrementalIntegral(M,D,X,!0),D=X,X-=v;this.fullSpiralIncrementalIntegral(M,D,b,!0)}else{const v=K.clampToStartEnd(b,0,1),D=Math.trunc(v*E),X=D/E;M=this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(D,M),this.fullSpiralIncrementalIntegral(M,X,b,!0)}return M}fractionToPointAndDerivative(v,M){const b=this.activeFractionInterval.fractionToPoint(v);M=M||Mt.createZero(),this.fractionToPoint(v,M.origin);const E=this.globalFractionToBearingRadians(b),D=this._arcLength01*this.activeFractionInterval.signedDelta();return this.localToWorld.matrix.multiplyXY(D*Math.cos(E),D*Math.sin(E),M.direction),M}fractionToFrenetFrame(v,M){const b=this.activeFractionInterval.fractionToPoint(v);(M=M||pt.createIdentity()).origin.setFrom(this.fractionToPoint(v)),xt.createRigidFromMatrix3d(this.localToWorld.matrix,z.XYZ,M.matrix);const E=this.globalFractionToBearingRadians(b),D=Math.cos(E),X=Math.sin(E);return M.matrix.applyGivensColumnOp(0,1,D,X),M}fractionToPointAnd2Derivatives(v,M){const b=this.activeFractionInterval.fractionToPoint(v),E=this.fractionToPoint(v),D=this.globalFractionToBearingRadians(b),X=Math.cos(D),z=Math.sin(D),R=this.activeFractionInterval.signedDelta(),O=R,Y=O*R,N=this.localToWorld.matrix.multiplyXY(O*X,O*z),B=this.localToWorld.matrix.multiplyXY(-Y*z,Y*X);return B.scaleInPlace(this.globalFractionToCurvature(b)),bt.createCapture(E,N,B,M)}dispatchToGeometryHandler(v){return v.handleTransitionSpiral(this)}isAlmostEqual(v){return v instanceof _n&&this.radius01.isAlmostEqual(v.radius01)&&this.bearing01.isAlmostEqualAllowPeriodShift(v.bearing01)&&this.localToWorld.isAlmostEqual(v.localToWorld)&&K.isSameCoordinate(this._arcLength01,v._arcLength01)&&this.activeFractionInterval.isAlmostEqual(v.activeFractionInterval)&&this._curvature01.isAlmostEqual(v._curvature01)}}_n.defaultSpiralType="clothoid",_n.initWorkSpace(),function(v){v[v.Sections=0]="Sections",v[v.AlsoRuledSweep=1]="AlsoRuledSweep",v[v.AlsoMesh=2]="AlsoMesh"}(io||(io={}));class vn{static addPartialSegment(v,M,b,E,D,X){(M||X>D)&&(void 0===b||void 0===E||K.isAlmostEqualNumber(D,X)||v.tryAddChild(we.create(b.interpolate(D,E),b.interpolate(X,E))))}static createArcPointTangentPoint(v,M,b){const E=$.createStartEnd(v,b),D=xt.createRigidFromColumns(M,E,z.XYZ);if(void 0!==D){const b=E.dotProduct(E),X=D.dotColumnY(E),z=K.conditionalDivideCoordinate(b,2*X);if(void 0!==z){const b=D.columnY();b.scaleInPlace(-z);const X=D.columnX();X.scaleInPlace(z);const R=b.plus(E);let O=b.angleTo(R).radians;M.dotProduct(R)<0&&(O=2*Math.PI-O);const Y=v.plusScaled(b,-1);return ti.create(Y,b,X,It.createStartEndRadians(0,O))}}}static createFilletsInLineString(v,M,b=!0){if(Array.isArray(v))return this.createFilletsInLineString(new ae(v),M,b);if(v instanceof ke)return this.createFilletsInLineString(v.packedPoints,M,b);const E=v.length;if(E<=1)return;const D=v.getPoint3dAtCheckedPointIndex(0),X=v.getPoint3dAtCheckedPointIndex(1),z=[];z.push({fraction10:0,fraction12:0,point:D.clone()});for(let O=1;O+1<E;O++){const b=v.getPoint3dAtCheckedPointIndex(O+1);let E=0;Array.isArray(M)?O<M.length&&(E=M[O]):Number.isFinite(M)&&(E=M),0!==E?z.push(ti.createFilletArc(D,X,b,E)):z.push({fraction10:0,fraction12:0,point:X.clone()}),D.setFromPoint3d(X),X.setFromPoint3d(b)}if(z.push({fraction10:0,fraction12:0,point:X.clone()}),!b)for(let O=1;O+1<E;O++){const v=z[O];(v.fraction10>1||v.fraction12>1||1-v.fraction10<z[O-1].fraction12||v.fraction12>1-z[O+1].fraction10)&&(v.fraction10=0,v.fraction12=0,z[O].arc=void 0)}const R=Ve.create();this.addPartialSegment(R,b,z[0].point,z[1].point,z[0].fraction12,1-z[1].fraction10);for(let O=1;O+1<v.length;O++){const v=z[O],M=z[O+1];R.tryAddChild(v.arc),this.addPartialSegment(R,b,v.point,M.point,v.fraction12,1-M.fraction10)}return R}static createRectangleXY(v,M,b,E,D=0,X){let z=K.correctSmallMetricDistance(X);const R=Math.min(v,b),O=Math.max(v,b),Y=Math.min(M,E),N=Math.max(M,E);if(z=Math.min(Math.abs(z),.5*(O-R),.5*(N-Y)),0===z)return Oe.createPolygon([Q.create(R,Y,D),Q.create(O,Y,D),Q.create(O,N,D),Q.create(R,N,D),Q.create(R,Y,D)]);{const v=$.create(z,0,0),M=$.create(0,z,0),b=R+z,E=Y+z,X=O-z,B=N-z,V=[Q.create(X,B,D),Q.create(b,B,D),Q.create(b,E,D),Q.create(X,E,D)],L=Oe.create();for(let D=0;D<4;D++){const b=V[D],E=V[(D+1)%4],X=$.createStartEnd(b,E),z=ti.create(b,v,M,It.createStartEndDegrees(0,90));L.tryAddChild(z);const R=z.endPoint();X.isAlmostZero||L.tryAddChild(we.create(R,R.plus(X))),v.rotate90CCWXY(v),M.rotate90CCWXY(M)}return L}}static appendToArcInPlace(v,M,b=!1){if(v.center.isAlmostEqual(M.center)){const E=K.split3WaySign(v.sweep.sweepRadians*M.sweep.sweepRadians,-1,0,1),D=v.angleToPointAndDerivative(v.sweep.fractionToAngle(1));v.sweep.sweepRadians<0&&D.direction.scaleInPlace(-1);const X=M.angleToPointAndDerivative(M.sweep.fractionToAngle(0));if(M.sweep.sweepRadians<0&&X.direction.scaleInPlace(-1),D.isAlmostEqual(X))return v.sweep.setStartEndRadians(v.sweep.startRadians,v.sweep.startRadians+v.sweep.sweepRadians+E*M.sweep.sweepRadians),!0;if(b&&(X.direction.scaleInPlace(-1),D.isAlmostEqual(X)))return v.sweep.setStartEndRadians(v.sweep.startRadians,v.sweep.startRadians+v.sweep.sweepRadians-E*M.sweep.sweepRadians),!0}return!1}static assembleArcChainOnEllipsoid(v,M,b=.5){const E=Ve.create();for(let D=0;D+1<M.length;D++){const X=v.sectionArcWithIntermediateNormal(M[D].toAngles(),b,M[D+1].toAngles());E.tryAddChild(X)}return E}static appendGeometryQueryArray(v,M){if(v instanceof Nt)M.push(v);else if(Array.isArray(v))for(const b of v)this.appendGeometryQueryArray(b,M)}static createPipeSegments(v,M){if(v instanceof we)return ci.createAxisPoints(v.startPoint(),v.endPoint(),M,M,!1);if(v instanceof ti)return ln.createAlongArc(v,M,!1);if(v instanceof oe){const b=On.create();return b.addMiteredPipes(v,M),b.claimPolyface()}if(v instanceof Ne){const b=[];for(const E of v.children){const v=this.createPipeSegments(E,M);this.appendGeometryQueryArray(v,b)}return b}}static createMiteredPipeSections(v,M){const b=[];if(v.length<2)return[];const E=$.create(),D=$.create(),X=$.create(),R=Q.create();let O;if(v.vectorIndexIndex(0,1,X),v.getPoint3dAtUncheckedPointIndex(0,R),M instanceof ti)O=M.clone(),O.center.setFrom(R),E.setFrom(M.vector0),D.setFrom(M.vector90);else{if("number"!=typeof M&&!Q.isXAndY(M))return[];{const v="number"==typeof M?M:M.x,b="number"==typeof M?M:M.y,Y=xt.createRigidHeadsUp(X,z.ZXY);Y.columnX(E).scaleInPlace(v),Y.columnY(D).scaleInPlace(b),O=ti.create(R,E,D,It.create360())}}b.push(O);const Y=$.create(),N=$.create();for(let z=1;z<v.length;z++)Y.setFromVector3d(X),v.getPoint3dAtUncheckedPointIndex(z,R),z+1<v.length?v.vectorIndexIndex(z,z+1,X):X.setFromVector3d(Y),Y.normalizeInPlace()&&X.normalizeInPlace()&&(Y.interpolate(.5,X,N),Pn(E,Y,N,E),Pn(D,Y,N,D),b.push(ti.create(R,E,D,It.create360())));return b}static createMiteredSweepSections(v,M,b){const E={sections:[],planes:[]},D=oi.createBisectorPlanesForDistinctPoints(v,b.wrapIfPhysicallyClosed);if(void 0!==D&&D.length>1){const t=function(v,M,b,D){const X=$.createStartEnd(v.getOriginRef(),M.getOriginRef()),z=pt.createFlattenAlongVectorToPlane(X,b.getOriginRef(),b.getNormalRef());if(void 0===z)return D;const R=D.cloneTransformed(z);return void 0===R?D:(E.planes.push(b),E.sections.push(R),R)};let v=t(D[0],D[1],D[0],M);for(let M=1;M<D.length;M++)v=t(D[M-1],D[M],D[M],v);if(b.outputSelect){const v=hn.create(E.sections,b.capped??!1);if(v&&(E.ruledSweep=v,io.AlsoMesh===b.outputSelect)){const M=On.create(b.strokeOptions);M.addRuledSweep(v),E.mesh=M.claimPolyface()}}return E}}static createArcPointTangentRadius(v,M,b,E,D){void 0===E&&(E=$.unitZ());const X=E.unitCrossProduct(M);if(void 0===X)return;const z=v.plusScaled(X,b);X.scaleInPlace(-b);const R=M.scaleToLength(Math.abs(b));return ti.create(z,X,R,It.create(D))}static createLineSpiralSpiralLine(v,M,b,E){const D=$.createStartEnd(M,b),X=$.createStartEnd(b,E),z=D.magnitude(),O=Math.atan2(D.y,D.x),Y=D.angleToXY(X),N=.5*Y.radians,B=O+Y.radians,V=xt.createRotationAroundAxisIndex(R.Z,W.createRadians(O)),L=pt.createRefs(M.clone(),V),U=_n.createFrom4OutOf5(v,0,void 0,W.createRadians(0),W.createRadians(N),z,void 0,L);if(U){const X=O+N,Y=$.createPolar(1,W.createRadians(X)),V=Y.dotProductStartEnd(M,b)/Y.dotProductStartEnd(M,U.endPoint()),Sr=_n.createFrom4OutOf5(v,0,void 0,W.createRadians(0),W.createRadians(N),z*V,void 0,L),Cr=D.magnitude(),kr=$.createStartEnd(b,E);kr.scaleToLength(Cr,kr);const Fr=b.plus(kr),Xr=xt.createRotationAroundAxisIndex(R.Z,W.createRadians(B+Math.PI)),zr=pt.createRefs(Fr,Xr),Rr=_n.createFrom4OutOf5(v,0,-Sr.radius01.x1,W.zero(),void 0,Sr.curveLength(),We.create(1,0),zr);return[Sr,Rr]}}static createLineSpiralSpiralLineWithSpiralLength(v,M,b,E,D){const X=$.createStartEnd(M,b),z=$.createStartEnd(b,E),O=Math.atan2(X.y,X.x),Y=X.angleToXY(z),N=.5*Y.radians,B=.5*(Math.PI-Y.radians),V=Math.atan2(-z.y,-z.x),L=_n.createFrom4OutOf5(v,0,void 0,W.zero(),W.createRadians(N),D,void 0,pt.createIdentity());if(L){const X=L.fractionToPoint(1),z=M.distance(b),Y=E.distance(b),U=X.y/Math.tan(B),Sr=K.conditionalDivideFraction(z-U-X.x,z),Cr=K.conditionalDivideFraction(Y-U-X.x,Y);if(void 0!==Sr&&void 0!==Cr){const X=xt.createRotationAroundAxisIndex(R.Z,W.createRadians(O)),z=M.interpolate(Sr,b),Y=pt.createRefs(z,X),B=_n.createFrom4OutOf5(v,0,void 0,W.zero(),W.createRadians(N),D,void 0,Y),L=xt.createRotationAroundAxisIndex(R.Z,W.createRadians(V)),U=E.interpolate(Cr,b),kr=pt.createRefs(U,L);return[B,_n.createFrom4OutOf5(v,0,void 0,W.zero(),W.createRadians(-N),D,void 0,kr)]}}}static createLineSpiralArcSpiralLine(v,M,b,E,D,X,z){const R=$.createStartEnd(M,b);R.z=0;const O=$.createStartEnd(E,b);O.z=0;const Y=R.normalize(),N=O.normalize();if(void 0===Y||void 0===N)return;const B=Y.unitPerpendicularXY(),V=N.unitPerpendicularXY(),L=R.angleToXY(O),U=K.split3WaySign(L.radians,1,-1,-1),Sr=-U,Cr=U*Math.abs(z),kr=Sr*Math.abs(z),Fr=_n.createFrom4OutOf5(v,0,Cr,W.zero(),void 0,D,void 0,pt.createIdentity()),Xr=_n.createFrom4OutOf5(v,0,kr,W.zero(),void 0,X,void 0,pt.createIdentity()),zr=Fr.fractionToPointAndUnitTangent(1),Rr=Xr.fractionToPointAndUnitTangent(1),Or=zr.origin.x-Cr*zr.direction.y,Yr=zr.origin.y+Cr*zr.direction.x,Nr=Rr.origin.x-kr*Rr.direction.y,Lr=Rr.origin.y+kr*Rr.direction.x,Kr=$.createAdd2Scaled(Y,Or,B,Yr),qr=$.createAdd2Scaled(N,Nr,V,Lr),Qr=J.create();if(Ft.linearSystem2d(Y.x,-N.x,Y.y,-N.y,qr.x-Kr.x,qr.y-Kr.y,Qr)){const v=b.plusScaled(Y,Qr.x),M=b.plusScaled(N,Qr.y),E=pt.createOriginAndMatrixColumns(v,Y,B,$.unitZ()),D=pt.createOriginAndMatrixColumns(M,N,V,$.unitZ());Fr.tryTransformInPlace(E),Xr.tryTransformInPlace(D);const X=Fr.fractionToPointAndUnitTangent(1),z=Xr.fractionToPointAndUnitTangent(1);z.direction.scaleInPlace(-1);const R=X.direction.angleToXY(z.direction);return Cr<0&&R.setRadians(-R.radians),[Fr,vn.createArcPointTangentRadius(X.origin,X.direction,Cr,void 0,R),Xr]}}static planePlaneIntersectionRay(v,M){const b=v.altitudeXYZ(0,0,0),E=M.altitudeXYZ(0,0,0),D=v.normalX(),X=v.normalY(),z=v.normalZ(),R=M.normalX(),O=M.normalY(),Y=M.normalZ(),N=K.crossProductXYXY(X,z,O,Y),B=K.crossProductXYXY(z,D,Y,R),V=K.crossProductXYXY(D,X,R,O),L=Ft.linearSystem3d(D,X,z,R,O,Y,N,B,V,-b,-E,0);if(void 0!==L)return Mt.createXYZUVW(L.x,L.y,L.z,N,B,V)}}function Pn(v,M,b,E){const D=v.dotProduct(b),X=M.dotProduct(b),z=K.safeDivideFraction(D,X,0);return v.plusScaled(M,-z,E)}class In extends Ze{constructor(v){super(),this._localPoint=Q.create(),this._worldPoint=Q.create(),this._perpVector=$.createZero(),this._maxDistance=0,this._localToWorld=v.toRigidZFrame()}announcePoint(v){this._localToWorld.multiplyInversePoint3d(v,this._localPoint);const M=this._localPoint.magnitudeXY();M>=this._maxDistance&&(this._maxDistance=M,this._perpVector.setFromPoint3d(this._localPoint),this._perpVector.z=0,this._localToWorld.matrix.multiplyXY(this._localPoint.x,this._localPoint.y,this._perpVector))}handleLineSegment3d(v){this.announcePoint(v.startPoint(this._worldPoint)),this.announcePoint(v.endPoint(this._worldPoint))}handleLineString3d(v){for(let M=0;M<v.numPoints();M++)v.pointAt(M,this._worldPoint),this.announcePoint(this._worldPoint)}handleArc3d(v){const M=Ie.applyAngleTol(void 0,3,v.sweep.sweepRadians,.1),b=1/M;for(let E=0;E<=M;E++)v.fractionToPoint(E*b,this._worldPoint),this.announcePoint(this._worldPoint)}static computeMaxVectorFromRay(v,M){const b=new In(v);return M.dispatchToGeometryHandler(b),b._perpVector.clone()}static buildRotationalNormalsInLineStrings(v,M,b){if(v instanceof ke){const E=v.packedPoints,D=v.packedDerivatives,X=v.ensureEmptySurfaceNormals();if(D&&X){const D=$.create(),z=$.create(),R=Q.create(),O=E.length;for(let Y=0;Y<O;Y++)E.getPoint3dAtUncheckedPointIndex(Y,R),M.perpendicularPartOfVectorToTarget(R,D),D.isAlmostZero?M.direction.crossProduct(b,z):M.direction.crossProduct(D,z),v.packedDerivatives.getVector3dAtCheckedVectorIndex(Y,D),D.crossProduct(z,z),z.normalizeInPlace(),X.push(z)}}else if(v.children){const E=v.children;for(const v of E)this.buildRotationalNormalsInLineStrings(v,M,b)}}}class An{startSweeps(v,M,b){return!0}endSweeps(v,M,b){return!0}}class Sn extends An{constructor(){super(),this.myMap=zt.createWithComponentIndex()}startPass(v){return 0===v?(this.myMap.numStroke=0,!0):1===v}visit(v,M){return 0===v?(M.numStroke>this.myMap.numStroke&&(this.myMap.numStroke=M.numStroke),!0):1===v&&(M.numStroke=this.myMap.numStroke,!0)}endPass(v){return!0}}class wn extends An{constructor(){super(),this.maxCurveLength=0}startPass(v){return 0===v?(this.maxCurveLength=0,!0):1===v}visit(v,M){return 0===v?(this.maxCurveLength=K.maxXY(M.curveLength,this.maxCurveLength),!0):1===v&&(M.a0=0,M.a1=this.maxCurveLength,!0)}endPass(v){return!0}}class Cn{constructor(v,M){this.parent=v,this.maps=[],this.options=M}static createForCurveChain(v,M){const b=new Cn(v,M);b.parent=v;for(const E of v.children)E.computeAndAttachRecursiveStrokeCounts(M),E.strokeData&&b.maps.push(E.strokeData);return b}getStrokes(){const v=ke.create();this.options&&(this.options.needNormals||this.options.needParams)&&(v.ensureEmptyFractions(),v.ensureEmptyDerivatives(),v.ensureEmptyUVParams());for(const M of this.maps)M.primitive&&M.primitive.addMappedStrokesToLineString3D(M,v);return v}static applySummed01LimitsWithinArray(v,M){let b=M;for(const E of v)E.a0+=b,E.componentData?E.a1=this.applySummed01LimitsWithinArray(E.componentData,E.a0):E.a1+=b,b=E.a1;return b}applySummed01Limits(v){return Cn.applySummed01LimitsWithinArray(this.maps,v)}}class Tn{constructor(v){this.parent=v,this.chains=[]}static createForParityRegionOrChain(v,M){const b=new Tn(v);if(v instanceof ii)for(const E of v.children){const v=Cn.createForCurveChain(E,M);b.chains.push(v)}else v instanceof Ne&&b.chains.push(Cn.createForCurveChain(v,M));return b}static areSectionsCompatible(v,M){if(v.length<2)return!0;const b=v[0].chains.length;for(let E=1;E<v.length;E++){if(v[E].chains.length!==b)return!1;for(let b=0;b<v[0].chains.length;b++){const D=v[0].chains[b].maps.length;if(v[E].chains[b].maps.length!==D)return!1;for(let X=0;X<D;X++)if(!v[0].chains[b].maps[X].isCompatibleComponentStructure(v[E].chains[b].maps[X],M))return!1}}return!0}static remapa0a1WithinEachChain(v){for(const M of v)for(const v of M.chains)v.applySummed01Limits(0)}static applyMultipassVisitorCallbackNoComponents(v,M,b,E,D){const X=v.length;if(!D.startSweeps(M,b,E))return!1;if(void 0===E)for(let z=0;D.startPass(z);z++){for(let E=0;E<X;E++)if(!D.visit(z,v[E].chains[M].maps[b]))return!1;if(!D.endPass(z))return!1}else for(let z=0;D.startPass(z);z++){for(let R=0;R<X;R++)if(!D.visit(z,v[R].chains[M].maps[b].componentData[E]))return!1;if(!D.endPass(z))return!1}return!!D.endSweeps(M,b,E)}static runMultiPassVisitorAtCorrespondingPrimitives(v,M){const b=v[0].chains.length;for(let E=0;E<b;E++){const b=v[0].chains[E].maps.length;for(let D=0;D<b;D++)if(v[0].chains[E].maps[D].componentData){const b=v[0].chains[E].maps[D].componentData.length;for(let X=0;X<b;X++)if(!this.applyMultipassVisitorCallbackNoComponents(v,E,D,X,M))return!1}else if(!this.applyMultipassVisitorCallbackNoComponents(v,E,D,void 0,M))return!1}return!0}static enforceStrokeCountCompatibility(v){if(v.length<2)return!0;if(!Tn.areSectionsCompatible(v,!1))return!1;const M=new Sn;return this.runMultiPassVisitorAtCorrespondingPrimitives(v,M),!0}static enforceCompatibleDistanceSums(v){if(v.length<2)return!0;if(!Tn.areSectionsCompatible(v,!1))return!1;const M=new wn;return this.runMultiPassVisitorAtCorrespondingPrimitives(v,M),this.remapa0a1WithinEachChain(v),!0}getStrokes(){if(1===this.chains.length)return this.chains[0].getStrokes();{const v=ii.create();for(const M of this.chains){const b=M.getStrokes();b instanceof ke&&v.tryAddChild(Oe.create(b))}return v}}static extendDistanceRangeBetweenStrokes(v,M,b){if(v instanceof ke){if(M instanceof ke&&v.numPoints()===M.numPoints()){const E=v.numPoints(),D=Q.create(),X=Q.create(),z=v.packedPoints,R=M.packedPoints;for(let v=0;v<E;v++)z.getPoint3dAtCheckedPointIndex(v,D),R.getPoint3dAtCheckedPointIndex(v,X),b.extendX(D.distance(X));return!0}}else if(v instanceof ii){if(M instanceof ii){const E=v.children,D=M.children,X=E.length;if(X===D.length){for(let v=0;v<X;v++)if(!this.extendDistanceRangeBetweenStrokes(E[v],D[v],b))return!1;return!0}}}else if(v instanceof Ne&&M instanceof Ne){const E=v.children,D=M.children,X=E.length;if(X===D.length){for(let v=0;v<X;v++)if(!this.extendDistanceRangeBetweenStrokes(E[v],D[v],b))return!1;return!0}}return!1}}class Fn{constructor(v,M,b){this.surface=v,this.point=b||Q.createZero(),this.uv=M||H.createZero(),this.a=0}static createSurfaceUVPoint(v,M,b){const E=new Fn(v);return M&&E.uv.setFrom(M),E.point.setFromPoint3d(b),E}static createSurfaceUVNumbersPoint(v,M,b,E){const D=new Fn(v);return D.uv.x=M,D.uv.y=b,D.point.setFromPoint3d(E),D}}class kn{constructor(v,M){this.curveDetail=v,this.surfaceDetail=M}}class Mn{constructor(v,M,b,E){this.point00=v,this.point10=M,this.point01=b,this.point11=E}static create(v,M,b,E){return new Mn(v.clone(),M.clone(),b.clone(),E.clone())}static createXYZ(v,M,b,E,D,X,z,R,O,Y,N,B){return new Mn(Q.create(v,M,b),Q.create(E,D,X),Q.create(z,R,O),Q.create(Y,N,B))}clone(){return new Mn(this.point00.clone(),this.point10.clone(),this.point01.clone(),this.point11.clone())}isAlmostEqual(v){return this.point00.isAlmostEqual(v.point00)&&this.point10.isAlmostEqual(v.point10)&&this.point01.isAlmostEqual(v.point01)&&this.point11.isAlmostEqual(v.point11)}tryTransformInPlace(v){return v.multiplyPoint3d(this.point00,this.point00),v.multiplyPoint3d(this.point10,this.point10),v.multiplyPoint3d(this.point01,this.point01),v.multiplyPoint3d(this.point11,this.point11),!0}cloneTransformed(v){const M=this.clone();return M.tryTransformInPlace(v),M}extendRange(v,M){M?(v.extendTransformedPoint(M,this.point00),v.extendTransformedPoint(M,this.point10),v.extendTransformedPoint(M,this.point01),v.extendTransformedPoint(M,this.point11)):(v.extendPoint(this.point00),v.extendPoint(this.point10),v.extendPoint(this.point01),v.extendPoint(this.point11))}uvFractionToPoint(v,M,b){const E=(1-v)*(1-M),D=v*(1-M),X=(1-v)*M,z=v*M;return Q.create(E*this.point00.x+D*this.point10.x+X*this.point01.x+z*this.point11.x,E*this.point00.y+D*this.point10.y+X*this.point01.y+z*this.point11.y,E*this.point00.z+D*this.point10.z+X*this.point01.z+z*this.point11.z,b)}uvFractionToPointAndTangents(v,M,b){const E=1-v,D=1-M,X=E*D,z=v*D,R=E*M,O=v*M;return bt.createOriginAndVectorsXYZ(X*this.point00.x+z*this.point10.x+R*this.point01.x+O*this.point11.x,X*this.point00.y+z*this.point10.y+R*this.point01.y+O*this.point11.y,X*this.point00.z+z*this.point10.z+R*this.point01.z+O*this.point11.z,D*(this.point10.x-this.point00.x)+M*(this.point11.x-this.point01.x),D*(this.point10.y-this.point00.y)+M*(this.point11.y-this.point01.y),D*(this.point10.z-this.point00.z)+M*(this.point11.z-this.point01.z),E*(this.point01.x-this.point00.x)+v*(this.point11.x-this.point10.x),E*(this.point01.y-this.point00.y)+v*(this.point11.y-this.point10.y),E*(this.point01.z-this.point00.z)+v*(this.point11.z-this.point10.z),b)}static conditionalPivot(v,M,b,E){if(Math.abs(M[E][v])>Math.abs(M[b][v])){const v=M[b];M[b]=M[E],M[E]=v}}intersectRay(v){const M=this.point10.minus(this.point00),b=this.point01.minus(this.point00),E=this.point11.minus(this.point10);E.subtractInPlace(b);const D=[new Float64Array([-v.direction.x,this.point00.x-v.origin.x,M.x,b.x,E.x]),new Float64Array([-v.direction.y,this.point00.y-v.origin.y,M.y,b.y,E.y]),new Float64Array([-v.direction.z,this.point00.z-v.origin.z,M.z,b.z,E.z])];Mn.conditionalPivot(0,D,0,1),Mn.conditionalPivot(0,D,0,2),Ft.eliminateFromPivot(D[0],0,D[1],-1),Ft.eliminateFromPivot(D[0],0,D[2],-1);const X=Ft.solveBilinearPair(D[1][1],D[1][2],D[1][3],D[1][4],D[2][1],D[2][2],D[2][3],D[2][4]);if(X){const M=[];for(const b of X){const E=-(D[0][1]+D[0][2]*b.x+(D[0][3]+D[0][4]*b.x)*b.y)/D[0][0],X=v.fractionToPoint(E);M.push(new kn(vt.createRayFractionPoint(v,E,X),Fn.createSurfaceUVPoint(this,b,X)))}return M}}maxUEdgeLength(){return K.maxXY(this.point00.distance(this.point10),this.point01.distance(this.point11))}maxVEdgeLength(){return K.maxXY(this.point00.distance(this.point01),this.point10.distance(this.point11))}}class bn{static sampledRangeOfOffsetPatch(v,M,b,E){const D=ut.createNull(),X=1/(b=Math.ceil(K.clamp(b,2,500))),z=1/(E=Math.ceil(K.clamp(E,2,500))),R=Q.create(),O=bt.createXYPlane();let Y,N;for(let B=0;B<=E;B++){N=B*z;for(let E=0;E<=b;E++)if(Y=E*X,void 0!==M){v.uvFractionToPointAndTangents(Y,N,O);const b=O.unitNormal();void 0!==b&&(O.origin.addScaledInPlace(b,M),D.extend(O.origin))}else v.uvFractionToPoint(Y,N,R),D.extendXYZ(R.x,R.y,R.z)}return D}static sampledRangeOfOffsetEllipsoidPatch(v,M,b){const E=Ie.applyAngleTol(b,2,v.latitudeSweep.sweepRadians,W.degreesToRadians(5)),D=Ie.applyAngleTol(b,2,v.longitudeSweep.sweepRadians,W.degreesToRadians(5));return this.sampledRangeOfOffsetPatch(v,M,E,D)}constructor(){}static createLinestringOnUVLine(v,M,b,E,D,X,z=!1,R=!1){const O=ke.create(),Y=Q.create();let N,B,V;const L=X+1;for(let U=0;U<L;U++)N=U/X,B=K.interpolate(M,N,E),V=K.interpolate(b,N,D),v.uvFractionToPoint(B,V,Y),O.addPoint(Y),z&&O.addUVParamAsUV(B,V),R&&O.addFraction(N);return O}}class En{static pointsClone(){const v=[];for(const M of this.points)v.push(M.clone());return v}}En.points=[Q.create(0,0,0),Q.create(1,0,0),Q.create(0,1,0),Q.create(1,1,0),Q.create(0,0,1),Q.create(1,0,1),Q.create(0,1,1),Q.create(1,1,1)],En.primaryCapId=-1,En.cornerIndexCCW=[[1,0,2,3],[4,5,7,6],[0,1,5,4],[1,3,7,5],[3,2,6,7],[2,0,4,6]],En.partnerFace=[[5,4,3,2],[2,3,4,5],[0,3,1,5],[0,4,1,2],[0,5,1,3],[0,2,1,4]],En.faceId=[[En.primaryCapId,0],[En.primaryCapId,1],[0,0],[0,1],[0,2],[0,3]],En.faceDirections=[[[0,1,2],[-1,1,-1]],[[0,1,2],[1,1,1]],[[0,2,1],[1,-1,1]],[[1,2,0],[1,1,1]],[[0,2,1],[-1,1,1]],[[1,2,0],[-1,1,-1]]],En.axisEdgeVertex=[[[0,1],[2,3],[4,5],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,4],[1,5],[2,6],[3,7]]];class Dn{constructor(v,M,b){this.points=v,this.begin=M,this.end=b}static createComplete(v){return new this(v,0,v.length)}static createBeginEnd(v,M,b){return new this(v,M,b)}static createBeginLength(v,M,b){return new this(v,M,M+b)}advanceBegin(){return this.begin++,this.begin<this.end}advanceEnd(){return this.end++,this.end>this.points.length&&(this.end=this.points.length),this.begin<this.end}localIndexToParentIndex(v){if(v>=0){const M=this.begin+v;if(M<this.points.length)return M}}get isValidSubset(){return 0===this.length||void 0!==this.localIndexToParentIndex(0)&&void 0!==this.localIndexToParentIndex(this.length-1)}restrictEnd(){this.end>this.points.length&&(this.end=this.points.length)}get isNonEmpty(){return this.begin<this.end}advanceToTail(v){return this.begin=v.end-1,this.isNonEmpty}advanceToHead(v){return this.begin=v.begin,this.isNonEmpty}setFrom(v,M,b){this.points=v.points,this.begin=void 0===M?v.begin:M,this.end=void 0===b?v.end:b,this.restrictEnd()}get length(){return this.end>this.begin?this.end-this.begin:0}get isSingleton(){return this.begin+1===this.end}}class Xn extends Dn{}class Rn extends Vi{constructor(v,M,b,E,D,X){super(v,M,b),this._isValid=X,this._quality=D,this.id=E}setFrom(v){return super.setFrom(v),this._isValid=v._isValid,this._quality=v._quality,this.id=v.id,this}static createFromIndexedXYZ(v,M,b,E,D,X,z,R){R||(R=new Rn(Q.create(),Q.create(),Q.create(),z,0,!1)),R.id=z;let O=0;return void 0!==v.getPoint3dAtCheckedPointIndex(M,R.points[0])&&O++,void 0!==b.getPoint3dAtCheckedPointIndex(E,R.points[1])&&O++,void 0!==D.getPoint3dAtCheckedPointIndex(X,R.points[2])&&O++,3===O?R.updateAspectRatio():R.markInvalid(),R}get isValid(){return this._isValid}markInvalid(v){this._isValid=!1,void 0!==v&&(this._quality=v)}updateAspectRatio(){this._quality=super.aspectRatio,this._isValid=this._quality>0}clone(v){return v?v.setFrom(this):new Rn(this.points[0].clone(),this.points[1].clone(),this.points[2].clone(),this.id,this._quality,this._isValid)}static copyWithLowerQuality(v,M,b){if(b=v.clone(b),M.isValid){const E=v.dotProductOfCrossProductsFromOrigin(M);b._quality=K.minXY(v.aspectRatio,M.aspectRatio),E<0&&(b._quality-=1)}return b}static updateIfOtherHasHigherQuality(v,M){M.isValid&&M._quality>v._quality&&v.setFrom(M)}}class zn{constructor(v){this._turnRadians=v,this._xyzA=Q.create(),this._xyzB=Q.create(),this._forwardA=$.create(),this._forwardB=$.create(),this._vector1=$.create(),this._crossA=$.create(),this._crossB=$.create()}isForwardVector(v,M,b){if(v.dotProduct(M)<=0)return!1;const E=v.angleFromPerpendicular(b);return!(Math.abs(E.radians)>this._turnRadians)}isPlanarBase(v,M,b,E,D,X,z,R,O,Y){return M+1<v.length&&E+1<b.length&&(v.getPoint3dAtUncheckedPointIndex(M,D),b.getPoint3dAtUncheckedPointIndex(E,R),v.vectorXYAndZIndex(D,M+1,z),b.vectorXYAndZIndex(R,E+1,Y),$.createStartEnd(D,R,this._vector1),this._vector1.crossProduct(z,X),this._vector1.crossProduct(Y,O),!D.isAlmostEqual(R)&&X.angleTo(O).radians<this._turnRadians)}advanceToPlanarLimit(v,M,b,E,D,X,z,R){for(M.setFrom(v,v.begin,b);M.end<v.end&&(M.points.vectorXYAndZIndex(E,M.end,this._vector1),this.isForwardVector(this._vector1,X,D))&&this.isForwardVector(this._vector1,R,z)&&(!(M.end>0)||(M.points.vectorIndexIndex(M.end-1,M.end,this._vector1),this.isForwardVector(this._vector1,X,D)));)M.end++}addGreedy(v,M,b,E=!1){for(v.restrictEnd(),M.restrictEnd();v.length>1&&M.length>1;)if(this._triangleA1=Rn.createFromIndexedXYZ(v.points,v.begin,v.points,v.begin+1,M.points,M.begin,1,this._triangleA1),this._triangleA2=Rn.createFromIndexedXYZ(v.points,v.begin+1,v.points,v.begin+2,M.points,M.begin,2,this._triangleA2),this._triangleA3=Rn.createFromIndexedXYZ(v.points,v.begin,v.points,v.begin+1,M.points,M.begin+1,3,this._triangleA3),this._triangleB1=Rn.createFromIndexedXYZ(M.points,M.begin+1,M.points,M.begin,v.points,v.begin,-1,this._triangleB1),this._triangleB2=Rn.createFromIndexedXYZ(M.points,M.begin+2,M.points,M.begin+1,v.points,v.begin,-2,this._triangleB2),this._triangleB3=Rn.createFromIndexedXYZ(M.points,M.begin+1,M.points,M.begin,v.points,v.begin+1,-3,this._triangleB3),this._bestTriangle=Rn.copyWithLowerQuality(this._triangleA1,this._triangleB3,this._bestTriangle),this._workTriangle=Rn.copyWithLowerQuality(this._triangleB1,this._triangleA3,this._workTriangle),Rn.updateIfOtherHasHigherQuality(this._bestTriangle,this._workTriangle),this._bestTriangle.id>0){if(v.advanceBegin(),b(this._bestTriangle),E)return}else if(M.advanceBegin(),b(this._bestTriangle),E)return;if(v.isSingleton)for(;M.length>=2;)this._workTriangle=Rn.createFromIndexedXYZ(M.points,M.begin+1,M.points,M.begin,v.points,v.begin,0,this._workTriangle),b(this._workTriangle),M.advanceBegin();if(M.isSingleton)for(;v.length>=2;)this._workTriangle=Rn.createFromIndexedXYZ(v.points,v.begin,v.points,v.begin+1,M.points,M.begin,0,this._workTriangle),b(this._workTriangle),v.advanceBegin()}emitTriangles(v,M,b){this.emitTrianglesGo(Nn(v),Nn(M),b)}emitTrianglesGo(v,M,b){const E=Xn.createComplete(v),D=Xn.createComplete(M),X=Xn.createComplete(v),z=Xn.createComplete(M);for(;E.length>0&&D.length>0&&(E.length>1||D.length>1);)this.isPlanarBase(v,E.begin,M,D.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(this.advanceToPlanarLimit(E,X,E.begin+1,this._xyzA,this._crossA,this._forwardA,this._crossB,this._forwardB),this.advanceToPlanarLimit(D,z,D.begin+1,this._xyzB,this._crossB,this._forwardB,this._crossA,this._forwardA),this.addGreedy(X,z,b),E.advanceToTail(X),D.advanceToTail(z)):this.isPlanarBase(v,E.begin+1,M,D.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(X.setFrom(E,E.begin,E.begin+2),z.setFrom(D,D.begin,D.begin+1),this.addGreedy(X,z,b),E.advanceToTail(X),D.advanceToTail(z)):this.isPlanarBase(v,E.begin,M,D.begin+1,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(X.setFrom(E,E.begin,E.begin+1),z.setFrom(D,D.begin,D.begin+2),this.addGreedy(X,z,b),E.advanceToTail(X),D.advanceToTail(z)):E.length>1&&D.length>1?(X.setFrom(E,E.begin,E.begin+2),z.setFrom(D,D.begin,D.begin+2),this.addGreedy(X,z,b,!0),E.advanceToHead(X),D.advanceToHead(z)):E.length>1?(X.setFrom(E,E.begin,E.begin+2),z.setFrom(D),this.addGreedy(X,z,b),E.advanceToTail(X),D.advanceToTail(z)):D.length>1&&(X.setFrom(E),z.setFrom(D,D.begin,D.begin+2),this.addGreedy(X,z,b),E.advanceToTail(X),D.advanceToTail(z));this.addGreedy(E,D,b)}static createContext(v=this.defaultNearColinearAngle){return new zn(v.radians)}}function Nn(v,M=K.smallMetricDistance){let b=!1;const E=v.length;for(let z=0;z+1<E;z++)if(v.distanceIndexIndex(z,z+1)<=M){b=!0;break}if(!b)return v;const D=new nt(E);D.pushXYZ(v.getXAtUncheckedPointIndex(0),v.getYAtUncheckedPointIndex(0),v.getZAtUncheckedPointIndex(0));let X=0;for(let z=1;z<E;z++)v.distanceIndexIndex(X,z)>M&&(D.pushXYZ(v.getXAtUncheckedPointIndex(z),v.getYAtUncheckedPointIndex(z),v.getZAtUncheckedPointIndex(z)),X=z);return v.distanceIndexIndex(0,E-1)<=M&&(D.pop(),D.pushFromGrowableXYZArray(D,0)),D}zn.defaultNearColinearAngle=W.createDegrees(15);class Yn{constructor(v=!1,M=!1,b=!1){this.xyz=Q.create(),this.normalIndex=-1,this.uvIndex=-1,this.xyzIndex=-1,v&&(this.normal=$.create()),M&&(this.uv=H.create(),this.uvIndex=-1),b&&(this.sectionDerivative=$.create())}copyContentsFrom(v){this.xyz.setFromPoint3d(v.xyz),this.xyzIndex=v.xyzIndex,this.normal&&this.normal.setFromVector3d(v.normal),this.normalIndex=v.normalIndex,this.uv&&this.uv.setFrom(v.uv),this.uvIndex=v.uvIndex,this.sectionDerivative&&this.sectionDerivative.setFrom(v.sectionDerivative)}loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(v,M,b,E,D){M.getPoint3dAtCheckedPointIndex(v,this.xyz),E&&void 0!==D&&(this.uv=H.create(E.atUncheckedIndex(v),D)),this.xyzIndex=-1,this.normalIndex=-1,this.uvIndex=-1,void 0!==this.sectionDerivative&&void 0!==b&&b.getVector3dAtCheckedVectorIndex(v,this.sectionDerivative)}static suppressSmallUnitVectorComponents(v){const M=K.smallFloatingPoint;Math.abs(v.x)<M&&(v.x=0),Math.abs(v.y)<M&&(v.y=0),Math.abs(v.z)<M&&(v.z=0)}static computeNormalsAlongRuleLine(v,M){if(v.sectionDerivative&&M.sectionDerivative){const b=Yn._edgeVector;$.createStartEnd(v.xyz,M.xyz,b),v.sectionDerivative.crossProduct(b,v.normal),M.sectionDerivative.crossProduct(b,M.normal),v.normal.normalizeInPlace(),M.normal.normalizeInPlace(),Yn.suppressSmallUnitVectorComponents(v.normal),Yn.suppressSmallUnitVectorComponents(M.normal)}}}Yn._edgeVector=$.create();class On extends Ue{get options(){return this._options}get reversedFlag(){return this._reversed}claimPolyface(v=!0,M=K.smallMetricDistance){return v&&this._polyface.data.compress(M),this._polyface}toggleReversedFacetFlag(){this._reversed=!this._reversed}constructor(v){super(),this._options=v||Ie.createForFacets(),this._polyface=Ci.create(this._options.needNormals,this._options.needParams,this._options.needColors,this._options.needTwoSided),this._reversed=!1}static create(v){return new On(v)}addTransformedUnitBox(v){this.addTransformedRangeMesh(v,ut.createXYZXYZ(0,0,0,1,1,1))}addTransformedRangeMesh(v,M,b){const E=this._polyface.data.pointCount,D=M.corners();for(const z of D)this._polyface.addPoint(v.multiplyPoint3d(z));let X=0;for(const z of En.cornerIndexCCW){if(!b||X<b.length&&b[X]){const v=z.map((v=>v+E));this._reversed&&v.reverse(),this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(v[0],v[1],v[2],!1),this.addIndexedTrianglePointIndexes(v[0],v[2],v[3],!1)):this.addIndexedQuadPointIndexes(v[0],v[1],v[3],v[2],!1),this._polyface.terminateFacet()}X++}}addTriangleFan(v,M,b){const E=M.numPoints();if(E>2){b&&this.toggleReversedFacetFlag();const D=this.addPoint(v);let X=this.findOrAddPointInLineString(M,0),z=0;for(let v=1;v<E;v++)z=this.findOrAddPointInLineString(M,v),this.addIndexedTrianglePointIndexes(D,X,z),X=z;b&&this.toggleReversedFacetFlag()}}addTrianglesInUncheckedConvexPolygon(v,M){const b=v.numPoints();if(b>2){let E,D;M&&this.toggleReversedFacetFlag(),this._options.needNormals&&(E=v.quickUnitNormal(On._workVectorFindOrAdd),M&&E.scaleInPlace(-1),D=this._polyface.addNormal(E));const X=this._options.needParams?v.packedUVParams:void 0;let z=-1,R=-1,O=-1;X&&(z=this.addParamInGrowableXYArray(X,0),R=this.addParamInGrowableXYArray(X,1));const Y=this.findOrAddPointInLineString(v,0);let N=this.findOrAddPointInLineString(v,1),B=0,V=b;v.isPhysicallyClosed&&V--;for(let M=2;M<V;M++,N=B,R=O)B=this.findOrAddPointInLineString(v,M),this.addIndexedTrianglePointIndexes(Y,N,B,!1),void 0!==D&&this.addIndexedTriangleNormalIndexes(D,D,D),X&&(O=this.addParamInGrowableXYArray(X,M),this.addIndexedTriangleParamIndexes(z,R,O)),this._polyface.terminateFacet();M&&this.toggleReversedFacetFlag()}}addPoint(v){return this._polyface.addPoint(v)}findOrAddPoint(v){return this.addPoint(v)}addParamXY(v,M){return this._polyface.addParamUV(v,M)}findOrAddParamXY(v,M){return this.addParamXY(v,M)}findOrAddPointInLineString(v,M,b,E){const D=v.pointAt(M,On._workPointFindOrAddA);if(D)return b&&b.multiplyPoint3d(D,D),this._polyface.addPoint(D,E)}findOrAddPointInGrowableXYZArray(v,M,b,E){const D=v.getPoint3dAtCheckedPointIndex(M,On._workPointFindOrAddA);if(D)return b&&b.multiplyPoint3d(D,D),this._polyface.addPoint(D,E)}findOrAddNormalInGrowableXYZArray(v,M,b,E){const D=v.getVector3dAtCheckedVectorIndex(M,On._workVectorFindOrAdd);if(D)return b&&b.multiplyVector(D,D),this._polyface.addNormal(D,E)}addParamInGrowableXYArray(v,M){if(!v)return;const b=v.getPoint2dAtCheckedPointIndex(M,On._workUVFindOrAdd);return b?this._polyface.addParam(b):void 0}findOrAddParamInGrowableXYArray(v,M){return this.addParamInGrowableXYArray(v,M)}findOrAddParamInLineString(v,M,b,E,D){const X=v.fractions&&M<v.fractions.length?v.fractions.atUncheckedIndex(M):M/v.points.length;return this._polyface.addParamUV(X,b,E,D)}findOrAddNormalInLineString(v,M,b,E,D){const X=v.packedSurfaceNormals;if(X){const v=X.getVector3dAtCheckedVectorIndex(M,On._workVectorFindOrAdd);if(v)return b&&b.multiplyVector(v,v),this._polyface.addNormal(v,E,D)}}addPointXYZ(v,M,b){return this._polyface.addPointXYZ(v,M,b)}findOrAddPointXYZ(v,M,b){return this.addPointXYZ(v,M,b)}getUVTransformForTriangleFacet(v,M,b){const E=v.vectorTo(M),D=v.vectorTo(b),X=xt.createRigidFromColumns(E,D,z.XYZ);return pt.createOriginAndMatrix(v,X).inverse()}getNormalForTriangularFacet(v,M,b){const E=v.vectorTo(M),D=v.vectorTo(b);let X=E.crossProduct(D).normalize();return X=X||$.create(),X}addQuadFacet(v,M,b,E){v instanceof nt&&(v=v.getPoint3dArray());const D=this.options.needParams,X=this.options.needNormals,z=this.options.needColors;let R,O,Y,N,B,V,L,U,Sr,Cr,kr,Fr,Xr,zr,Rr,Or;if(D)if(void 0!==M&&M.length>3)R=M[0],O=M[1],Y=M[2],N=M[3];else{const M=this.getUVTransformForTriangleFacet(v[0],v[1],v[2]);void 0===M?R=O=Y=N=H.createZero():(R=H.createFrom(M.multiplyPoint3d(v[0])),O=H.createFrom(M.multiplyPoint3d(v[1])),Y=H.createFrom(M.multiplyPoint3d(v[2])),N=H.createFrom(M.multiplyPoint3d(v[3])))}if(X&&(void 0!==b&&b.length>3?(B=b[0],V=b[1],L=b[2],U=b[3]):(B=this.getNormalForTriangularFacet(v[0],v[1],v[2]),V=this.getNormalForTriangularFacet(v[0],v[1],v[2]),L=this.getNormalForTriangularFacet(v[0],v[1],v[2]),U=this.getNormalForTriangularFacet(v[0],v[1],v[2]))),z&&void 0!==E&&E.length>3&&(Sr=E[0],Cr=E[1],kr=E[2],Fr=E[3]),this._options.shouldTriangulate){const M=v[0].vectorTo(v[2]),b=v[1].vectorTo(v[3]);M.magnitude()>=b.magnitude()?(this.addTriangleFacet([v[0],v[1],v[2]],D?[R,O,Y]:void 0,X?[B,V,L]:void 0,z?[Sr,Cr,kr]:void 0),this.addTriangleFacet([v[0],v[2],v[3]],D?[R,Y,N]:void 0,X?[B,L,U]:void 0,z?[Sr,kr,Fr]:void 0)):(this.addTriangleFacet([v[0],v[1],v[3]],D?[R,O,N]:void 0,X?[B,V,U]:void 0,z?[Sr,Cr,Fr]:void 0),this.addTriangleFacet([v[1],v[2],v[3]],D?[O,Y,N]:void 0,X?[V,L,U]:void 0,z?[Cr,kr,Fr]:void 0))}else D&&(Xr=this._polyface.addParam(R),zr=this._polyface.addParam(O),Rr=this._polyface.addParam(Y),Or=this._polyface.addParam(N),this.addIndexedQuadParamIndexes(Xr,zr,Or,Rr)),X&&(Xr=this._polyface.addNormal(B),zr=this._polyface.addNormal(V),Rr=this._polyface.addNormal(L),Or=this._polyface.addNormal(U),this.addIndexedQuadNormalIndexes(Xr,zr,Or,Rr)),z&&(Xr=this._polyface.addColor(Sr),zr=this._polyface.addColor(Cr),Rr=this._polyface.addColor(kr),Or=this._polyface.addColor(Fr),this.addIndexedQuadColorIndexes(Xr,zr,Or,Rr)),Xr=this.addPoint(v[0]),zr=this.addPoint(v[1]),Rr=this.addPoint(v[2]),Or=this.addPoint(v[3]),this.addIndexedQuadPointIndexes(Xr,zr,Or,Rr)}addIndexedQuadPointIndexes(v,M,b,E,D=!0){this._reversed?(this._polyface.addPointIndex(v),this._polyface.addPointIndex(b),this._polyface.addPointIndex(E),this._polyface.addPointIndex(M)):(this._polyface.addPointIndex(v),this._polyface.addPointIndex(M),this._polyface.addPointIndex(E),this._polyface.addPointIndex(b)),D&&this._polyface.terminateFacet()}addIndexedQuadParamIndexes(v,M,b,E){this._reversed?(this._polyface.addParamIndex(v),this._polyface.addParamIndex(b),this._polyface.addParamIndex(E),this._polyface.addParamIndex(M)):(this._polyface.addParamIndex(v),this._polyface.addParamIndex(M),this._polyface.addParamIndex(E),this._polyface.addParamIndex(b))}addIndexedQuadNormalIndexes(v,M,b,E){this._reversed?(this._polyface.addNormalIndex(v),this._polyface.addNormalIndex(b),this._polyface.addNormalIndex(E),this._polyface.addNormalIndex(M)):(this._polyface.addNormalIndex(v),this._polyface.addNormalIndex(M),this._polyface.addNormalIndex(E),this._polyface.addNormalIndex(b))}addIndexedQuadColorIndexes(v,M,b,E){this._reversed?(this._polyface.addColorIndex(v),this._polyface.addColorIndex(b),this._polyface.addColorIndex(E),this._polyface.addColorIndex(M)):(this._polyface.addColorIndex(v),this._polyface.addColorIndex(M),this._polyface.addColorIndex(E),this._polyface.addColorIndex(b))}addTriangleFacet(v,M,b,E){if(v.length<3)return;let D,X,z,R,O,Y;if(v instanceof nt?(R=v.getPoint3dAtCheckedPointIndex(0),O=v.getPoint3dAtCheckedPointIndex(1),Y=v.getPoint3dAtCheckedPointIndex(2)):(R=v[0],O=v[1],Y=v[2]),this._options.needParams){if(M&&M.length>=3)D=this._polyface.addParam(M[0]),X=this._polyface.addParam(M[1]),z=this._polyface.addParam(M[2]);else{const v=this.getUVTransformForTriangleFacet(R,O,Y);D=this._polyface.addParam(H.createFrom(v?v.multiplyPoint3d(R):void 0)),X=this._polyface.addParam(H.createFrom(v?v.multiplyPoint3d(O):void 0)),z=this._polyface.addParam(H.createFrom(v?v.multiplyPoint3d(O):void 0))}this.addIndexedTriangleParamIndexes(D,X,z)}if(this._options.needNormals){if(void 0!==b&&b.length>2)D=this._polyface.addNormal(b[0]),X=this._polyface.addNormal(b[1]),z=this._polyface.addNormal(b[2]);else{const v=this.getNormalForTriangularFacet(R,O,Y);D=this._polyface.addNormal(v),X=this._polyface.addNormal(v),z=this._polyface.addNormal(v)}this.addIndexedTriangleNormalIndexes(D,X,z)}this._options.needColors&&void 0!==E&&E.length>2&&(D=this._polyface.addColor(E[0]),X=this._polyface.addColor(E[1]),z=this._polyface.addColor(E[2]),this.addIndexedTriangleColorIndexes(D,X,z)),D=this.addPoint(R),X=this.addPoint(O),z=this.addPoint(Y),this.addIndexedTrianglePointIndexes(D,X,z)}addIndexedTrianglePointIndexes(v,M,b,E=!0){this._reversed?(this._polyface.addPointIndex(v),this._polyface.addPointIndex(b),this._polyface.addPointIndex(M)):(this._polyface.addPointIndex(v),this._polyface.addPointIndex(M),this._polyface.addPointIndex(b)),E&&this._polyface.terminateFacet()}addIndexedTriangleParamIndexes(v,M,b){this._reversed?(this._polyface.addParamIndex(v),this._polyface.addParamIndex(b),this._polyface.addParamIndex(M)):(this._polyface.addParamIndex(v),this._polyface.addParamIndex(M),this._polyface.addParamIndex(b))}addIndexedTriangleNormalIndexes(v,M,b){this._reversed?(this._polyface.addNormalIndex(v),this._polyface.addNormalIndex(b),this._polyface.addNormalIndex(M)):(this._polyface.addNormalIndex(v),this._polyface.addNormalIndex(M),this._polyface.addNormalIndex(b))}addIndexedTriangleColorIndexes(v,M,b){this._reversed?(this._polyface.addColorIndex(v),this._polyface.addColorIndex(b),this._polyface.addColorIndex(M)):(this._polyface.addColorIndex(v),this._polyface.addColorIndex(M),this._polyface.addColorIndex(b))}setSectorIndices(v){v.xyzIndex=this.addPoint(v.xyz),v.normal&&(v.normalIndex=this._polyface.addNormal(v.normal)),v.uv&&(v.uvIndex=this._polyface.addParam(v.uv))}addSectorTriangle(v,M,b){v.xyz.isAlmostEqual(M.xyz)||M.xyz.isAlmostEqual(b.xyz)||b.xyz.isAlmostEqual(v.xyz)||(this._options.needNormals&&this.addIndexedTriangleNormalIndexes(v.normalIndex,M.normalIndex,b.normalIndex),this._options.needParams&&this.addIndexedTriangleParamIndexes(v.uvIndex,M.uvIndex,b.uvIndex),this.addIndexedTrianglePointIndexes(v.xyzIndex,M.xyzIndex,b.xyzIndex),this._polyface.terminateFacet())}addSectorQuadA01B01(v,M,b,E){v.xyz.isAlmostEqual(M.xyz)&&b.xyz.isAlmostEqual(E.xyz)||(this._options.shouldTriangulate?(this.addSectorTriangle(v,M,E),this.addSectorTriangle(E,b,v)):(this._options.needNormals&&this.addIndexedQuadNormalIndexes(v.normalIndex,M.normalIndex,b.normalIndex,E.normalIndex),this._options.needParams&&this.addIndexedQuadParamIndexes(v.uvIndex,M.uvIndex,b.uvIndex,E.uvIndex),this.addIndexedQuadPointIndexes(v.xyzIndex,M.xyzIndex,b.xyzIndex,E.xyzIndex),this._polyface.terminateFacet()))}addBetweenLineStringsWithRuleEdgeNormals(v,M,b,E,D=!1){const X=v.packedPoints,z=b.packedPoints,R=v.packedDerivatives,O=b.packedDerivatives,Y=v.fractions,N=b.fractions,B=this._options.needNormals,V=this._options.needParams,L=new Yn(B,V,B),U=new Yn(B,V,B),Sr=new Yn(B,V,B),Cr=new Yn(B,V,B),kr=new Yn(B,V,B),Fr=new Yn(B,V,B),Xr=X.length;if(!(Xr<2||Xr!==z.length)){L.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,X,R,Y,M),Sr.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,z,O,N,E),B&&Yn.computeNormalsAlongRuleLine(L,Sr),this.setSectorIndices(L),this.setSectorIndices(Sr),kr.copyContentsFrom(L),Fr.copyContentsFrom(Sr);for(let v=1;v<Xr;v++)U.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(v,X,R,Y,M),Cr.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(v,z,R,N,E),Yn.computeNormalsAlongRuleLine(U,Cr),this.setSectorIndices(U),this.setSectorIndices(Cr),this.addSectorQuadA01B01(L,U,Sr,Cr),L.copyContentsFrom(U),Sr.copyContentsFrom(Cr);D&&this.addSectorQuadA01B01(L,kr,Sr,Fr)}}addBetweenLineStringsWithStoredIndices(v,M){const b=v.pointIndices,E=M.pointIndices;let D=v.normalIndices,X=M.normalIndices;this._options.needNormals||(D=void 0,X=void 0);let z=v.paramIndices,R=M.paramIndices;this._options.needParams||(z=void 0,R=void 0);const O=b.length;for(let Y=1;Y<O;Y++)this.options.shouldTriangulate?(Vn(b.atUncheckedIndex(Y-1),b.atUncheckedIndex(Y),E.atUncheckedIndex(Y))&&(this.addIndexedTrianglePointIndexes(b.atUncheckedIndex(Y-1),b.atUncheckedIndex(Y),E.atUncheckedIndex(Y)),D&&X&&this.addIndexedTriangleNormalIndexes(D.atUncheckedIndex(Y-1),D.atUncheckedIndex(Y),X.atUncheckedIndex(Y-1)),z&&R&&this.addIndexedTriangleParamIndexes(z.atUncheckedIndex(Y-1),z.atUncheckedIndex(Y),R.atUncheckedIndex(Y-1))),Vn(E.atUncheckedIndex(Y),E.atUncheckedIndex(Y-1),b.atUncheckedIndex(Y-1))&&(this.addIndexedTrianglePointIndexes(b.atUncheckedIndex(Y-1),E.atUncheckedIndex(Y),E.atUncheckedIndex(Y-1)),D&&X&&this.addIndexedTriangleNormalIndexes(D.atUncheckedIndex(Y-1),X.atUncheckedIndex(Y),X.atUncheckedIndex(Y-1)),z&&R&&this.addIndexedTriangleParamIndexes(z.atUncheckedIndex(Y-1),R.atUncheckedIndex(Y),R.atUncheckedIndex(Y-1)))):(b.atUncheckedIndex(Y-1)===b.atUncheckedIndex(Y)&&E.atUncheckedIndex(Y-1)===E.atUncheckedIndex(Y)||(this.addIndexedQuadPointIndexes(b.atUncheckedIndex(Y-1),b.atUncheckedIndex(Y),E.atUncheckedIndex(Y-1),E.atUncheckedIndex(Y)),D&&X&&this.addIndexedQuadNormalIndexes(D.atUncheckedIndex(Y-1),D.atUncheckedIndex(Y),X.atUncheckedIndex(Y-1),X.atUncheckedIndex(Y)),z&&R&&this.addIndexedQuadParamIndexes(z.atUncheckedIndex(Y-1),z.atUncheckedIndex(Y),R.atUncheckedIndex(Y-1),R.atUncheckedIndex(Y))),this._polyface.terminateFacet())}addBetweenTransformedLineStrings(v,M,b,E=!1){if(v instanceof ke){const D=v.points.length;let X=this.findOrAddPointInLineString(v,0,M),z=this.findOrAddPointInLineString(v,0,b);const R=X,O=z;let Y=0,N=0;for(let E=1;E<D;E++)Y=this.findOrAddPointInLineString(v,E,M),N=this.findOrAddPointInLineString(v,E,b),this.addIndexedQuadPointIndexes(X,Y,z,N),X=Y,z=N;E&&this.addIndexedQuadPointIndexes(X,R,z,O)}else{const E=v.children;if(E)for(const v of E)this.addBetweenTransformedLineStrings(v,M,b)}}addBetweenStrokeSetPair(v,M,b,E){if(v instanceof ke&&b instanceof ke)this.addBetweenLineStringsWithRuleEdgeNormals(v,M,b,E,!1);else if(v instanceof ii&&b instanceof ii){if(v.children.length===b.children.length)for(let D=0;D<v.children.length;D++)this.addBetweenStrokeSetPair(v.children[D],M,b.children[D],E)}else if(v instanceof Ne&&b instanceof Ne){const D=v.children,X=b.children;if(D.length===X.length)for(let v=0;v<D.length;v++){const b=D[v],z=X[v];b instanceof ke&&z instanceof ke&&this.addBetweenLineStringsWithRuleEdgeNormals(b,M,z,E)}}}addCone(v){let M=16;this._options&&(M=this._options.applyTolerancesToArc(v.getMaxRadius()));let b=1;const E=v.strokeConstantVSection(0,M,this._options),D=v.strokeConstantVSection(1,M,this._options);if(this._options){const v=nt.distanceRangeBetweenCorrespondingPoints(E.packedPoints,D.packedPoints);b=this._options.applyMaxEdgeLength(1,v.low)}const X=v.maxIsoParametricDistance();this.addUVGridBody(v,M,b,We.create(0,X.x),We.create(0,X.y)),this.endFace(),v.capped&&(K.isSmallMetricDistance(v.getRadiusA())||(this.addTrianglesInUncheckedConvexPolygon(E,!0),this.endFace()),K.isSmallMetricDistance(v.getRadiusB())||(this.addTrianglesInUncheckedConvexPolygon(D,!1),this.endFace()))}addTorusPipe(v,M,b){const E=v.getThetaFraction();let D=K.clamp(K.resolveNumber(M,8),4,64),X=K.clamp(K.resolveNumber(b,Math.ceil(16*E)),2,64);this._options&&(D=this._options.applyTolerancesToArc(v.getMinorRadius()),X=this._options.applyTolerancesToArc(v.getMajorRadius(),v.getSweepAngle().radians)),this.toggleReversedFacetFlag();const z=v.maxIsoParametricDistance();if(this.addUVGridBody(v,D,X,We.create(0,z.x),We.create(0,z.y)),this.toggleReversedFacetFlag(),v.capped&&E<1){const M=v.getConstructiveFrame(),b=v.getMinorRadius(),E=v.getMajorRadius(),X=2*b,z=E-b,R=E+b,O=-b,Y=pt.createRowValues(X,0,0,z,0,0,-1,0,0,X,0,O),N=M.multiplyTransformTransform(Y).inverse();if(N){const M=bn.createLinestringOnUVLine(v,0,0,1,0,D,!1,!0);M.computeUVFromXYZTransform(N),this.addTrianglesInUncheckedConvexPolygon(M,!1)}const B=v.getSweepAngle().radians,V=Math.cos(B),L=Math.sin(B),U=pt.createRowValues(-V*X,0,-L,R*V,-L*X,0,V,R*L,0,X,0,O),Sr=M.multiplyTransformTransform(U).inverse();if(Sr){const M=bn.createLinestringOnUVLine(v,1,1,0,1,D,!1,!0);M.computeUVFromXYZTransform(Sr),this.addTrianglesInUncheckedConvexPolygon(M,!1)}}}addLinearSweepLineStringsXYZOnly(v,M){if(v instanceof ke){let b=Q.create(),E=Q.create(),D=0,X=0,z=0,R=0;const O=v.numPoints();for(let Y=0;Y<O;Y++)b=v.pointAt(Y,b),E=b.plus(M,E),X=this.addPoint(b),R=this.addPoint(E),Y>0&&this.addIndexedQuadPointIndexes(D,X,z,R),D=X,z=R}else if(v instanceof Ne)for(const b of v.children)this.addLinearSweepLineStringsXYZOnly(b,M)}addRotationalSweep(v){const M=v.getCurves(),b=Tn.createForParityRegionOrChain(M,this._options).getStrokes(),E=v.cloneAxisRay(),D=In.computeMaxVectorFromRay(E,b),X=E.direction.crossProduct(D);this._options.needNormals&&In.buildRotationalNormalsInLineStrings(b,E,X);const z=D.magnitude(),R=Math.abs(z*v.getSweep().radians);let O=Ie.applyAngleTol(this._options,1,v.getSweep().radians,void 0);O=Ie.applyMaxEdgeLength(this._options,O,R);for(let Y=1;Y<=O;Y++){const M=v.getFractionalRotationTransform((Y-1)/O),E=v.getFractionalRotationTransform(Y/O);this.addBetweenRotatedStrokeSets(b,M,Y-1,E,Y)}if(v.capped){const M=v.getSweepContourRef();M.purgeFacets(),M.emitFacets(this,!0,void 0),M.emitFacets(this,!1,v.getFractionalRotationTransform(1))}}addTriangulatedRegion(v){const M=cn.createForLinearSweep(v);M&&M.emitFacets(this,this.reversedFlag,void 0)}applyStrokeCountsToCurvePrimitives(v){const M=this._options;if(v instanceof oe)v.computeStrokeCountForOptions(M);else if(v instanceof ze){const M=v.children;if(M)for(const v of M)this.applyStrokeCountsToCurvePrimitives(v)}}addBetweenStrokeSetsWithRuledNormals(v,M,b){const E=[v],D=[0];for(let X=1;X<b;X++){const z=X/b,R=ri.interpolateBetween(v,X/b,M);E.push(R),D.push(z)}E.push(M),D.push(1);for(let X=0;X<b;X++)this.addBetweenStrokeSetPair(E[X],D[X],E[X+1],D[X+1])}createIndicesInLineString(v,M,b){const E=v.numPoints();{const M=v.ensureEmptyPointIndices(),D=this.findOrAddPointInLineString(v,0,b);if(M.push(D),E>1){let X,z=D;for(let D=1;D+1<E;D++)X=this.findOrAddPointInLineString(v,D,b,z),M.push(X),z=X;X=this.findOrAddPointInLineString(v,E-1,b,D),M.push(X)}}if(this._options.needNormals&&void 0!==v.packedSurfaceNormals){const M=v.ensureEmptyNormalIndices(),D=this.findOrAddNormalInLineString(v,0,b);M.push(D);let X,z=D;if(E>1){for(let D=1;D+1<E;D++)X=this.findOrAddNormalInLineString(v,D,b,z),M.push(X),z=X;X=this.findOrAddNormalInLineString(v,E-1,b,D,z),M.push(X)}}if(this._options.needParams&&void 0!==v.packedUVParams){const b=v.ensureEmptyUVIndices(),D=this.findOrAddParamInLineString(v,0,M);b.push(D);let X,z=D;if(E>1){for(let D=1;D+1<E;D++)X=this.findOrAddParamInLineString(v,D,M,z),b.push(X),z=X;X=this.findOrAddParamInLineString(v,E-1,M,z,D),b.push(X)}}}addBetweenRotatedStrokeSets(v,M,b,E,D){if(v instanceof ke){const X=v.cloneTransformed(M);this.createIndicesInLineString(X,b);const z=v.cloneTransformed(E);this.createIndicesInLineString(z,D),this.addBetweenLineStringsWithStoredIndices(X,z)}else if(v instanceof ii)for(const X of v.children)this.addBetweenRotatedStrokeSets(X,M,b,E,D);else if(v instanceof Ne)for(const X of v.children)X instanceof ke&&this.addBetweenRotatedStrokeSets(X,M,b,E,D)}addLinearSweep(v){const M=v.getCurvesRef(),b=Tn.createForParityRegionOrChain(M,this._options).getStrokes(),E=v.cloneSweepVector(),D=pt.createTranslation(E),X=b.cloneTransformed(D),z=this._options.applyMaxEdgeLength(1,E.magnitude());if(this.addBetweenStrokeSetsWithRuledNormals(b,X,z),v.capped&&M.isAnyRegionType){const M=v.getSweepContourRef();M.purgeFacets(),M.emitFacets(this,!0,void 0),M.emitFacets(this,!1,D)}}addRuledSweep(v){const M=v.sweepContoursRef();let b,E;const D=[];for(const X of M)D.push(Tn.createForParityRegionOrChain(X.curves,this._options));if(Tn.enforceStrokeCountCompatibility(D)){Tn.enforceCompatibleDistanceSums(D);for(let v=0;v<M.length;v++){if(E=D[v].getStrokes(),E||(E=M[v].curves.cloneStroked()),v>0&&b&&E){const v=ft.createNull();if(Tn.extendDistanceRangeBetweenStrokes(b,E,v)&&!v.isNull){const M=this._options.applyMaxEdgeLength(1,v.high);this.addBetweenStrokeSetsWithRuledNormals(b,E,M)}}b=E}}return v.capped&&M[0].curves.isAnyRegionType&&(M[0].purgeFacets(),M[0].emitFacets(this,!0,void 0),M[M.length-1].purgeFacets(),M[M.length-1].emitFacets(this,!1,void 0)),!0}addSphere(v,M){let b=M||this.options.applyTolerancesToArc(v.maxAxisRadius());K.isOdd(b)&&(b+=1);const E=K.clampToStartEnd(Math.abs(b*v.latitudeSweepFraction),1,Math.ceil(.5*b)),D=v.strokeConstantVSection(0,b,this._options);v.capped&&!K.isSmallMetricDistance(D.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(D,!0),this.endFace());const X=v.maxIsoParametricDistance();this.addUVGridBody(v,b,E,We.create(0,X.x),We.create(0,X.y)),this.endFace();const z=v.strokeConstantVSection(1,b,this._options);v.capped&&!K.isSmallMetricDistance(z.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(z,!1),this.endFace())}addBox(v){const M=v.getCorners(),b=K.maxXY(v.getBaseX(),v.getBaseX()),E=K.maxXY(v.getBaseY(),v.getTopY());let D=0;for(let N=0;N<4;N++)D=K.maxXY(D,M[N].distance(M[N+4]));const X=this._options.applyMaxEdgeLength(1,b),z=this._options.applyMaxEdgeLength(1,E),R=this._options.applyMaxEdgeLength(1,D),O=We.create(0,b),Y=We.create(0,D);this.addUVGridBody(Mn.create(M[0],M[1],M[4],M[5]),X,R,O,Y),O.shift(b),this.addUVGridBody(Mn.create(M[1],M[3],M[5],M[7]),z,R,O,Y),O.shift(E),this.addUVGridBody(Mn.create(M[3],M[2],M[7],M[6]),X,R,O,Y),O.shift(b),this.addUVGridBody(Mn.create(M[2],M[0],M[6],M[4]),z,R,O,Y),this.endFace(),v.capped&&(O.set(0,b),Y.set(0,E),this.addUVGridBody(Mn.create(M[4],M[5],M[6],M[7]),X,z,O,Y),this.endFace(),O.set(0,b),Y.set(0,E),this.addUVGridBody(Mn.create(M[2],M[3],M[0],M[1]),X,z,O,Y),this.endFace())}addPolygon(v,M){for(void 0===M&&(M=v.length);M>1&&v[M-1].isAlmostEqual(v[0]);)M--;let b=0;if(this._reversed)for(let E=M;--E>=0;)b=this.addPoint(v[E]),this._polyface.addPointIndex(b);else for(let E=0;E<M;E++)b=this.addPoint(v[E]),this._polyface.addPointIndex(b);this._polyface.terminateFacet()}addPolygonGrowableXYZArray(v){let M=v.length;for(;M>2&&K.isSmallMetricDistance(v.distanceIndexIndex(0,M-1));)M--;for(;M>2&&K.isSmallMetricDistance(v.distanceIndexIndex(M-2,M-1));)M--;if(3===M){const b=v.crossProductIndexIndexIndex(0,1,2).magnitude(),E=v.distanceIndexIndex(0,1)+v.distanceIndexIndex(0,2)+v.distanceIndexIndex(1,2);b<K.smallMetricDistance*E&&(M=0)}if(M>2){let b=0;if(this._reversed)for(let E=M;--E>=0;)b=this.findOrAddPointInGrowableXYZArray(v,E),this._polyface.addPointIndex(b);else for(let E=0;E<M;E++)b=this.findOrAddPointInGrowableXYZArray(v,E),this._polyface.addPointIndex(b);this._polyface.terminateFacet()}}addFacetFromGrowableArrays(v,M,b,E,D){let X=v.length;for(;X>1&&K.isSmallMetricDistance(v.distanceIndexIndex(0,X-1));)X--;let z=0;if(M&&M.length<X&&(M=void 0),b&&b.length<X&&(b=void 0),E&&E.length<X&&(E=void 0),D&&D.length<X&&(D=void 0),this._reversed)for(let R=X;--R>=0;)z=this.findOrAddPointInGrowableXYZArray(v,R),this._polyface.addPointIndex(z),M&&(z=this.findOrAddNormalInGrowableXYZArray(M,R),this._polyface.addNormalIndex(z)),b&&(z=this.addParamInGrowableXYArray(b,R),this._polyface.addParamIndex(z)),E&&(z=this._polyface.addColor(E[R]),this._polyface.addColorIndex(z));else for(let R=0;R<X;R++)z=this.findOrAddPointInGrowableXYZArray(v,R),this._polyface.addPointIndex(z,!D||D[R]),M&&(z=this.findOrAddNormalInGrowableXYZArray(M,R),this._polyface.addNormalIndex(z)),b&&(z=this.addParamInGrowableXYArray(b,R),this._polyface.addParamIndex(z)),E&&(z=this._polyface.addColor(E[R]),this._polyface.addColorIndex(z));this._polyface.terminateFacet()}addFacetFromVisitor(v){this.addFacetFromGrowableArrays(v.point,v.normal,v.param,v.color,v.edgeVisible)}addFacetsFromVisitor(v){for(v.reset();v.moveToNextFacet();)this.addFacetFromVisitor(v)}addFacetFromIndexedVisitor(v,M){if(M.length>v.pointIndex.length)return!1;const b=new nt(M.length),E=v.normal?new nt(M.length):void 0,D=v.param?new Te(M.length):void 0,X=v.color?new Array(M.length):void 0,z=v.edgeVisible?new Array(M.length):void 0;for(let R=0;R<M.length;++R){const O=M[R];if(O<0||O>=v.point.length)return!1;b.pushXYZ(v.point.getXAtUncheckedPointIndex(O),v.point.getYAtUncheckedPointIndex(O),v.point.getZAtUncheckedPointIndex(O)),v.normal&&E&&E.pushXYZ(v.normal.getXAtUncheckedPointIndex(O),v.normal.getYAtUncheckedPointIndex(O),v.normal.getZAtUncheckedPointIndex(O)),v.param&&D&&D.pushXY(v.param.getXAtUncheckedPointIndex(O),v.param.getYAtUncheckedPointIndex(O)),v.color&&X&&(X[R]=v.color[O]),v.edgeVisible&&z&&(z[R]=v.edgeVisible[O])}return this.addFacetFromGrowableArrays(b,E,D,X,z),!0}addIndexedPolyface(v,M=!1,b){this._polyface.addIndexedPolyface(v,M,b)}endFace(){return this._polyface.setNewFaceData()}handleCone(v){return this.addCone(v)}handleTorusPipe(v){return this.addTorusPipe(v)}handleSphere(v){return this.addSphere(v)}handleBox(v){return this.addBox(v)}handleLinearSweep(v){return this.addLinearSweep(v)}handleRotationalSweep(v){return this.addRotationalSweep(v)}handleRuledSweep(v){return this.addRuledSweep(v)}handleLoop(v){return this.addTriangulatedRegion(v)}handleParityRegion(v){return this.addTriangulatedRegion(v)}handleUnionRegion(v){return this.addTriangulatedRegion(v)}addGeometryQuery(v){v.dispatchToGeometryHandler(this)}addGraph(v,M=(v=>Zi.testNodeMaskNotExterior(v)),b=(v=>Zi.testMateMaskExterior(v))){let E=0;const D=this._options.needNormals,X=this._options.needParams;let z=0;D&&(z=this._polyface.addNormalXYZ(0,0,1)),v.announceFaceLoops(((v,R)=>{if(M(R)&&R.countEdgesAroundFace()>2){let v=R;do{E=this.addPointXYZ(v.x,v.y,v.z),this._polyface.addPointIndex(E,void 0===b||b(v)),X&&(E=this.addParamXY(v.x,v.y),this._polyface.addParamIndex(E)),D&&this._polyface.addNormalIndex(z),v=v.faceSuccessor}while(v!==R);this._polyface.terminateFacet()}return!0}))}addGraphFaces(v,M){let b=0;for(const E of M){let v=E;do{b=this.addPointXYZ(v.x,v.y,v.z),this._polyface.addPointIndex(b),v=v.faceSuccessor}while(v!==E);this._polyface.terminateFacet()}}static graphToPolyface(v,M,b=(v=>Zi.testNodeMaskNotExterior(v))){const E=On.create(M);return E.addGraph(v,b),E.endFace(),E.claimPolyface()}static graphFacesToPolyface(v,M){const b=On.create();return b.addGraphFaces(v,M),b.endFace(),b.claimPolyface()}static polygonToTriangulatedPolyface(v,M){if(M||(M=ei.createFrameWithCCWPolygon(v)),M){const b=M.multiplyInversePoint3dArray(v);vr.areaXY(b)<0&&b.reverse();const E=Ps.createTriangulatedGraphFromSingleLoop(b);if(E){const v=this.graphToPolyface(E);return v.tryTransformInPlace(M),v}}}addCoordinateFacets(v,M,b,E=!1){for(let D=0;D<v.length;D++){const E=M?M[D]:void 0,X=b?b[D]:void 0;3===v[D].length?this.addTriangleFacet(v[D],E,X):4===v[D].length&&this.addQuadFacet(v[D],E,X)}E&&this.endFace()}addUVGridBody(v,M,b,E,D){let X,z,R,O,Y=new At(M),N=new At(M);const B=this._reversed,V=this.options.needNormals;V&&(R=new At(M),O=new At(M));const L=this.options.needParams;let U;L&&(X=new At(M),z=new At(M)),Y.ensureCapacity(M),N.ensureCapacity(M);const Sr=H.create(),Cr=$.create(),kr=1/M,Fr=1/b,Xr=bt.createXYPlane();for(let zr=0;zr<=b;zr++){N.clear(),V&&O.clear(),L&&z.clear();for(let b=0;b<=M;b++){const M=b*kr,X=zr*Fr;v.uvFractionToPointAndTangents(M,X,Xr),N.push(this._polyface.addPoint(Xr.origin)),V&&(Xr.vectorU.crossProduct(Xr.vectorV,Cr),Cr.normalizeInPlace(),B&&Cr.scaleInPlace(-1),O.push(this._polyface.addNormal(Cr))),L&&z.push(this._polyface.addParam(H.create(E?E.fractionToPoint(M):M,D?D.fractionToPoint(X):X,Sr)))}if(zr>0)for(let v=0;v<M;v++)this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(Y.atUncheckedIndex(v),Y.atUncheckedIndex(v+1),N.atUncheckedIndex(v),!1),V&&this.addIndexedTriangleNormalIndexes(R.atUncheckedIndex(v),R.atUncheckedIndex(v+1),O.atUncheckedIndex(v)),L&&this.addIndexedTriangleParamIndexes(X.atUncheckedIndex(v),X.atUncheckedIndex(v+1),z.atUncheckedIndex(v)),this._polyface.terminateFacet(),this.addIndexedTrianglePointIndexes(N.atUncheckedIndex(v),Y.atUncheckedIndex(v+1),N.atUncheckedIndex(v+1),!1),V&&this.addIndexedTriangleNormalIndexes(O.atUncheckedIndex(v),R.atUncheckedIndex(v+1),O.atUncheckedIndex(v+1)),L&&this.addIndexedTriangleParamIndexes(z.atUncheckedIndex(v),X.atUncheckedIndex(v+1),z.atUncheckedIndex(v+1)),this._polyface.terminateFacet()):(this.addIndexedQuadPointIndexes(Y.atUncheckedIndex(v),Y.atUncheckedIndex(v+1),N.atUncheckedIndex(v),N.atUncheckedIndex(v+1),!1),V&&this.addIndexedQuadNormalIndexes(R.atUncheckedIndex(v),R.atUncheckedIndex(v+1),O.atUncheckedIndex(v),O.atUncheckedIndex(v+1)),L&&this.addIndexedQuadParamIndexes(X.atUncheckedIndex(v),X.atUncheckedIndex(v+1),z.atUncheckedIndex(v),z.atUncheckedIndex(v+1)),this._polyface.terminateFacet());U=N,N=Y,Y=U,L&&(U=z,z=X,X=U),V&&(U=O,O=R,R=U)}Y.clear(),N.clear()}static pointsToTriangulatedPolyface(v,M){const b=Ps.createTriangulatedGraphFromPoints(v);if(b)return On.graphToPolyface(b,M)}addGreedyTriangulationBetweenLineStrings(v,M){zn.createContext().emitTriangles(Bn(v),Bn(M),(v=>{this.addTriangleFacet(v.points)}))}addMiteredPipesFromPoints(v,M,b=12){const E=vn.createMiteredPipeSections(v,M),D=Q.create(),X=Q.create(),z=Q.create(),R=Q.create();b<3&&(b=3);const O=1/b;for(let Y=1;Y<E.length;Y++){const v=E[Y-1],M=E[Y];v.fractionToPoint(0,D),M.fractionToPoint(0,z);for(let E=1;E<=b;E++,D.setFromPoint3d(X),z.setFromPoint3d(R)){const b=E*O;v.fractionToPoint(b,X),M.fractionToPoint(b,R),this.addQuadFacet([D,z,R,X])}}}addMiteredPipes(v,M,b=12){if(Array.isArray(v))this.addMiteredPipesFromPoints(new ae(v),M,b);else if(v instanceof nt)this.addMiteredPipesFromPoints(v,M,b);else if(v instanceof it)this.addMiteredPipesFromPoints(v,M,b);else if(v instanceof ke)this.addMiteredPipesFromPoints(v.packedPoints,M,b);else if(v instanceof Nt){const E=ke.create();v.emitStrokes(E,this._options),this.addMiteredPipesFromPoints(E.packedPoints,M,b)}}getEdgeIndices(v){let M=-1,b=-1;for(let E=this._polyface.facetIndex0(v.facetIndex);E<this._polyface.facetIndex1(v.facetIndex);++E)v.vertexIndexA===this._polyface.data.pointIndex[E]?M=E:v.vertexIndexB===this._polyface.data.pointIndex[E]&&(b=E);return M<0||b<0?void 0:{edgeIndexA:M,edgeIndexB:b}}addSweptFace(v,M){const b=this.getEdgeIndices(v);if(void 0===b)return!1;const E=M+v.facetIndex;if(!this._polyface.isValidFacetIndex(E))return!1;const D=this._polyface.numEdgeInFacet(v.facetIndex);if(D!==this._polyface.numEdgeInFacet(E))return!1;const X=this._polyface.facetIndex0(v.facetIndex),z=this._polyface.facetIndex0(E),R=D-1-(b.edgeIndexA-X),O=D-1-(b.edgeIndexB-X),Y=[b.edgeIndexB,b.edgeIndexA,z+R,z+O],N=[];let B;void 0!==this.options.needColors&&void 0!==this._polyface.data.color&&void 0!==this._polyface.data.colorIndex&&(B=[]);for(let V=0;V<4;++V){const v=this._polyface.data.getPoint(this._polyface.data.pointIndex[Y[V]]);if(void 0===v)return!1;if(N.push(v),void 0!==B){const v=this._polyface.data.getColor(this._polyface.data.colorIndex[Y[V]]);if(void 0===v)return!1;B.push(v)}}return this.addQuadFacet(N,void 0,void 0,B),!0}addSweptIndexedPolyface(v,M,b=!1){let E=!0;const D=on.sumFacetAreas(v,M);K.isAlmostEqualNumber(0,D)&&(E=!1);const X=on.partitionFacetIndicesByVisibilityVector(v,M,W.createDegrees(.001)),z=X[0].length,R=X[1].length;X[2].length>0&&(E=!1),z>0&&R>0&&(E=!1);const O=z>0,Y=this._polyface.facetCount;this.addIndexedPolyface(v,O);const N=this._polyface.facetCount;this.addIndexedPolyface(v,!O,pt.createTranslation(M));const B=N-Y,V=Array.from({length:B},((v,M)=>Y+M)),L=Ai.createSubsetVisitor(this._polyface,V,1),U=[];on.createIndexedEdges(L).sortAndCollectClusters(void 0,U,void 0,void 0);const Sr=this._options.shouldTriangulate;this._options.shouldTriangulate=b;for(const Cr of U)if(Cr instanceof Ns)this.addSweptFace(Cr,B);else if(Array.isArray(Cr))for(const v of Cr)this.addSweptFace(v,B);return this._options.shouldTriangulate=Sr,E}}function Bn(v){return Array.isArray(v)?new ae(v):v instanceof ke?v.packedPoints:v}function Vn(v,M,b){return v!==M&&M!==b&&b!==v}On._workPointFindOrAddA=Q.create(),On._workVectorFindOrAdd=$.create(),On._workUVFindOrAdd=H.create();class Ln{constructor(v=5){this._activeMomentData=ni.create(),this._activeMomentData.needOrigin=!0,this._gaussMapper=new ne(v)}get momentData(){return this._activeMomentData}startParentCurvePrimitive(v){}startCurvePrimitive(v){}endCurvePrimitive(v){}endParentCurvePrimitive(v){}announceIntervalForUniformStepStrokes(v,M,b,E){this.startCurvePrimitive(v),M<1&&(M=1);const D=1/M;let X,z;for(let R=1;R<=M;R++){const O=K.interpolate(b,(R-1)*D,E),Y=R===M?E:K.interpolate(b,R*D,E),N=this._gaussMapper.mapXAndW(O,Y);for(let M=0;M<N;M++){z=this._gaussMapper.gaussX[M];const b=v.fractionToPointAndDerivative(z);X=this._gaussMapper.gaussW[M]*b.direction.magnitude(),this._activeMomentData.accumulateScaledOuterProduct(b.origin,X)}}}announceSegmentInterval(v,M,b,E,D,X){this._activeMomentData.accumulateLineMomentsXYZ(M,b)}announcePointTangent(v,M,b){}visitLeaves(v){if(v instanceof oe)v.emitStrokableParts(this);else if(v instanceof ze)for(const M of v.children)this.visitLeaves(M)}}class Un{pushNewChain(v){const M=[];v&&M.push(v),this._chains.push(M)}findOrCreateTailChain(){return 0===this._chains.length&&this.pushNewChain(),this._chains[this._chains.length-1]}findAnyChainToConnect(v){for(let M=0;M<this._chains.length;M++){const b=this._chains[M];if(this._xyzWork1=b[b.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(v))return{chainIndex:M,atEnd:!0};if(this._xyzWork1=b[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(v))return{chainIndex:M,atEnd:!1}}}constructor(v){this._chains=[],this._makeClones=v}announceCurvePrimitive(v,M=!1){if(v){if(this._makeClones){const M=v.clone();if(!(M&&M instanceof oe))return;this.transferMarkup(v,M),v=M}if(M){this._xyzWork0=v.startPoint(this._xyzWork0);let M=this.findAnyChainToConnect(this._xyzWork0);M?M.atEnd?this._chains[M.chainIndex].push(v):(v.reverseInPlace(),this._chains[M.chainIndex].splice(0,0,v)):(this._xyzWork0=v.endPoint(this._xyzWork0),M=this.findAnyChainToConnect(this._xyzWork0),M?M.atEnd?(v.reverseInPlace(),this._chains[M.chainIndex].push(v)):this._chains[M.chainIndex].splice(0,0,v):this._chains.push([v]))}else{const M=this.findOrCreateTailChain();0!==M.length&&Un.needBreakBetweenPrimitives(M[M.length-1],v)?this.pushNewChain(v):M.push(v)}}}transferMarkup(v,M){v&&M&&(M.startCut=v.startCut,M.endCut=v.endCut)}promoteArrayToCurves(v,M){if(0!==v.length)return M&&(Un._staticPointA=v[0].startPoint(Un._staticPointA),Un._staticPointB=v[v.length-1].endPoint(Un._staticPointB),Un._staticPointA.isAlmostEqual(Un._staticPointB))?Oe.createArray(v):1===v.length?v[0]:Ve.createArray(v)}grabResult(v=!1){const M=this._chains;if(0===M.length)return;if(1===M.length)return this.promoteArrayToCurves(M[0],v);const b=Ye.create();for(const E of M){const M=this.promoteArrayToCurves(E,v);b.tryAddChild(M)}return b}static needBreakBetweenPrimitives(v,M,b=!1){return void 0===v||void 0===M||void 0!==v.endCut||void 0!==M.startCut||(Un._staticPointA=v.endPoint(Un._staticPointA),Un._staticPointB=M.startPoint(Un._staticPointB),b?!Un._staticPointA.isAlmostEqualXY(Un._staticPointB):!Un._staticPointA.isAlmostEqual(Un._staticPointB))}}class Zn extends Ue{constructor(v){super(),this._options=v||new ur}handleCurveChain(v){const M=v.children.length,b=[];let E=0;for(let D=0;D<M;){const X=v.children[D];if(this._options.consolidateLinearGeometry&&(X instanceof we||X instanceof ke)){b.length=0;let z=D;for(;z<v.children.length;z++){const M=v.children[z];if(M instanceof we)b.push(M.startPoint()),b.push(M.endPoint());else{if(!(M instanceof ke))break;{const v=M.packedPoints;for(let M=0;M<v.length;M++)b.push(v.getPoint3dAtUncheckedPointIndex(M))}}}if(b.length>1){const X=this._options.colinearPointTolerance,R=oi.compressShortEdges(b,X),O=oi.compressByPerpendicularDistance(R,X);0===D&&z===M&&si.compressColinearWrapInPlace(O,X),O.length<2?v.children[E++]=ke.create(O[0]):2===O.length?v.children[E++]=we.create(O[0],O[1]):v.children[E++]=ke.createPoints(O)}else v.children[E++]=X;D=z}else if(this._options.consolidateCompatibleArcs&&X instanceof ti){for(;++D<v.children.length;){const M=v.children[D];if(!(M instanceof ti))break;if(!vn.appendToArcInPlace(X,M))break}v.children[E++]=X}else v.children[E++]=X,D++}v.children.length=E}handlePath(v){return this.handleCurveChain(v)}handleLoop(v){return this.handleCurveChain(v)}handleParityRegion(v){for(const M of v.children)M.dispatchToGeometryHandler(this)}handleUnionRegion(v){for(const M of v.children)M.dispatchToGeometryHandler(this)}}class qn{constructor(v,M){this.fraction=v,this.otherCurveDetail=M}setFrom(v,M){M&&this.isSameFraction(v)&&(this.otherCurveDetail=v.otherCurveDetail?v.otherCurveDetail:this.otherCurveDetail),this.fraction=v.fraction}isSameFraction(v){return K.isSmallAngleRadians(this.fraction-v.fraction)}set(v,M){this.fraction=v,this.otherCurveDetail=M}}class Wn{static hasInteriorDetailAIntersections(v,M=K.smallAngleRadians){if(0===v.length)return!1;for(const b of v)if(b.detailA.fraction>M||b.detailA.fraction<1-M)return!0;return!1}collectFragmentAndAdvanceCut(v,M,b,E){if(!M.isSameFraction(b)){const D=v.clonePartialCurve(M.fraction,b.fraction);void 0!==D&&(D.startCut=M.otherCurveDetail,D.endCut=b.otherCurveDetail,E.push(D))}M.setFrom(b,!0)}collectSinglePrimitiveFragments(v,M,b){if(void 0===M||!Wn.hasInteriorDetailAIntersections(M))return void b.push(v.clone());M.sort(((v,M)=>v.detailA.fraction-M.detailA.fraction));const E=new qn(0,void 0),D=new qn(1,void 0);for(const X of M)D.set(X.detailA.fraction,X.detailB),this.collectFragmentAndAdvanceCut(v,E,D,b);D.set(1,void 0),this.collectFragmentAndAdvanceCut(v,E,D,b)}static cloneCurvesWithXYSplits(v,M){const b=new Wn;if(v instanceof oe){const E=[],D=Xi.intersectionXYPairs(v,!1,M,!1);return b.collectSinglePrimitiveFragments(v,D,E),1===E.length?E[0]:Ve.createArray(E)}if(v instanceof Ne){const E=[];for(const D of v.children){const v=Xi.intersectionXYPairs(D,!1,M,!1);b.collectSinglePrimitiveFragments(D,v,E)}return Ve.createArray(E)}}}class Gn{static testPointInOnOutLoopXY(v,M,b){let E;const D=Q.create(M,b);for(let X=0;Math.abs(X)<6;X=-1.2313*(X+.3212897)){E=yt.createXYAngle(M,b,W.createRadians(X));const z=E.getNormalRef(),R=[];for(const M of v.children)M instanceof oe&&M.appendPlaneIntersectionPoints(E,R);oe.snapAndRestrictDetails(R,!1,!0);let O,Y,N=0,B=0,V=0;for(const v of R){if(v.intervalRole!==L.isolated&&void 0!==v.intervalRole&&V++,O=v.point.x-M,Y=v.point.y-b,K.isSameCoordinateXY(O,Y,0,0))return 0;const E=K.crossProductXYXY(z.x,z.y,O,Y);if(D.isAlmostEqualXY(v.point))return 0;E<0?N++:E>0&&B++}if(0!==V)continue;const U=1&N;if(U===(1&B))return 1===U?1:-1}return-1}static testPointInOnOutParityRegionXY(v,M,b){let E=-1;for(const D of v.children)if(D instanceof Oe){const v=this.testPointInOnOutLoopXY(D,M,b);if(0===v)return 0;v>0&&(E=-E)}return E}static testPointInOnOutUnionRegionXY(v,M,b){for(const E of v.children){const v=this.testPointInOnOutRegionXY(E,M,b);if(v>=0)return v}return-1}static testPointInOnOutRegionXY(v,M,b){return v instanceof Oe?this.testPointInOnOutLoopXY(v,M,b):v instanceof ii?this.testPointInOnOutParityRegionXY(v,M,b):v instanceof Ji?this.testPointInOnOutUnionRegionXY(v,M,b):-1}}class Hn{constructor(){this.primitiveToPair=new Map,this.primitiveToIndex=new Map,this._numIndexedPrimitives=0}assignPrimitiveIndex(v){void 0!==v&&void 0===this.primitiveToIndex.get(v)&&this.primitiveToIndex.set(v,this._numIndexedPrimitives++)}insertPrimitiveToPair(v,M){if(v){const b=this.primitiveToPair.get(v);this.assignPrimitiveIndex(v),b?b.push(M):this.primitiveToPair.set(v,[M])}}insertPair(v){const M=v.detailA.curve;M&&this.insertPrimitiveToPair(M,v);const b=v.detailB.curve;b&&this.insertPrimitiveToPair(b,v)}splitAndAppendMissingClosedPrimitives(v,M=K.smallMetricDistance){for(const b of v){let v=!1;if(b instanceof ti?v=b.sweep.isFullCircle:b instanceof we||b instanceof ke||(v=b.startPoint().isAlmostEqualXY(b.endPoint(),M)),v&&!this.primitiveToPair.has(b)){const v=b.clonePartialCurve(0,.5),M=b.clonePartialCurve(.5,1);v&&M&&(this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(v,0),vt.createCurveEvaluatedFraction(M,1))),this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(v,1),vt.createCurveEvaluatedFraction(M,0))))}}}}class Jn{static assembleHalfEdgeGraph(v,M,b=K.smallMetricDistance){const E=new Hn;for(const X of M)E.insertPair(X);v.length>E.primitiveToPair.size&&E.splitAndAppendMissingClosedPrimitives(v,b);const D=new qi;for(const X of E.primitiveToPair.entries()){const v=X[0],M=X[1].reduce(((M,b)=>{if(!b.detailA.hasFraction1)return[...M,b];const E=Qn(b,v),D=vt.createCurveFractionPoint(v,E.fraction,E.point),X=vt.createCurveFractionPoint(v,E.fraction1,E.point1);return[...M,Pt.createCapture(D,D),Pt.createCapture(X,X)]}),[]);M.sort(((M,b)=>jn(M,v)-jn(b,v)));let E={point:v.startPoint(),fraction:0};for(const X of M){const M=Qn(X,v),z=K.restrictToInterval(M.fraction,0,1);E=this.addHalfEdge(D,v,E.point,E.fraction,M.point,z,b)}this.addHalfEdge(D,v,E.point,E.fraction,v.endPoint(),1,b)}return Cs.clusterAndMergeXYTheta(D,(v=>v.sortAngle)),D}static addHalfEdge(v,M,b,E,D,X,z=K.smallMetricDistance){if(b.isAlmostEqualXY(D,z))return{point:b,fraction:E};const R=v.createEdgeXYAndZ(b,0,D,0),O=vt.createCurveEvaluatedFractionFraction(M,E,X),Y=R.edgeMate;return R.edgeTag=O,R.sortData=1,Y.edgeTag=O,Y.sortData=-1,R.sortAngle=Kn(M,E,!1),Y.sortAngle=Kn(M,X,!0),{point:D,fraction:X}}static collectSignedLoop(v,M,b=1e-10,E){let D=E?0:lr.computeXYArea(v);return void 0===D&&(D=0),Math.abs(D)<b&&(D=0),v.computedAreaInPlanarSubdivision=D,D>0?M.positiveAreaLoops.push(v):D<0?M.negativeAreaLoops.push(v):M.slivers.push(v),D}static createLoopInFace(v,M){let b=v;const E=Oe.create();do{const v=b.edgeTag;if(v){let D;D=b.sortData>0?v.curve.clonePartialCurve(v.fraction,v.fraction1):v.curve.clonePartialCurve(v.fraction1,v.fraction),D&&(void 0!==M&&M(b,D,E),E.tryAddChild(D))}b=b.faceSuccessor}while(b!==v);return E}static isNullFace(v){const M=v.faceSuccessor.faceSuccessor===v;let b=!1;if(M){const M=Cs.curvatureSortKey(v),E=Cs.curvatureSortKey(v.faceSuccessor.edgeMate);K.isSameCoordinate(M,E)||(b=!0)}return M&&!b}static nonNullEdgeMate(v,M){if(this.isNullFace(M))return;let b=M.edgeMate;for(;this.isNullFace(b);)if(b=b.faceSuccessor.edgeMate,b===M)return;return b}static collectSignedLoopSetsInHalfEdgeGraph(v,M=1e-10){const b=Es.collectConnectedComponentsWithExteriorParityMasks(v,void 0),E=[],D=new Map;for(const X of b){const b={positiveAreaLoops:[],negativeAreaLoops:[],slivers:[]},z=[];for(const E of X){const X=this.isNullFace(E),R=this.createLoopInFace(E,((M,b,E)=>{if(!X){const X=this.nonNullEdgeMate(v,M);if(void 0!==X){const v=D.get(X);if(void 0===v){const v=new Be(E,b,void 0,void 0);D.set(M,v)}else v instanceof Be&&(v.setB(E,b),z.push(v),D.delete(X))}}}));this.collectSignedLoop(R,b,M,X)}b.edges=z,E.push(b),D.clear()}return E}}function Kn(v,M,b){const E=v.fractionToPointAndDerivative(M),D=b?-1:1;return Math.atan2(D*E.direction.y,D*E.direction.x)}function jn(v,M){return v.detailA.curve===M?v.detailA.fraction:v.detailB.curve===M?v.detailB.fraction:void 0}function Qn(v,M){return v.detailA.curve===M?v.detailA:v.detailB.curve===M?v.detailB:void 0}class $n extends Ue{constructor(){super(...arguments),this._point0=Q.create(),this._point1=Q.create()}handleArc3d(v){const M=this._activeMomentData,b=v.sweep.sweepRadians,E=.5*b;let D=Math.sin(E),X=Math.cos(E),z=Math.sin(b);W.isFullCircleRadians(b)&&(D=0,X=-1,z=0);const R=2*D*D*D*X/(E-D*X),O=D*D*D,Y=.5*(b-z),N=.25*Y*(1+R)-O*O*4/(9*Y),B=.25*Y*(1-R/3),V=4*D*D*D/(3*(b-z)),L=v.sweep.fractionToRadians(.5),U=v.radiansToRotatedBasis(L),Sr=U.origin.plusScaled(U.vectorU,V);M.accumulateXYProductsInCentroidalFrame(N,0,B,Y,Sr,U.vectorU,U.vectorV);const Cr=v.fractionToPoint(0),kr=v.fractionToPoint(1);M.accumulateTriangleMomentsXY(void 0,Cr,kr)}handleLineString3d(v){this._activeMomentData.accumulateTriangleToLineStringMomentsXY(void 0,v.packedPoints)}handleLineSegment3d(v){const M=this._activeMomentData;v.startPoint(this._point0),v.endPoint(this._point1),M.accumulateTriangleMomentsXY(void 0,this._point0,this._point1)}handleLoop(v){const M=this._activeMomentData=ni.create();M.needOrigin=!1;for(const b of v.children)b.dispatchToGeometryHandler(this);return this._activeMomentData=void 0,M}handleParityRegion(v){const M=[];let b,E=0;for(const D of v.children)if(D instanceof Oe){const v=this.handleLoop(D);if(v){M.push(v);const D=Math.abs(v.quantitySum);D>E&&(E=D,b=v)}}if(b){const v=ni.create(),E=b.signFactor(1);v.accumulateProducts(b,E);for(const D of M)if(D!==b){const M=D.signFactor(-1);v.accumulateProducts(D,M)}return v}}handleUnionRegion(v){const M=ni.create();for(const b of v.children){const v=b.dispatchToGeometryHandler(this);if(v){const b=v.signFactor(1);M.accumulateProducts(v,b)}}return M}getStrokeOptions(){if(this._strokeOptions)return this._strokeOptions;const v=Ie.createForCurves();return v.angleTol=W.createDegrees(5),this._strokeOptions=v,v}handleCurvePrimitive(v){const M=ke.create(),b=this.getStrokeOptions();v.emitStrokes(M,b),this.handleLineString3d(M)}handleBSplineCurve3d(v){return this.handleCurvePrimitive(v)}handleBSplineCurve3dH(v){return this.handleCurvePrimitive(v)}handleTransitionSpiral(v){return this.handleCurvePrimitive(v)}}class tr{startComponent(v){return!0}finishComponent(v){return!0}enterFace(v,M){return!0}leaveFace(v,M){return!0}}class er extends tr{constructor(v,M){super(),this._inComponent=[!1,!1,!1],this._exteriorMask=M,this._faceSelectFunction=v}startComponent(v){return v.setMaskAroundFace(this._exteriorMask),!0}enterFace(v,M){const b=M.edgeTag;return 1!==M.edgeTag&&2!==M.edgeTag||(this._inComponent[b]=!this._inComponent[b]),this._faceSelectFunction(this._inComponent[1],this._inComponent[2])||M.setMaskAroundFace(this._exteriorMask),!0}leaveFace(v,M){const b=M.edgeTag;return 1!==M.edgeTag&&2!==M.edgeTag||(this._inComponent[b]=!this._inComponent[b]),!0}}class ir{static faceToFaceSearchFromOuterLoop(v,M,b,E,D){if(M.isMaskSet(b))return;if(!D.startComponent(M))return;const X=[];M.setMaskAroundFace(b);let z=M;do{let v=z,M=z.edgeMate;if(!M.isMaskSet(b)){X.push(z),X.push(M);let R=M.faceSuccessor;if(M.setMaskAroundFace(b),v=M,D.enterFace(X,M))for(;;){if(M=R.edgeMate,!M.isMaskSet(b)){if(M.setMaskAroundFace(b),!D.enterFace(X,M))return;X.push(R),X.push(M),R=M,v=M}if(R.setMask(E),R=R.faceSuccessor,R===v){if(D.leaveFace(X,R),X.length<=2)break;X.pop(),R=X[X.length-1],X.pop(),v=X[X.length-1]}if(R.isMaskSet(E))return}}z=z.faceSuccessor}while(z!==M);D.finishComponent(M)}static doPolygonBoolean(v,M,b,E){const D=new qi,X=Rr.BOUNDARY_EDGE|Rr.PRIMARY_EDGE,z=lr.addLoopsWithEdgeTagToGraph(D,v,X,1),R=lr.addLoopsWithEdgeTagToGraph(D,M,X,2);if(E&&E("unmerged loops",D,"U"),z||R){Cs.splitIntersectingEdges(D),E&&E("After splitIntersectingEdges",D,"S"),Cs.clusterAndMergeXYTheta(D),E&&E("After clusterAndMergeXYTheta",D,"M"),new Hi(D).regularizeGraph(!0,!0),E&&E("After regularize",D,"MR");const v=Es.findMinimumAreaFace(D);if(void 0===v)return;const M=Rr.EXTERIOR,X=D.grabMask(),z=D.grabMask(),R=M|X|z;D.clearMask(R);const O=new er(b,M);return this.faceToFaceSearchFromOuterLoop(D,v,X,z,O),E&&E("After faceToFaceSearchFromOuterLoop",D,"MRX"),D.dropMask(X),D.dropMask(z),D}}static doBinaryBooleanBetweenMultiLoopInputs(v,M,b,E,D,X){const z=new qi,R=Rr.BOUNDARY_EDGE|Rr.PRIMARY_EDGE,O=rr.create(M,D);O.graph=z,O.faceAreaFunction=v=>Es.signedFaceArea(v);for(const Y of v)if(Y.length>2){const v=new sr(Y,O.groupA);lr.addLoopsWithEdgeTagToGraph(z,Y,R,v)}for(const Y of E)if(Y.length>2){const v=new sr(Y,O.groupB);lr.addLoopsWithEdgeTagToGraph(z,Y,R,v)}return Cs.splitIntersectingEdges(z),Cs.clusterAndMergeXYTheta(z),new Hi(z).regularizeGraph(!0,!0),O.runClassificationSweep(b),X&&O.unmaskMaskedNullFaces(Rr.EXTERIOR),z}}!function(v){v[v.Union=0]="Union",v[v.Parity=1]="Parity",v[v.Intersection=2]="Intersection",v[v.NonBounding=-1]="NonBounding"}(no||(no={}));class sr{constructor(v,M){this.region=v,this.parentGroup=M,this.sweepState=0}clearState(){this.sweepState=0}}class nr{constructor(v,M){this.members=[],this.parent=v,this.groupOpType=M,this._numIn=0}clearState(){for(const v of this.members)v.clearState();this._numIn=0}range(){const v=ut.createNull();for(const M of this.members)if(M.region instanceof Nt)M.region.extendRange(v);else{const b=ut.createFromVariantData(M.region);v.extendRange(b)}return v}getInOut(){return this.groupOpType===no.Union?this._numIn>0:this.groupOpType===no.Parity?K.isOdd(this._numIn):this.groupOpType===no.Intersection&&this._numIn===this.members.length}addMember(v,M=!1){if(v instanceof Oe||v instanceof ii){const M=v.clone();lr.consolidateAdjacentPrimitives(M),this.members.push(new sr(M,this))}else if(v instanceof Ji)for(const b of v.children)this.addMember(b);else if(Array.isArray(v))for(const b of v)this.addMember(b);else M&&v instanceof we&&this.members.push(new sr(v,this))}recordMemberStateChange(v,M){const b=K.isOdd(v),E=K.isOdd(M);!b&&E?this._numIn++:b&&!E&&this._numIn--}}class rr{constructor(v,M){this.groupA=new nr(this,v),this.groupB=new nr(this,M),this.extraGeometry=new nr(this,no.NonBounding),this.binaryOp=ro.Union}static create(v,M){return new rr(v,M)}addMembers(v,M){this.groupA.addMember(v),this.groupB.addMember(M),this.addConnectives()}addConnectives(){const v=this.groupA.range(),M=this.groupB.range(),b=v.union(M),E=lr.computeXYAreaTolerance(b);let D=.1;this._workSegment=qe.findExtremePointsInDirection(b.corners(),rr._bridgeDirection,this._workSegment),this._workSegment&&(D*=this._workSegment.point0Ref.distanceXY(this._workSegment.point1Ref));const X=[],o=v=>{const M=lr.computeXYArea(v);void 0===M||Math.abs(M)<E||(this._workSegment=qe.findExtremePointsInDirection(v,rr._bridgeDirection,this._workSegment),this._workSegment&&X.push(this._workSegment.point1Ref))};for(const R of[this.groupA.members,this.groupB.members])for(const v of R)if(v.region instanceof Oe)o(v.region);else if(v.region instanceof ii)for(const M of v.region.children)o(M);const z=Mt.createZero();for(const R of X){const v=D+Mt.create(R,rr._bridgeDirection,z).intersectionWithRange3d(b).high,M=Q.createAdd2Scaled(R,1,rr._bridgeDirection,v),E=we.createXYXY(R.x,R.y,M.x,M.y);this.extraGeometry.addMember(E,!0)}}annotateAndMergeCurvesInGraph(v=K.smallMetricDistance){const M=[];for(const D of[this.groupA,this.groupB,this.extraGeometry])for(const v of D.members){let b=M.length;if(v.region instanceof Nt)for(lr.collectCurvePrimitives(v.region,M,!0,!0);b<M.length;b++)M[b].parent=v}const b=Xi.allIntersectionsAmongPrimitivesXY(M,v),E=Jn.assembleHalfEdgeGraph(M,b,v);this.graph=E,this.faceAreaFunction=ar}runClassificationSweep(v,M){this._announceFaceFunction=M,this.binaryOp=v,this.graph.clearMask(Rr.EXTERIOR);for(const X of[this.groupA,this.groupB])X.clearState();const b=this.graph.grabMask(),E=this.graph.grabMask(),D=hr.create(this.graph);for(const X of D.components){const v=Es.findMinimumAreaFace(X.faces,this.faceAreaFunction);if(v){const M=Rr.EXTERIOR|b|E;this.graph.clearMask(M),ir.faceToFaceSearchFromOuterLoop(this.graph,v,b,E,this)}}this.graph.dropMask(b),this.graph.dropMask(E)}unmaskMaskedNullFaces(v){for(const M of this.graph.allHalfEdges){const b=M.faceSuccessor;b.faceSuccessor===M&&M.getMask(v)&&b.getMask(v)&&(M.edgeMate.getMask(v)&&b.edgeMate.getMask(v)||(M.clearMask(v),b.clearMask(v)))}}getInOut(){return this.binaryOp===ro.Union?this.groupA.getInOut()||this.groupB.getInOut():this.binaryOp===ro.Intersection?this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===ro.AMinusB?this.groupA.getInOut()&&!this.groupB.getInOut():this.binaryOp===ro.BMinusA?!this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===ro.Parity&&this.groupA.getInOut()!==this.groupB.getInOut()}recordTransitionAcrossEdge(v,M){const i=v=>{if(v.parentGroup.groupOpType===no.NonBounding)return v;if(0!==M){const b=v.sweepState;v.sweepState+=M,v.parentGroup.recordMemberStateChange(b,v.sweepState)}return v},b=v.edgeTag;if(b instanceof sr)return i(b);if(b instanceof vt){const v=b.curve.parent;if(v instanceof sr)return i(v)}}startComponent(v){return v.setMaskAroundFace(Rr.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,v,-1,ar(v)),!0}finishComponent(v){return!0}enterFace(v,M){this.recordTransitionAcrossEdge(M,1);const b=this.getInOut();return b||M.setMaskAroundFace(Rr.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,M,b?1:0,ar(M)),!0}leaveFace(v,M){return this.recordTransitionAcrossEdge(M,-1),!0}}function or(v,M,b,E){let D;D=v&&v.point1?-(v.point1.x-v.point.x)*(.5*(v.point.y+v.point1.y)-E.y):-(b.x-M.x)*(.5*(M.y+b.y)-E.y);let X=0;return v&&v.curve&&v.hasFraction1&&(v.curve instanceof we||v.curve instanceof ti&&(X=v.curve.areaToChordXY(v.fraction,v.fraction1))),D+X}function ar(v){let M=0,b=v;do{M+=b.sortData*or(b.edgeTag,b,b.faceSuccessor,v)}while((b=b.faceSuccessor)!==v);return M}rr._bridgeDirection=$.createNormalized(1,-.12328974132467);class cr{constructor(v){this.faces=v,this.range=gt.createNull(),this.faceAreas=[]}buildFaceData(v,M){const i=M=>(v?v(M,this.range):this.range.extendXY(M.x,M.y),0);this.range.setNull();for(const b of this.faces)b.sumAroundFace(i);this.faceAreas.length=0,M||(M=v=>Es.signedFaceArea(v));for(const b of this.faces)this.faceAreas.push(M(b))}}class hr{constructor(v){this.graph=v,this.components=[]}static create(v,M){const b=new hr(v),E=Es.collectConnectedComponentsWithExteriorParityMasks(v,void 0);for(const D of E){const v=new cr(D);v.buildFaceData(M,ar),b.components.push(v)}return b}}!function(v){v[v.Union=0]="Union",v[v.Parity=1]="Parity",v[v.Intersection=2]="Intersection",v[v.AMinusB=3]="AMinusB",v[v.BMinusA=4]="BMinusA"}(ro||(ro={}));class lr{static computeXYAreaMoments(v){const M=new $n,b=v.dispatchToGeometryHandler(M);if(b instanceof ni)return b.shiftOriginAndSumsToCentroidOfSums(),b}static computeXYAreaTolerance(v,M=K.smallMetricDistance){const b=.5*M;return b*(v.xLength()+v.yLength()+b)}static computeXYArea(v){const M=new $n,b=v.dispatchToGeometryHandler(M);if(b instanceof ni)return b.quantitySum}static computeXYZWireMomentSums(v){const M=new Ln;M.visitLeaves(v);const b=M.momentData;return b.shiftOriginAndSumsToCentroidOfSums(),b}static addLoopsToGraph(v,M,b){if(M instanceof Oe){const E=M.getPackedStrokes();E&&this.addLoopsToGraph(v,E,b)}else if(M instanceof ii)for(const E of M.children){const M=E.getPackedStrokes();M&&this.addLoopsToGraph(v,M,b)}else if(M instanceof it){const E=Ps.directCreateFaceLoopFromCoordinates(v,M);void 0!==E&&b(v,E)}else if(Array.isArray(M)&&M.length>0)if(Q.isAnyImmediatePointType(M[0])){const E=Ps.directCreateFaceLoopFromCoordinates(v,M);void 0!==E&&b(v,E)}else if(M[0]instanceof it)for(const E of M){const M=Ps.directCreateFaceLoopFromCoordinates(v,E);void 0!==M&&b(v,M)}else for(const E of M)Array.isArray(E)&&this.addLoopsToGraph(v,E,b)}static addLoopsWithEdgeTagToGraph(v,M,b,E){const D=[];if(this.addLoopsToGraph(v,M,((v,M)=>{M&&(D.push(M),M.setMaskAndEdgeTagAroundFace(b,E,!0))})),D.length>0)return D}static finishGraphToPolyface(v,M){if(v)return M&&(Ps.triangulateAllPositiveAreaFaces(v),Ps.flipTriangles(v)),On.graphToPolyface(v)}static polygonXYAreaIntersectLoopsToPolyface(v,M,b=!1){const E=ir.doPolygonBoolean(v,M,((v,M)=>v&&M),this._graphCheckPointFunction);return this.finishGraphToPolyface(E,b)}static polygonXYAreaUnionLoopsToPolyface(v,M,b=!1){const E=ir.doPolygonBoolean(v,M,((v,M)=>v||M),this._graphCheckPointFunction);return this.finishGraphToPolyface(E,b)}static polygonXYAreaDifferenceLoopsToPolyface(v,M,b=!1){const E=ir.doPolygonBoolean(v,M,((v,M)=>v&&!M),this._graphCheckPointFunction);return this.finishGraphToPolyface(E,b)}static regionBooleanXY(v,M,b,E=K.smallMetricDistance){const D=Ji.create(),X=rr.create(no.Union,no.Union);X.addMembers(v,M),X.annotateAndMergeCurvesInGraph(E);const z=X.groupA.range().union(X.groupB.range()),R=this.computeXYAreaTolerance(z,E);return X.runClassificationSweep(b,((v,M,b,E)=>{if(!(M.countEdgesAroundFace()<2||Math.abs(E)<R||1!==b)){const v=Jn.createLoopInFace(M);v&&D.tryAddChild(v)}})),D}static polygonBooleanXYToPolyface(v,M,b,E=!1){const D=ir.doBinaryBooleanBetweenMultiLoopInputs(v,no.Union,M,b,no.Union,!0);return this.finishGraphToPolyface(D,E)}static polygonBooleanXYToLoops(v,M,b){const E=ir.doBinaryBooleanBetweenMultiLoopInputs(v,no.Union,M,b,no.Union,!0);if(!E)return;const D=Es.collectExtendedBoundaryLoopsInGraph(E,Rr.EXTERIOR),X=[];for(const z of D){const v=new nt;for(const b of z)v.pushXYZ(b.x,b.y,b.z);v.pushWrap(1);const M=Oe.create();M.tryAddChild(ke.createCapture(v)),X.push(M)}return lr.sortOuterAndHoleLoopsXY(X)}static constructPolygonWireXYOffset(v,M,b){return(new Ni).constructPolygonWireXYOffset(v,M,b)}static constructCurveXYOffset(v,M){const b=Se.create(M);return Oi.constructCurveXYOffset(v,b)}static testPointInOnOutRegionXY(v,M,b){return Gn.testPointInOnOutRegionXY(v,M,b)}static createLoopPathOrBagOfCurves(v,M=!0,b=!1){const E=v.length;if(0===E)return;let D,X=0,z=!1;M&&(X=K.maxXY(X,v[0].startPoint().distance(v[E-1].endPoint())));for(let R=0;R+1<E;R++)X=K.maxXY(X,v[R].endPoint().distance(v[R+1].startPoint()));K.isSmallMetricDistance(X)?(D=M?Oe.create():Ve.create(),z=!0):D=Ye.create();for(const R of v)D.tryAddChild(R);return z&&b&&lr.consolidateAdjacentPrimitives(D),D}static setCheckPointFunction(v){this._graphCheckPointFunction=v}static cloneCurvesWithXYSplits(v,M){return Wn.cloneCurvesWithXYSplits(v,M)}static splitToPathsBetweenBreaks(v,M){if(void 0===v)return;if(v instanceof oe)return v;const b=v.collectCurvePrimitives(),E=new Un(M);for(const D of b)E.announceCurvePrimitive(D);return E.grabResult()}static collectInsideAndOutsideOffsets(v,M,b){return Oi.collectInsideAndOutsideXYOffsets(v,M,b)}static collectChains(v,M=K.smallMetricDistance){return Oi.collectChains(v,M)}static splitPathsByRegionInOnOutXY(v,M){const b={insideParts:[],outsideParts:[],coincidentParts:[]},E=lr.cloneCurvesWithXYSplits(v,M),D=lr.splitToPathsBetweenBreaks(E,!0);if(D instanceof ze)for(const X of D.children){const v=ze.createCurveLocationDetailOnAnyCurvePrimitive(X);v&&dr(X,lr.testPointInOnOutRegionXY(M,v.point.x,v.point.y),b.outsideParts,b.coincidentParts,b.insideParts)}else if(D instanceof oe){const v=ze.createCurveLocationDetailOnAnyCurvePrimitive(D);v&&dr(D,lr.testPointInOnOutRegionXY(M,v.point.x,v.point.y),b.outsideParts,b.coincidentParts,b.insideParts)}return b}static rectangleEdgeTransform(v,M=!0){if(v instanceof ke)return this.rectangleEdgeTransform(v.packedPoints);if(v instanceof it){let b;if(M&&5===v.length){if(!K.isSmallMetricDistance(v.distanceIndexIndex(0,4)))return;b=v}else if(M||4!==v.length){if(v.length<(M?5:4))return;if(b=nt.create(v),si.compressInPlaceByShortEdgeLength(b,K.smallMetricDistance),b.length<(M?5:4))return}else b=v;const E=b.vectorIndexIndex(0,1),D=b.vectorIndexIndex(0,3),X=b.vectorIndexIndex(1,2),z=E.crossProduct(D);if(z.normalizeInPlace()&&X.isAlmostEqual(D)&&E.isPerpendicularTo(D))return pt.createOriginAndMatrixColumns(b.getPoint3dAtUncheckedPointIndex(0),E,D,z)}else{if(Array.isArray(v))return this.rectangleEdgeTransform(new ae(v),M);if(v instanceof Oe&&1===v.children.length&&v.children[0]instanceof ke)return this.rectangleEdgeTransform(v.children[0].packedPoints,!0);if(v instanceof Ve&&1===v.children.length&&v.children[0]instanceof ke)return this.rectangleEdgeTransform(v.children[0].packedPoints,M);if(v instanceof Ne&&!v.checkForNonLinearPrimitives()){const M=v.getPackedStrokes();if(M)return this.rectangleEdgeTransform(M)}}}static consolidateAdjacentPrimitives(v,M){const b=new Zn(M);v.dispatchToGeometryHandler(b)}static sortOuterAndHoleLoopsXY(v){const M=[];for(const b of v)if(b instanceof Oe)mr.pushLoop(M,b);else if(b instanceof it){const v=Oe.createPolygon(b);mr.pushLoop(M,v)}return mr.sortAsAnyRegion(M)}static constructAllXYRegionLoops(v,M=K.smallMetricDistance){const b=lr.collectCurvePrimitives(v,void 0,!0,!0),E=this.curveArrayRange(b),D=this.computeXYAreaTolerance(E,M),X=Xi.allIntersectionsAmongPrimitivesXY(b,M),z=Jn.assembleHalfEdgeGraph(b,X,M);return Jn.collectSignedLoopSetsInHalfEdgeGraph(z,D)}static collectCurvePrimitives(v,M,b=!1,E=!1){const D=void 0===M?[]:M;if(v instanceof oe)v.collectCurvePrimitives(D,b,E);else if(v instanceof ze)v.collectCurvePrimitives(D,b,E);else if(Array.isArray(v))for(const X of v)this.collectCurvePrimitives(X,D,b,E);return D}static expandLineStrings(v){const M=[];for(const b of v)if(b instanceof ke)for(let v=0;v+1<b.packedPoints.length;v++){const E=b.getIndexedSegment(v);void 0!==E&&M.push(E)}else M.push(b);return M}static curveArrayRange(v,M){const b=ut.create();if(v instanceof Nt)v.extendRange(b,M);else if(Array.isArray(v))for(const E of v)E instanceof Nt?E.extendRange(b,M):E instanceof Q?b.extendPoint(E,M):E instanceof nt?b.extendRange(E.getRange(M)):Array.isArray(E)&&b.extendRange(this.curveArrayRange(E,M));return b}static triangulateStrokedRegionComponent(v){let M;if(Array.isArray(v)){if(0===v.length)return;const b=v[0];if(Q.isAnyImmediatePointType(b))M=Ps.createTriangulatedGraphFromSingleLoop(v);else if(v.length>1){let E;if(b instanceof st)E=v;else{E=[];for(const M of v)E.push(nt.create(M))}const D=vr.sortOuterAndHoleLoopsXY(E);1===D.length&&(M=Ps.createTriangulatedGraphFromLoops(D[0]))&&Ps.flipTriangles(M)}else M=Ps.createTriangulatedGraphFromSingleLoop(b)}else M=Ps.createTriangulatedGraphFromSingleLoop(v);return M||(M=ir.doPolygonBoolean(v,[],((v,M)=>v)))&&Ps.triangulateAllPositiveAreaFaces(M)&&Ps.flipTriangles(M),M}static strokeRegionComponent(v,M){const b=v.cloneStroked(M),E=[];if(b instanceof Oe)b.children.length>0&&b.children[0]instanceof ke&&E.push(b.children[0].packedPoints);else if(b instanceof ii)for(const D of b.children)D.children.length>0&&D.children[0]instanceof ke&&E.push(D.children[0].packedPoints);return E}static triangulateRegionComponent(v,M){const b=this.strokeRegionComponent(v,M);return this.triangulateStrokedRegionComponent(b)}static facetRegionXY(v,M){let b;if(v instanceof Ji)for(const E of v.children){const v=lr.triangulateRegionComponent(E,M);v&&(b?b.allHalfEdges.push(...v.allHalfEdges):b=v)}else b=this.triangulateRegionComponent(v,M);if(b)return M?.maximizeConvexFacets&&ws.expandConvexFaces(b),On.graphToPolyface(b,M)}static convexDecomposePolygonXY(v,M=!0){const b=lr.triangulateStrokedRegionComponent(v);if(!b)return;M&&ws.expandConvexFaces(b);const E=[];return b.announceFaceLoops(((v,M)=>(M.isMaskSet(Rr.EXTERIOR)||E.push(nt.create(M.collectAroundFace((v=>v.getPoint3d())))),!0))),E}}function dr(v,M,b,E,D){M>0?D.push(v):M<0?b.push(v):E.push(v)}class ur{constructor(){this.consolidateLinearGeometry=!0,this.consolidateCompatibleArcs=!0,this.duplicatePointTolerance=K.smallMetricDistance,this.colinearPointTolerance=K.smallMetricDistance}}class fr{}class gr extends fr{get signedArea(){return this._signedArea}constructor(v){super(),this.data=v,this._signedArea=vr.areaXY(v)}classifyPointXY(v){return vr.classifyPointInPolygonXY(v.x,v.y,this.data)}getAnyInteriorPoint(){for(let v=0;v<this.data.length;v++){const M=this.constructInteriorPointNearEdge(v,.2349);if(void 0!==M)return M}}grabPolygon(){return this.data}grabLoop(){return Oe.createPolygon(this.data)}reverseForAreaSign(v){v*this._signedArea<0&&(this.data.reverseInPlace(),this._signedArea*=-1)}constructInteriorPointNearEdge(v,M){if(v+1<this.data.length){const b=this.data.getPoint3dAtUncheckedPointIndex(v),E=this.data.getPoint3dAtUncheckedPointIndex(v+1),D=b.vectorTo(E),X=b.interpolate(M,E);if(D.rotate90CCWXY(D),D.normalizeInPlace()){this._signedArea<0&&D.scaleInPlace(-1);const v=Math.sqrt(Math.abs(this._signedArea));for(let M=1e-5;M<3;M*=5){const b=X.plusScaled(D,M*v);if(1===this.classifyPointXY(b))return b}}}}}class pr extends fr{get signedArea(){return this._signedArea}constructor(v){super(),this.data=v;const M=lr.computeXYAreaMoments(v);this._signedArea=void 0!==M?M.quantitySum:0}classifyPointXY(v){return lr.testPointInOnOutRegionXY(this.data,v.x,v.y)}constructInteriorPointNearChild(v,M){if(v<this.data.children.length){const b=this.data.children[v].fractionToPointAndUnitTangent(M);b.direction.rotate90CCWXY(b.direction),this._signedArea<0&&b.direction.scaleInPlace(-1);const E=Math.sqrt(Math.abs(this._signedArea));for(let v=1e-5;v<3;v*=5){const M=b.fractionToPoint(v*E);if(1===this.classifyPointXY(M))return M}}}getAnyInteriorPoint(){for(let v=0;v<this.data.children.length;v++){const M=this.constructInteriorPointNearChild(v,.2349);if(void 0!==M)return M}}grabPolygon(){const v=this.data.cloneStroked();if(v instanceof Ne){const M=ke.create();for(const b of v.children)b instanceof oe&&b.emitStrokes(M);return M.numPoints()>0?M.packedPoints:void 0}}grabLoop(){return this.data}reverseForAreaSign(v){v*this._signedArea<0&&(this.data.reverseChildrenInPlace(),this._signedArea*=-1)}}class mr{constructor(v,M){this._loopCarrier=v instanceof st?new gr(v):new pr(v),this.range=M,this.sortKey=Math.abs(this._loopCarrier.signedArea),this.isHole=!1}static pushPolygon(v,M){const b=M.getRange(),E=new mr(M,b);return E.sortKey>0&&(v.push(E),!0)}static pushLoop(v,M){const b=M.range(),E=new mr(M,b);return E.sortKey>0&&(v.push(E),!0)}static assignParentsAndDepth(v){v.sort(((v,M)=>M.sortKey-v.sortKey));for(let M=v.length;M-- >0;){const b=v[M],E=b._loopCarrier.getAnyInteriorPoint();if(void 0!==E){v[M].parentIndex=void 0,v[M].outputSetIndex=void 0;for(let D=M;D-- >0;){const M=v[D];if(M.range.containsXY(E.x,E.y)&&1===M._loopCarrier.classifyPointXY(E)){b.parentIndex=D;break}}}}}static assemblePolygonSet(v){const M=[];for(const b of v){b.isHole=!1;const E=b.parentIndex;void 0!==E&&(b.isHole=!v[E].isHole),b.isHole?(b._loopCarrier.reverseForAreaSign(-1),M[v[E].outputSetIndex].push(b._loopCarrier.grabPolygon())):(b._loopCarrier.reverseForAreaSign(1),b.outputSetIndex=M.length,M.push([]),M[b.outputSetIndex].push(b._loopCarrier.grabPolygon()))}return M}static assembleLoopSet(v){const M=[],b=v.length;for(let E=0;E<b;E++){const D=v[E],X=D.parentIndex;if(D.isHole=void 0!==X&&!v[X].isHole,!D.isHole){D._loopCarrier.reverseForAreaSign(1);const X=D._loopCarrier.grabLoop();let z;for(let M=E+1;M<b;M++){const b=v[M];b.parentIndex===E&&(void 0===z?(z=ii.create(),z.tryAddChild(X),b._loopCarrier.reverseForAreaSign(-1),z.tryAddChild(b._loopCarrier.grabLoop())):(b._loopCarrier.reverseForAreaSign(-1),z.tryAddChild(b._loopCarrier.grabLoop())))}void 0!==z?M.push(z):void 0!==X&&M.push(X)}}return M}static sortAsAnyRegion(v){this.assignParentsAndDepth(v);const M=this.assembleLoopSet(v);if(1===M.length)return M[0];{const v=Ji.create();for(const b of M)v.tryAddChild(b);return v}}static sortAsArrayOfArrayOfPolygons(v){return this.assignParentsAndDepth(v),this.assemblePolygonSet(v)}grabPolygon(){return this._loopCarrier.grabPolygon()}grabLoop(){return this._loopCarrier.grabLoop()}reverseForAreaSign(v){this._loopCarrier.reverseForAreaSign(v)}getAnyInteriorPoint(){return this._loopCarrier.getAnyInteriorPoint()}}class xr{constructor(){this.point=new Q,this.a=0,this.v=new $,this.code=N.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.point.setZero(),this.a=0,this.v.setZero(),this.code=N.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(v){return void 0===v?v=new xr:v.invalidate(),v}copyContentsFrom(v){this.point.setFrom(v.point),this.a=v.a,this.v.setFrom(v.v),this.code=v.code,this.closestEdgeIndex=v.closestEdgeIndex,this.closestEdgeParam=v.closestEdgeParam}get isValid(){return this.code!==N.Unknown}get isInsideOrOn(){return this.code===N.InsidePolygon||this.code===N.OnPolygonVertex||this.code===N.OnPolygonEdgeInterior||this.code===N.InsidePolygonProjectsToVertex||this.code===N.InsidePolygonProjectsToEdgeInterior}}class yr{constructor(v){this.xyz=v,this.edge=void 0,this.sortCoordinate0=this.sortCoordinate1=0,this.sortDelta=0,this.isNotch=!1}static createCaptureWithReturnEdge(v){const M=new yr(v);return v.length>=2&&(M.edge=Mt.createStartEnd(v.front(),v.back())),M}setSortCoordinates(v){this.sortDelta=this.edge.direction.dotProduct(v.direction);const M=v.dotProductToPoint(this.edge.origin);this.sortDelta>=0?(this.sortCoordinate0=M,this.sortCoordinate1=M+this.sortDelta):(this.sortCoordinate0=M+this.sortDelta,this.sortCoordinate1=M)}containsSortLimits(v){return v.sortCoordinate0>=this.sortCoordinate1||v.sortCoordinate0<=this.sortCoordinate0||v.sortCoordinate1<=this.sortCoordinate0||v.sortCoordinate1>=this.sortCoordinate1?0:this.sortDelta*v.sortDelta>0?1:-1}absorb(v){this.xyz.pushFromGrowableXYZArray(v.xyz),this.sortCoordinate0=v.sortCoordinate1}static sortFunction(v,M){return v.sortCoordinate0-M.sortCoordinate0>0?1:-1}front(v){return this.xyz.front(v)}back(v){return this.xyz.back(v)}}class _r{constructor(){this.inputLoops=[],this.outputLoops=[]}mostDistantPoint(v,M,b){let E,D=-1;b.setZero();for(const X of this.inputLoops)X.front(M),E=M.distanceSquared(v),E>D&&(D=E,b.setFromPoint3d(M)),X.back(M),E=M.distanceSquared(v),E>D&&(D=E,b.setFromPoint3d(M))}sortInputs(){if(this.inputLoops.length>0&&this.inputLoops[0].xyz.length>0){const v=this.inputLoops[0].xyz.front(),M=Q.create(),b=Q.create();this.mostDistantPoint(v,M,b),this.mostDistantPoint(b,M,v);const E=Mt.createStartEnd(v,b);E.direction.normalizeInPlace();for(const D of this.inputLoops)D.setSortCoordinates(E);this.inputLoops.sort(((v,M)=>yr.sortFunction(v,M)))}}sortAndMergeLoops(){this.sortInputs();const v=this.inputLoops,M=this.outputLoops,b=[];M.length=0;for(const E of v){for(E.isNotch=!1;b.length>0;){const v=b[b.length-1],D=v.containsSortLimits(E);if(0!==D){if(1===D){E.isNotch=!1;break}v.absorb(E),E.isNotch=!0;break}v.isNotch||M.push(v),b.pop()}b.push(E)}for(const E of b)E.isNotch||M.push(E)}}class vr{static sumTriangleAreas(v){let M=0;const b=v.length;if(Array.isArray(v)){if(b>=3){const E=v[0],D=E.vectorTo(v[1]);let X=$.create();for(let z=2;z<b;z++)X=E.vectorTo(v[z],X),M+=D.crossProductMagnitude(X),D.setFrom(X)}return.5*M}const E=$.create();for(let D=2;D<b;D++)v.crossProductIndexIndexIndex(0,D-1,D,E),M+=E.magnitude();return.5*M}static sumTriangleAreasPerpendicularToUpVector(v,M){let b=M.magnitude();b<K.smallMetricDistance&&(M=$.create(0,0,1),b=1);let E=0;const D=v.length;if(Array.isArray(v)){if(D>=3){const b=v[0],X=b.vectorTo(v[1]);let z=$.create();for(let R=2;R<D;R++)z=b.vectorTo(v[R],z),E+=X.tripleProduct(z,M),X.setFrom(z)}return.5*E/b}const X=$.create();for(let z=2;z<D;z++)v.crossProductIndexIndexIndex(0,z-1,z,X),E+=X.dotProduct(M);return.5*E/b}static sumTriangleAreasXY(v){let M=0;const b=v.length;if(b>=3){const E=v[0],D=E.vectorTo(v[1]);let X=$.create();for(let z=2;z<b;z++)X=E.vectorTo(v[z],X),M+=D.crossProductXY(X),D.setFrom(X)}return M*=.5,M}static areaNormalGo(v,M){M?M.setZero():M=new $;const b=v.length;if(3===b)v.crossProductIndexIndexIndex(0,1,2,M);else if(b>3)for(let E=2;E<b;E++)v.accumulateCrossProductIndexIndexIndex(0,E-1,E,M);return M.scaleInPlace(.5),M.isZero?void 0:M}static areaNormal(v,M){return M||(M=$.create()),vr.areaNormalGo(new ae(v),M),M}static area(v){return vr.areaNormal(v).magnitude()}static areaXY(v){let M=0;if(v instanceof it){if(v.length>2){const b=v.getXAtUncheckedPointIndex(0),E=v.getYAtUncheckedPointIndex(0);let D,X,z=v.getXAtUncheckedPointIndex(1)-b,R=v.getYAtUncheckedPointIndex(1)-E;for(let O=2;O+1<v.length;O++,z=D,R=X)D=v.getXAtUncheckedPointIndex(O)-b,X=v.getYAtUncheckedPointIndex(O)-E,M+=K.crossProductXYXY(z,R,D,X)}}else for(let b=1;b+1<v.length;b++)M+=v[0].crossProductToPointsXY(v[b],v[b+1]);return.5*M}static sumAreaXY(v){let M=0;for(const b of v)M+=this.areaXY(b);return M}static centroidAreaNormal(v){if(Array.isArray(v)){const M=new ae(v);return this.centroidAreaNormal(M)}const M=v.length;if(3===M){const M=v.crossProductIndexIndexIndex(0,1,2),b=.5*M.magnitude(),E=v.getPoint3dAtCheckedPointIndex(0);v.accumulateScaledXYZ(1,1,E),v.accumulateScaledXYZ(2,1,E),E.scaleInPlace(1/3);const D=Mt.createCapture(E,M);return D.tryNormalizeInPlaceWithAreaWeight(b)?D:void 0}if(M>=3){const b=$.createZero();for(let V=2;V<M;V++)v.accumulateCrossProductIndexIndexIndex(0,V-1,V,b);b.normalizeInPlace();const E=v.getPoint3dAtCheckedPointIndex(0),D=$.create(),X=$.create();v.vectorXYAndZIndex(E,1,D);let z=$.create();const R=$.createZero(),O=$.createZero();let Y;for(let V=2;V<M;V++){v.vectorXYAndZIndex(E,V,X),z=D.crossProduct(X,z),Y=b.dotProduct(z),O.addInPlace(z);const M=Y/6;R.plus2Scaled(D,M,X,M,R),D.setFrom(X)}const N=.5*O.magnitude(),B=K.conditionalDivideFraction(1,N);if(void 0!==B){const v=Mt.createCapture(E.plusScaled(R,B),O);return v.tryNormalizeInPlaceWithAreaWeight(N),v}}}static centroidAndAreaXY(v,M){let b=0;if(M.set(0,0),v.length<3)return;const E=v[0];let D=J.create(0,0),X=0;for(let R=1;R+1<v.length;R++){const M=E.vectorTo(v[R]),b=E.vectorTo(v[R+1]),z=M.crossProduct(b);D=D.plus(M.plus(b).scale(z)),X+=z}b=.5*X;const z=K.conditionalDivideFraction(1,6*b);if(void 0!==z)return M.setFrom(E.plusScaled(D,z)),b;M.setFrom(E)}static unitNormal(v,M){M.setZero();let b=v.length;return b>1&&v.getPoint3dAtUncheckedPointIndex(0).isExactEqual(v.getPoint3dAtUncheckedPointIndex(b-1))&&--b,3===b?(v.crossProductIndexIndexIndex(0,1,2,M),M.normalizeInPlace()):4===b?(v.vectorIndexIndex(0,2,vr._vector0),v.vectorIndexIndex(1,3,vr._vector1),vr._vector0.crossProduct(vr._vector1,M),M.normalizeInPlace()):(vr.areaNormalGo(v,M),M.normalizeInPlace())}static addSecondMomentAreaProducts(v,M,b){this.addSecondMomentTransformedProducts(vr._triangleMomentWeights,v,M,2,b)}static addSecondMomentVolumeProducts(v,M,b){this.addSecondMomentTransformedProducts(vr._tetrahedralMomentWeights,v,M,3,b)}static addSecondMomentTransformedProducts(v,M,b,E,D){const X=vr._normal;if(vr.unitNormal(M,X)){const z=vr._vector0,R=vr._vector1,O=vr._vector2,Y=vr._matrixA,N=vr._matrixB,B=vr._matrixC,V=M.vectorXYAndZIndex(b,0,vr._vectorOrigin),L=M.length;let U=0;for(let Sr=2;Sr<L;Sr++)2===E?(M.vectorIndexIndex(0,Sr-1,z),M.vectorIndexIndex(0,Sr,R),U=X.tripleProduct(z,R),Y.setOriginAndVectors(V,z,R,X),Y.multiplyMatrixMatrix(v,N),N.multiplyMatrixMatrixTranspose(Y,B),D.addScaledInPlace(B,U)):3===E&&(M.vectorXYAndZIndex(b,0,z),M.vectorXYAndZIndex(b,Sr-1,R),M.vectorXYAndZIndex(b,Sr,O),U=z.tripleProduct(R,O),Y.setOriginAndVectors(b,z,R,O),Y.multiplyMatrixMatrix(v,N),N.multiplyMatrixMatrixTranspose(Y,B),D.addScaledInPlace(B,U))}}static testXYPolygonTurningDirections(v){let M=v.length,b=M-1;for(;b>1&&v[b].x===v[0].x&&v[b].y===v[0].y;)M=b--;if(M>2){let E=H.create(v[b].x-v[b-1].x,v[b].y-v[b-1].y);const D=H.create(v[0].x-v[b].x,v[0].y-v[b].y),X=E.x*D.y-E.y*D.x;for(let b=1;b<M;b++)if(E=D.clone(),H.create(v[b].x-v[b-1].x,v[b].y-v[b-1].y,D),(E.x*D.y-E.y*D.x)*X<=0)return 0;return X>0?1:-1}return 0}static isConvex(v){if(!(v instanceof it))return this.isConvex(new ae(v));let M=v.length;M>1&&v.getPoint3dAtUncheckedPointIndex(0).isExactEqual(v.getPoint3dAtUncheckedPointIndex(M-1))&&--M;const b=$.create();if(!this.unitNormal(v,b))return!1;let E=0,D=0;const X=this._vector0;let z=$.createStartEnd(v.getPoint3dAtUncheckedPointIndex(M-1),v.getPoint3dAtUncheckedPointIndex(0),this._vector1);for(let R=1;R<=M;R++){X.setFromVector3d(z),z=$.createStartEnd(v.getPoint3dAtUncheckedPointIndex(R-1),v.getPoint3dAtUncheckedPointIndex(R%M),z);const O=b.tripleProduct(X,z);O>=0?E+=O:D+=O}return Math.abs(D)<K.smallMetricDistanceSquared*E}static classifyPointInPolygon(v,M,b){const E=new Rt(v,M);let D=0;const X=b.length;let z,R=-1;for(D=0;D<X;D++)if(z=D+1,z>=X&&(z=0),E.tryStartEdge(b[D].x,b[D].y,b[z].x,b[z].y)){R=z;break}if(!(R<0)){for(let v=1;v<=X;v++)if(z=R+v,z>=X&&(z-=X),!E.advance(b[z].x,b[z].y))return E.classifyCounts();return E.classifyCounts()}}static classifyPointInPolygonXY(v,M,b){const E=new Rt(v,M);let D=0;const X=b.length;let z,R=-1;for(D=0;D<X;D++)if(z=D+1,z>=X&&(z=0),E.tryStartEdge(b.getXAtUncheckedPointIndex(D),b.getYAtUncheckedPointIndex(D),b.getXAtUncheckedPointIndex(z),b.getYAtUncheckedPointIndex(z))){R=z;break}if(!(R<0)){for(let v=1;v<=X;v++)if(z=R+v,z>=X&&(z-=X),!E.advance(b.getXAtUncheckedPointIndex(z),b.getYAtUncheckedPointIndex(z)))return E.classifyCounts();return E.classifyCounts()}}static orientLoopsCCWForOutwardNormalInPlace(v,M){if(v instanceof it)return this.orientLoopsCCWForOutwardNormalInPlace([v],M);const b=[],E=$.create();let D=0;for(const X of v)if(this.unitNormal(X,E)){const v=E.dotProduct(M);b.push(v),v<=0&&X.reverseInPlace(),D++}else b.push(0);return D}static sortOuterAndHoleLoopsXY(v){const M=[];for(const b of v)mr.pushPolygon(M,b);return mr.sortAsArrayOfArrayOfPolygons(M)}static sortOuterAndHoleLoops(v,M){const b=ei.createRightHandedFrame(M,v),E=b?.inverse(),D=[];if(void 0!==E)for(const R of v){const v=new nt(R.length);for(const M of R.points)v.push(E.multiplyPoint3d(M));D.push(v)}const X=vr.sortOuterAndHoleLoopsXY(D),z=[];if(void 0!==b)for(const R of X){const v=[];for(const M of R){const E=new nt(M.length);for(const v of M.points)E.push(b.multiplyPoint3d(v));v.push(E)}z.push(v)}return z}static closestPointOnBoundary(v,M,b=K.smallMetricDistance,E){if(!(v instanceof it))return this.closestPointOnBoundary(new ae(v),M,b,E);const D=b*b;let X=v.length;for(;X>1&&!(v.distanceSquaredIndexIndex(0,X-1)>D);)--X;if(E=xr.create(E),0===X)return E;if(1===X)return v.getPoint3dAtUncheckedPointIndex(0,E.point),E.a=E.point.distance(M),E.v.setZero(),E.code=N.OnPolygonVertex,E.closestEdgeIndex=0,E.closestEdgeParam=0,E;let z=X-1,R=K.largeCoordinateResult;for(let O=0;O<X;++O){let b=O+1;b===X&&(b=0);const Y=v.distanceSquaredIndexIndex(O,b);if(Y<=D)continue;const B=v.distanceSquaredIndexXYAndZ(O,M),V=v.dotProductIndexIndexXYAndZ(O,b,M)/Y;if(V<=0){const X=B;if(X<=D)return v.getPoint3dAtUncheckedPointIndex(O,E.point),E.a=Math.sqrt(X),E.v.setZero(),E.code=N.OnPolygonVertex,E.closestEdgeIndex=O,E.closestEdgeParam=0,E;X<R&&v.dotProductIndexIndexXYAndZ(O,z,M)<=0&&(v.getPoint3dAtUncheckedPointIndex(O,E.point),E.a=Math.sqrt(X),v.crossProductIndexIndexIndex(O,z,b,E.v),E.code=N.OnPolygonVertex,E.closestEdgeIndex=O,E.closestEdgeParam=0,R=X)}else if(V<=1){const X=B-V*V*Y;if(X<=D){const M=B;if(V<=.5&&M<=D)return v.getPoint3dAtUncheckedPointIndex(O,E.point),E.a=Math.sqrt(M),E.v.setZero(),E.code=N.OnPolygonVertex,E.closestEdgeIndex=O,E.closestEdgeParam=0,E;const z=X+(1-V)*(1-V)*Y;return V>.5&&z<=D?(v.getPoint3dAtUncheckedPointIndex(b,E.point),E.a=Math.sqrt(z),E.v.setZero(),E.code=N.OnPolygonVertex,E.closestEdgeIndex=b,E.closestEdgeParam=0,E):(v.interpolateIndexIndex(O,V,b,E.point),E.a=Math.sqrt(X),E.v.setZero(),E.code=N.OnPolygonEdgeInterior,E.closestEdgeIndex=O,E.closestEdgeParam=V,E)}X<R&&(v.interpolateIndexIndex(O,V,b,E.point),E.a=Math.sqrt(X),v.crossProductIndexIndexXYAndZ(O,b,M,E.v),E.code=N.OnPolygonEdgeInterior,E.closestEdgeIndex=O,E.closestEdgeParam=V,R=X)}z=O}return E}static intersectRay3d(v,M,b=K.smallMetricDistance,E){if(!(v instanceof it))return this.intersectRay3d(new ae(v),M,b,E);if(!this.unitNormal(v,this._normal))return xr.create(E);this._workPlane=yt.createXYZUVW(v.getXAtUncheckedPointIndex(0),v.getYAtUncheckedPointIndex(0),v.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane);const D=Q.createZero(this._workXYZ),X=M.intersectionWithPlane(this._workPlane,D);if(void 0===X)return xr.create(E);if((E=this.closestPointOnBoundary(v,D,b,E)).isValid){E.point.setFrom(D),E.a=X;const v=E.v.dotProduct(this._normal);0===v||(N.OnPolygonVertex===E.code?E.code=v>0?N.InsidePolygonProjectsToVertex:N.OutsidePolygonProjectsToVertex:N.OnPolygonEdgeInterior===E.code&&(E.code=v>0?N.InsidePolygonProjectsToEdgeInterior:N.OutsidePolygonProjectsToEdgeInterior))}return E}static intersectSegment(v,M,b,E=K.smallMetricDistance,D){return this._workRay=Mt.createStartEnd(M,b,this._workRay),this.intersectRay3d(v,this._workRay,E,D)}static computeEdgeDataXY(v,M,b,E,D=K.smallMetricDistance,X){const z=M%v.length,R=(z+1)%v.length;v.vectorIndexIndex(z,R,E).unitPerpendicularXY(E).negate(E);const O=v.getXAtUncheckedPointIndex(z)-b.x,Y=v.getYAtUncheckedPointIndex(z)-b.y;let N=K.dotProductXYXY(O,Y,E.x,E.y);const B=K.crossProductXYXY(O,Y,E.x,E.y),V=K.distanceXYXY(v.getXAtUncheckedPointIndex(z),v.getYAtUncheckedPointIndex(z),v.getXAtUncheckedPointIndex(R),v.getYAtUncheckedPointIndex(R));let L=K.safeDivideFraction(B,V,0);return K.isSameCoordinate(0,N,D)&&(N=0),K.isSameCoordinate(0,L,D)?L=0:K.isSameCoordinate(1,L,D)&&(L=1),H.create(N,L,X)}static convexBarycentricCoordinatesOnEdge(v,M,b,E,D,X,z,R){const O=!b.isZero&&0===E.x&&K.isIn01(E.y),Y=!X.isZero&&0===z.x&&K.isIn01(z.y);if(O&&Y)return R.fill(0),R[D]=1,R;const N=v.length;if(O){R.fill(0);const v=M,b=D,X=E.y;return R[v]=1-X,R[b]=X,R}if(Y){R.fill(0);const v=D,M=(D+1)%N,b=z.y;return R[v]=1-b,R[M]=b,R}}static convexBarycentricCoordinates(v,M,b=K.smallMetricDistance){if(Array.isArray(v))return this.convexBarycentricCoordinates(new ae(v),M);let E=v.length;for(;E>1&&v.getPoint3dAtUncheckedPointIndex(0).isExactEqual(v.getPoint3dAtUncheckedPointIndex(E-1));)--E;if(E<3||!vr.unitNormal(v,this._normal))return;const D=this._workMatrix3d=xt.createRigidHeadsUp(this._normal,z.ZXY,this._workMatrix3d),X=new nt(E);for(let z=0;z<E;++z)X.push(D.multiplyInverseXYZAsPoint3d(v.getXAtUncheckedPointIndex(z),v.getYAtUncheckedPointIndex(z),v.getZAtUncheckedPointIndex(z),this._workXYZ));const R=this._workXYZ=D.multiplyInverseXYZAsPoint3d(M.x,M.y,M.z,this._workXYZ);let O=E-1;const Y=this._vector0,N=this._workXY0=this.computeEdgeDataXY(X,O,R,Y,b,this._workXY0);if(N.x<0)return;const B=$.createFrom(Y,this._vector1),V=this._workXY1=H.createFrom(N,this._workXY1),L=Array(v.length).fill(0),U=b>0?1/(b*b):K.largeCoordinateResult;let Sr=0;for(let z=0;z<E;++z){const v=$.createFrom(Y,this._vector2),M=this._workXY2=z<E-1?this.computeEdgeDataXY(X,z,R,v,b,this._workXY2):H.createFrom(N,this._workXY2);if(M.x<0)return;if(void 0!==this.convexBarycentricCoordinatesOnEdge(X,O,B,V,z,v,M,L))return L;if(0===v.x&&0===v.y)continue;if(0===V.x||0===M.x)continue;const D=Math.abs(B.crossProductXY(v)),Cr=K.conditionalDivideCoordinate(D,V.x*M.x,U);if(void 0===Cr)return void e(!1);L[z]=Cr,Sr+=Cr,B.setFrom(v),V.setFrom(M),O=z}const Cr=K.conditionalDivideCoordinate(1,Sr);if(void 0!==Cr){for(let v=0;v<E;++v)L[v]*=Cr;return L}e(!1)}}vr._triangleMomentWeights=Xt.createRowValues(2/24,1/24,0,4/24,1/24,2/24,0,4/24,0,0,0,0,4/24,4/24,0,.5),vr._tetrahedralMomentWeights=Xt.createRowValues(1/60,1/120,1/120,1/24,1/120,1/60,1/120,1/24,1/120,1/120,1/60,1/24,1/24,1/24,1/24,1/6),vr._vector0=$.create(),vr._vector1=$.create(),vr._vector2=$.create(),vr._vectorOrigin=$.create(),vr._normal=$.create(),vr._matrixA=Xt.createIdentity(),vr._matrixB=Xt.createIdentity(),vr._matrixC=Xt.createIdentity();class Pr{static splitConvexPolygonInsideOutsidePlane(v,M,b,E,D){const X=Pr._xyz0Work,z=Pr._xyz1Work,R=Pr._xyz2Work,O=M.length;if(b.clear(),E.clear(),O>2){M.back(X),D.setNull();let Y=v.altitude(X);D.extendX(Y);for(let N=0;N<O;N++){M.getPoint3dAtUncheckedPointIndex(N,z);const O=v.altitude(z);D.extendX(O);let B=!1;if(Y*O<0){const v=-Y/(O-Y);v>1-1e-8&&O>=0?B=!0:(X.interpolate(v,z,R),b.push(R),E.push(R))}(O>=0||B)&&b.push(z),(O<=0||B)&&E.push(z),X.setFromPoint3d(z),Y=O}}}static clipConvexPolygonInPlace(v,M,b,E=!0,D=K.smallMetricDistance){b.clear();const X=E?1:-1,z=M.length;let R=0;const O=-D;let Y=0;if(M.length>1){let E,N=M.length-1,B=X*M.evaluateUncheckedIndexPlaneAltitude(N,v);Math.abs(B)<D&&(B=0);for(let V=0;V<z;B=E,N=V++){if(E=X*M.evaluateUncheckedIndexPlaneAltitude(V,v),Math.abs(E)<D&&(E=0),E<0&&R++,B*E<0){const v=-B/(E-B);v>1-1e-8&&E>=0||(b.pushInterpolatedFromGrowableXYZArray(M,N,v,V),E>0&&Y++)}E>=O&&(b.pushFromGrowableXYZArray(M,V),B<-O&&Y++),N=V,B=E}}return b.length<=2?M.clear():R>0&&(M.clear(),M.pushFromGrowableXYZArray(b)),b.clear(),Y}static polygonPlaneCrossings(v,M,b){if(b.length=0,M.length>=2){const E=this._xyz0Work;M.getPoint3dAtUncheckedPointIndex(M.length-1,E);let D=v.altitude(E);const X=this._xyz1Work;for(let z=0;z<M.length;z++){M.getPoint3dAtUncheckedPointIndex(z,X);const R=v.altitude(X);if(D*R<0){const v=-D/(R-D);b.push(E.interpolate(v,X))}0===R&&b.push(X.clone()),E.setFromPoint3d(X),D=R}}}static gatherCutLoopsFromPlaneClip(v,M,b=3,E=K.smallMetricDistance){const D=new _r;let X=0;const z=M.length;for(;X<z;X++){const b=M.evaluateUncheckedIndexPlaneAltitude(X,v);if(Math.abs(b)<=E)break}if(X===z)return D;let R=X;for(;R<z;){const O=new nt;O.pushFromGrowableXYZArray(M,R);let Y=R+1;for(;Y<z;){O.pushFromGrowableXYZArray(M,Y);const b=M.evaluateUncheckedIndexPlaneAltitude(Y,v);if(Math.abs(b)<=E)break;Y++}if(Y===z)for(let v=0;v<=X;v++)O.pushFromGrowableXYZArray(M,v);O.length>=b&&D.inputLoops.push(yr.createCaptureWithReturnEdge(O)),R=Y}return D}static reorderCutLoops(v){if(1!==v.inputLoops.length){if(2===v.inputLoops.length){if(v.inputLoops[0].edge.direction.dotProduct(v.inputLoops[1].edge.direction)>0)return v.outputLoops.push(v.inputLoops[0]),void v.outputLoops.push(v.inputLoops[1]);const M=v.inputLoops[1].xyz;return v.inputLoops[0].xyz.pushFromGrowableXYZArray(M),void v.outputLoops.push(v.inputLoops[0])}v.sortAndMergeLoops()}}static intersectRangeConvexPolygonInPlace(v,M){if(v.isNull)return;const b=new nt,E=Dt.create();return E.set(0,0,-1,v.high.z),this.clipConvexPolygonInPlace(E,M,b,!0),0!==M.length&&(E.set(0,0,1,-v.low.z),this.clipConvexPolygonInPlace(E,M,b,!0),0!==M.length&&(E.set(0,-1,0,v.high.y),this.clipConvexPolygonInPlace(E,M,b,!0),0!==M.length&&(E.set(0,1,0,-v.low.y),this.clipConvexPolygonInPlace(E,M,b,!0),0!==M.length&&(E.set(-1,0,0,v.high.x),this.clipConvexPolygonInPlace(E,M,b,!0),0!==M.length&&(E.set(1,0,0,-v.low.x),this.clipConvexPolygonInPlace(E,M,b,!0),0!==M.length)))))?M:void 0}}Pr._xyz0Work=Q.create(),Pr._xyz1Work=Q.create(),Pr._xyz2Work=Q.create();class Ir{static convexPolygonSplitInsideOutsidePlane(v,M,b,E,D){const X=new ae(M),z=new ae(b),R=new ae(E);Pr.splitConvexPolygonInsideOutsidePlane(v,X,z,R,D)}static polygonPlaneCrossings(v,M,b){const E=new ae(M);return Pr.polygonPlaneCrossings(v,E,b)}static convexPolygonClipInPlace(v,M,b,E=K.smallMetricDistance){void 0===b&&(b=[]),b.length=0;let D=0;const X=-E;if(M.length>2){let E=M[M.length-1],z=v.altitude(E);for(const R of M){const M=v.altitude(R);if(M<0&&D++,z*M<0){const v=-z/(M-z);v>1-1e-8&&M>=0||b.push(E.interpolate(v,R))}M>=X&&b.push(R),E=Q.createFrom(R),z=M}}if(b.length<=2)M.length=0;else if(D>0){M.length=0;for(const v of b)M.push(v);b.length=0}}}Ir._xyz0Work=Q.create();class Ar extends tt{constructor(v,M,b,E){super(),this._invisible=b,this._interior=E,this._inwardNormal=v,this._distanceFromOrigin=M}isAlmostEqual(v){return K.isSameCoordinate(this._distanceFromOrigin,v._distanceFromOrigin)&&this._inwardNormal.isAlmostEqual(v._inwardNormal)&&this._interior===v._interior&&this._invisible===v._invisible}clone(){return new Ar(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior)}cloneNegated(){const v=new Ar(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior);return v.negateInPlace(),v}static createPlane(v,M=!1,b=!1,E){const D=v.getNormalRef().dotProduct(v.getOriginRef());return E?(E._invisible=M,E._interior=b,E._inwardNormal=v.getNormalRef().clone(),E._distanceFromOrigin=D,E):new Ar(v.getNormalRef().clone(),D,M,b)}static createNormalAndDistance(v,M,b=!1,E=!1,D){const X=v.normalize();if(X)return D&&(D._invisible=b,D._interior=E,D._inwardNormal=X,D._distanceFromOrigin=M),new Ar(X,M,b,E)}static createNormalAndPoint(v,M,b=!1,E=!1,D){const X=v.normalize();if(X){const v=X.dotProduct(M);return D&&(D._invisible=b,D._interior=E,D._inwardNormal=X,D._distanceFromOrigin=v),new Ar(X,v,b,E)}}static createOriginAndVectors(v,M,b,E=!1,D=!1,X){const z=b.crossProduct(M);return this.createNormalAndPoint(z,v,E,D,X)}static createNormalAndPointXYZXYZ(v,M,b,E,D,X,z=!1,R=!1,O){const Y=K.hypotenuseXYZ(v,M,b),N=K.conditionalDivideFraction(1,Y);if(void 0!==N){if(O)return O._inwardNormal.set(v*N,M*N,b*N),O._distanceFromOrigin=O._inwardNormal.dotProductXYZ(E,D,X),O._invisible=z,O._interior=R,O;const Y=$.create(v*N,M*N,b*N);return new Ar(Y,Y.dotProductXYZ(E,D,X),z,R)}}toJSON(){const v={normal:this.inwardNormalRef.toJSON(),dist:this.distance};return this.interior&&(v.interior=!0),this.invisible&&(v.invisible=!0),v}static fromJSON(v,M){return v&&v.normal&&void 0!==v.dist&&Number.isFinite(v.dist)?Ar.createNormalAndDistance($.fromJSON(v.normal),v.dist,!!v.invisible,!!v.interior):Ar.createNormalAndDistance($.unitZ(),0,!1,!1,M)}setFlags(v,M){this._invisible=v,this._interior=M}get distance(){return this._distanceFromOrigin}get inwardNormalRef(){return this._inwardNormal}get interior(){return this._interior}get invisible(){return this._invisible}static createEdgeAndUpVector(v,M,b,E,D){const X=$.createFrom(M.minus(v));let z=b.crossProduct(X).normalize();if(z){if(void 0!==E&&!E.isAlmostZero){const v=$.createRotateVectorAroundVector(z,X,E);v&&(z=v.clone())}return z.negate(z),Ar.createNormalAndPoint(z,v,!1,!1,D)}}static createEdgeXY(v,M,b){const E=$.create(v.y-M.y,M.x-v.x);if(E.normalizeInPlace())return Ar.createNormalAndPoint(E,v,!1,!1,b)}getPlane3d(){const v=this._distanceFromOrigin;return yt.create(Q.create(this._inwardNormal.x*v,this._inwardNormal.y*v,this._inwardNormal.z*v),this._inwardNormal)}getPlane4d(){return Dt.create(this._inwardNormal.x,this._inwardNormal.y,this._inwardNormal.z,-this._distanceFromOrigin)}setPlane4d(v){const M=Math.sqrt(v.x*v.x+v.y*v.y+v.z*v.z),b=0===M?1:1/M;this._inwardNormal.x=b*v.x,this._inwardNormal.y=b*v.y,this._inwardNormal.z=b*v.z,this._distanceFromOrigin=-b*v.w}weightedAltitude(v){return v.x*this._inwardNormal.x+v.y*this._inwardNormal.y+v.z*this._inwardNormal.z-v.w*this._distanceFromOrigin}altitude(v){return v.x*this._inwardNormal.x+v.y*this._inwardNormal.y+v.z*this._inwardNormal.z-this._distanceFromOrigin}altitudeXYZ(v,M,b){return v*this._inwardNormal.x+M*this._inwardNormal.y+b*this._inwardNormal.z-this._distanceFromOrigin}normalX(){return this._inwardNormal.x}normalY(){return this._inwardNormal.y}normalZ(){return this._inwardNormal.z}velocity(v){return v.x*this._inwardNormal.x+v.y*this._inwardNormal.y+v.z*this._inwardNormal.z}velocityXYZ(v,M,b){return v*this._inwardNormal.x+M*this._inwardNormal.y+b*this._inwardNormal.z}dotProductPlaneNormalPoint(v){return v.x*this._inwardNormal.x+v.y*this._inwardNormal.y+v.z*this._inwardNormal.z}isPointOnOrInside(v,M=K.smallMetricDistance){let b=this.altitude(v);return M&&(b+=M),b>=0}isPointInside(v,M=K.smallMetricDistance){let b=this.altitude(v);return M&&(b-=M),b>0}isPointOn(v,M=K.smallMetricDistance){return Math.abs(this.altitude(v))<=M}appendIntersectionRadians(v,M){const b=v.toVectors(),E=this.altitude(v.center),D=this.velocity(b.vector0),X=this.velocity(b.vector90);wt.appendImplicitLineUnitCircleIntersections(E,D,X,void 0,void 0,M)}announceClippedArcIntervals(v,M){const b=Ar._clipArcFractionArray;return b.clear(),this.appendIntersectionRadians(v,b),v.sweep.radiansArrayToPositivePeriodicFractions(b),ds.selectIntervals01(v,b,this,M)}getBoundedSegmentSimpleIntersection(v,M){const b=this.altitude(v),E=this.altitude(M);if(!(b*E>0||0===b&&0===E))return-b/(E-b)}transformInPlace(v){const M=this.getPlane3d(),b=v.matrix,E=v.multiplyPoint3d(M.getOriginRef()),D=b.multiplyInverseTranspose(M.getNormalRef());if(!D)return!1;M.set(E,D);const X=M.getNormalRef().normalize();return!!X&&(this._inwardNormal=X,this._distanceFromOrigin=this._inwardNormal.dotProduct(M.getOriginRef()),!0)}setInvisible(v){this._invisible=v}negateInPlace(){this._inwardNormal=this._inwardNormal.negate(),this._distanceFromOrigin=-this._distanceFromOrigin}offsetDistance(v){this._distanceFromOrigin+=v}clipConvexPolygonInPlace(v,M,b=!0,E=K.smallMetricDistance){return Pr.clipConvexPolygonInPlace(this,v,M,b,E)}multiplyPlaneByMatrix4d(v,M=!0,b=!0){const E=this.getPlane4d();if(M){const M=v.createInverse();return!!M&&this.multiplyPlaneByMatrix4d(M,!1,b)}return b?v.multiplyTransposePoint4d(E,E):v.multiplyPoint4d(E,E),this.setPlane4d(E),!0}announceClippedSegmentIntervals(v,M,b,E,D){if(M<v)return!1;const X=-this.altitude(b),z=-this.altitude(E)-X,R=K.conditionalDivideFraction(-X,z);return void 0===R?X<=0&&(D&&D(v,M),!0):(z>0?R<M&&(M=R):R>v&&(v=R),!(M<v||(D&&D(v,M),0)))}getFrame(){const v=this._distanceFromOrigin,M=Q.create(this._inwardNormal.x*v,this._inwardNormal.y*v,this._inwardNormal.z*v),b=xt.createRigidHeadsUp(this._inwardNormal,z.ZXY);return pt.createOriginAndMatrix(M,b)}intersectRange(v,M=!1){if(v.isNull)return;const b=v.corners(),E=this.getFrame();E.multiplyInversePoint3dArrayInPlace(b);const D=ut.createArray(b);if(D.low.z*D.high.z>0)return;const X=new nt;return X.pushXYZ(D.low.x,D.low.y,0),X.pushXYZ(D.high.x,D.low.y,0),X.pushXYZ(D.high.x,D.high.y,0),X.pushXYZ(D.low.x,D.high.y,0),X.multiplyTransformInPlace(E),Pr.intersectRangeConvexPolygonInPlace(v,X),0!==X.length?(M&&X.pushWrap(1),X):void 0}appendPolygonClip(v,M,b,E){const D=ft.createNull(),X=E.grabFromCache(),z=E.grabFromCache();Pr.splitConvexPolygonInsideOutsidePlane(this,v,X,z,D),ds.captureOrDrop(X,3,M,E),ds.captureOrDrop(z,3,b,E)}projectPointToPlane(v,M){const b=-this.altitude(v);return v.plusXYZ(b*this._inwardNormal.x,b*this._inwardNormal.y,b*this._inwardNormal.z,M)}}Ar._clipArcFractionArray=new At;const lo={aliceBlue:16775408,amber:49151,antiqueWhite:14150650,aqua:16776960,aquamarine:13959039,azure:16777200,beige:14480885,bisque:12903679,black:0,blanchedAlmond:13495295,blue:16711680,blueViolet:14822282,brown:2763429,burlyWood:8894686,cadetBlue:10526303,chartreuse:65407,chocolate:1993170,coral:5275647,cornflowerBlue:15570276,cornSilk:14481663,crimson:3937500,cyan:16776960,darkBlue:9109504,darkBrown:2179941,darkCyan:9145088,darkGoldenrod:755384,darkGray:11119017,darkGreen:25600,darkGrey:11119017,darkKhaki:7059389,darkMagenta:9109643,darkOliveGreen:3107669,darkOrange:36095,darkOrchid:13382297,darkRed:139,darkSalmon:8034025,darkSeagreen:9419919,darkSlateBlue:9125192,darkSlateGray:5197615,darkSlateGrey:5197615,darkTurquoise:13749760,darkViolet:13828244,deepPink:9639167,deepSkyBlue:16760576,dimGray:6908265,dimGrey:6908265,dodgerBlue:16748574,fireBrick:2237106,floralWhite:15792895,forestGreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostWhite:16775416,gold:55295,goldenrod:2139610,gray:8421504,green:32768,greenYellow:3145645,grey:8421504,honeydew:15794160,hotPink:11823615,indianRed:6053069,indigo:8519755,ivory:15794175,khaki:9234160,lavender:16443110,lavenderBlush:16118015,lawnGreen:64636,lemonChiffon:13499135,lightBlue:15128749,lightCoral:8421616,lightCyan:16777184,lightGoldenrodYellow:13826810,lightGray:13882323,lightGreen:9498256,lightGrey:13882323,lightPink:12695295,lightSalmon:8036607,lightSeagreen:11186720,lightSkyBlue:16436871,lightSlateGray:10061943,lightSlateGrey:10061943,lightSteelBlue:14599344,lightyellow:14745599,lime:65280,limeGreen:3329330,linen:15134970,magenta:16711935,maroon:128,mediumAquamarine:11193702,mediumBlue:13434880,mediumOrchid:13850042,mediumPurple:14381203,mediumSeaGreen:7451452,mediumSlateBlue:15624315,mediumSpringGreen:10156544,mediumTurquoise:13422920,mediumVioletRed:8721863,midnightBlue:7346457,mintCream:16449525,mistyRose:14804223,moccasin:11920639,navajoWhite:11394815,navy:8388608,oldLace:15136253,olive:32896,oliveDrab:2330219,orange:42495,orangeRed:17919,orchid:14053594,paleGoldenrod:11200750,paleGreen:10025880,paleTurquoise:15658671,paleVioletRed:9662683,papayaWhip:14020607,peachPuff:12180223,peru:4163021,pink:13353215,plum:14524637,powderBlue:15130800,purple:8388736,rebeccaPurple:10040166,red:255,rosyBrown:9408444,royalBlue:14772545,saddleBrown:1262987,salmon:7504122,sandyBrown:6333684,seaGreen:5737262,seaShell:15660543,sienna:2970272,silver:12632256,skyBlue:15453831,slateBlue:13458026,slateGray:9470064,slateGrey:9470064,snow:16448255,springGreen:8388352,steelBlue:11829830,tan:9221330,teal:8421376,thistle:14204888,tomato:4678655,turquoise:13688896,violet:15631086,wheat:11788021,white:16777215,whiteSmoke:16119285,yellow:65535,yellowGreen:3329434};class wr{constructor(v=0,M=0,b=0){this.h=v,this.s=M,this.l=b}clone(v,M,b){return new wr(v??this.h,M??this.s,b??this.l)}toColorDef(v=0){return Mr.fromHSL(this.h,this.s,this.l,v)}static fromColorDef(v){return v.toHSL()}}var uo;!function(v){v[v.VISIBILITY_GOAL=40]="VISIBILITY_GOAL",v[v.HSV_SATURATION_WEIGHT=4]="HSV_SATURATION_WEIGHT",v[v.HSV_VALUE_WEIGHT=2]="HSV_VALUE_WEIGHT"}(uo||(uo={}));class Tr{constructor(v=0,M=0,b=0){this.h=v,this.s=M,this.v=b}clone(v,M,b){return new Tr(v??this.h,M??this.s,b??this.v)}toColorDef(v=0){return Mr.fromHSV(this,v)}static fromColorDef(v){return v.toHSV()}adjusted(v,M){let b;if(v){if(b=M*uo.HSV_VALUE_WEIGHT,this.v>=b)return new Tr(this.h,this.s,this.v-b);b-=this.v;const v=Math.min(this.s+b,100);return new Tr(this.h,v,0)}if(b=M*uo.HSV_SATURATION_WEIGHT,this.s>=b)return new Tr(this.h,this.s-b,this.v);b-=this.s;const E=Math.min(this.v+b,100);return new Tr(this.h,0,E)}}const fo=new Uint8Array(4),go=new Uint32Array(fo.buffer);class Mr{constructor(v){go[0]=v,this._tbgr=go[0]}static create(v){return this.fromTbgr(this.computeTbgr(v))}static computeTbgr(v){switch(typeof v){case"number":return v;case"string":return this.computeTbgrFromString(v);default:return 0}}toJSON(){return this._tbgr}static fromJSON(v){return this.create(v)}static from(v,M,b,E){return this.fromTbgr(this.computeTbgrFromComponents(v,M,b,E))}static computeTbgrFromComponents(v,M,b,E){return fo[0]=v,fo[1]=M,fo[2]=b,fo[3]=E||0,go[0]}static fromTbgr(v){switch(v){case lo.black:return this.black;case lo.white:return this.white;case lo.red:return this.red;case lo.green:return this.green;case lo.blue:return this.blue;default:return new Mr(v)}}static fromAbgr(v){return this.fromTbgr(this.getAbgr(v))}static fromString(v){return this.fromTbgr(this.computeTbgrFromString(v))}static isValidColor(v){return"number"==typeof v?v>=0&&v<=4294967295&&Math.floor(v)===v:void 0!==this.tryComputeTbgrFromString(v)}static computeTbgrFromString(v){return this.tryComputeTbgrFromString(v)??0}static tryComputeTbgrFromString(v){if("string"!=typeof v)return;v=v.toLowerCase();let M=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(v);if(M){let v;const b=M[1],E=M[2],n=v=>"%"===v[v.length-1],r=v=>{const M=parseFloat(v);return 255*K.clamp(n(v)?M/100:M,0,1)},o=v=>{const M=n(v)?parseFloat(v)/100*255:parseInt(v,10);return K.clamp(M,0,255)};switch(b){case"rgb":case"rgba":if(v=/^(\d+%*)\s*[, ]\s*(\d+%*)\s*[, ]\s*(\d+%*)\s*([,\/]\s*([0-9]*\.?[0-9]+%*)\s*)?$/.exec(E),v)return this.computeTbgrFromComponents(o(v[1]),o(v[2]),o(v[3]),"string"==typeof v[5]?255-r(v[5]):0);break;case"hsl":case"hsla":if(v=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(E),v){const M=parseFloat(v[1])/360,b=parseInt(v[2],10)/100,E=parseInt(v[3],10)/100,D="string"==typeof v[5]?255-r(v[5]):0;return this.computeTbgrFromHSL(M,b,E,D)}}}else if(M=/^\#([a-f0-9]+)$/.exec(v)){const v=M[1],b=v.length;if(3===b)return this.computeTbgrFromComponents(parseInt(v.charAt(0)+v.charAt(0),16),parseInt(v.charAt(1)+v.charAt(1),16),parseInt(v.charAt(2)+v.charAt(2),16),0);if(6===b)return this.computeTbgrFromComponents(parseInt(v.charAt(0)+v.charAt(1),16),parseInt(v.charAt(2)+v.charAt(3),16),parseInt(v.charAt(4)+v.charAt(5),16),0)}if(v&&v.length>0)for(const[b,E]of Object.entries(lo))if(b.toLowerCase()===v)return E}get colors(){return Mr.getColors(this._tbgr)}static getColors(v){return go[0]=v,{b:fo[2],g:fo[1],r:fo[0],t:fo[3]}}get tbgr(){return this._tbgr}getAbgr(){return Mr.getAbgr(this._tbgr)}static getAbgr(v){return go[0]=v,fo[3]=255-fo[3],go[0]}getRgb(){return Mr.getRgb(this._tbgr)}static getRgb(v){return go[0]=v,(fo[0]<<16)+(fo[1]<<8)+fo[2]}withAlpha(v){const M=Mr.withAlpha(this._tbgr,v);return M===this._tbgr?this:Mr.fromTbgr(M)}static withAlpha(v,M){return go[0]=v,fo[3]=255-(0|M),go[0]}getAlpha(){return Mr.getAlpha(this._tbgr)}static getAlpha(v){return go[0]=v,255-fo[3]}get isOpaque(){return Mr.isOpaque(this._tbgr)}static isOpaque(v){return 255===this.getAlpha(v)}getTransparency(){return Mr.getTransparency(this._tbgr)}static getTransparency(v){return go[0]=v,fo[3]}withTransparency(v){const M=Mr.withTransparency(this._tbgr,v);return M===this._tbgr?this:Mr.fromTbgr(M)}static withTransparency(v,M){return this.withAlpha(v,255-M)}get name(){return Mr.getName(this.tbgr)}static getName(v){for(const[M,b]of Object.entries(lo))if(b===v)return M}toHexString(){return Mr.toHexString(this.tbgr)}static toHexString(v){return`#${`000000${this.getRgb(v).toString(16)}`.slice(-6)}`}static getColorsString(v){const M=this.getColors(v);return`${M.r},${M.g},${M.b}`}toRgbString(){return Mr.toRgbString(this.tbgr)}static toRgbString(v){return`rgb(${this.getColorsString(v)})`}toRgbaString(){return Mr.toRgbaString(this.tbgr)}static toRgbaString(v){return`rgba(${this.getColorsString(v)},${this.getAlpha(v)/255})`}lerp(v,M){return Mr.fromTbgr(Mr.lerp(this.tbgr,v.tbgr,M))}static lerp(v,M,b){const E=this.getColors(v),D=this.getColors(M);return E.r+=(D.r-E.r)*b,E.g+=(D.g-E.g)*b,E.b+=(D.b-E.b)*b,this.computeTbgrFromComponents(E.r,E.g,E.b,E.t)}inverse(){return Mr.fromTbgr(Mr.inverse(this.tbgr))}static inverse(v){const M=this.getColors(v);return this.computeTbgrFromComponents(255-M.r,255-M.g,255-M.b)}static fromHSL(v,M,b,E=0){return this.fromTbgr(this.computeTbgrFromHSL(v,M,b,E))}static computeTbgrFromHSL(v,M,b,E=0){const n=(v,M,b)=>Math.round(255*((v,M,b)=>(b<0&&(b+=1),b>1&&(b-=1),b<1/6?v+6*(M-v)*b:b<.5?M:b<2/3?v+6*(M-v)*(2/3-b):v))(v,M,b));if(v=(v%1+1)%1,M=K.clamp(M,0,1),b=K.clamp(b,0,1),0===M)return b*=255,this.computeTbgrFromComponents(b,b,b,E);const D=b<=.5?b*(1+M):b+M-b*M,X=2*b-D;return this.computeTbgrFromComponents(n(X,D,v+1/3),n(X,D,v),n(X,D,v-1/3),E)}toHSL(){const v=this.colors;v.r/=255,v.g/=255,v.b/=255;const M=Math.max(v.r,v.g,v.b),b=Math.min(v.r,v.g,v.b);let E,D=0;const X=(b+M)/2;if(b===M)E=0;else{const z=M-b;switch(E=X<=.5?z/(M+b):z/(2-M-b),M){case v.r:D=(v.g-v.b)/z+(v.g<v.b?6:0);break;case v.g:D=(v.b-v.r)/z+2;break;case v.b:D=(v.r-v.g)/z+4}D/=6}return new wr(D,E,X)}toHSV(){const{r:v,g:M,b:b}=this.colors;let E=v<M?v:M;b<E&&(E=b);let D=v>M?v:M;b>D&&(D=b);const X=Math.floor(D/255*100+.5),z=D-E,R=0!==D?Math.floor(z/D*100+.5):0;let O=0;if(R){const E=(D-v)/z,X=(D-M)/z,R=(D-b)/z;let Y;Y=v===D?R-X:M===D?2+E-R:4+X-E,Y*=60,Y<0&&(Y+=360),O=Math.floor(Y+.5),O>=360&&(O=0)}else O=0;return new Tr(O,R,X)}static fromHSV(v,M=0){if(!v.s||-1===v.h){const M=255&Math.floor(255*v.v/100+.5+3e-14);return Mr.from(M,M,M,0)}let b=v.h,E=v.s,D=v.v;360===b&&(b=0),b/=60;const X=Math.floor(b),z=b-X;D/=100,E/=100;const R=255&Math.floor(D*(1-E)*255+.5),O=255&Math.floor(D*(1-E*z)*255+.5),Y=255&Math.floor(D*(1-E*(1-z))*255+.5),N=255&Math.floor(255*D+.5);let B=0,V=0,L=0;switch(X){case 0:B=N,L=Y,V=R;break;case 1:B=O,L=N,V=R;break;case 2:B=R,L=N,V=Y;break;case 3:B=R,L=O,V=N;break;case 4:B=Y,L=R,V=N;break;case 5:B=N,L=R,V=O}return Mr.from(B,L,V,M)}visibilityCheck(v){const M=this.colors,b=v.colors;return.3*Math.abs(M.r-b.r)+.59*Math.abs(M.g-b.g)+.11*Math.abs(M.b-b.b)}adjustedForContrast(v,M){const b=this.visibilityCheck(v);if(uo.VISIBILITY_GOAL<=b)return void 0!==M?this.withAlpha(M):this;const E=Math.floor((uo.VISIBILITY_GOAL-b)/255*100);let D=this.toHSV(),X=D.clone();D=D.adjusted(!0,E),X=X.adjusted(!1,E),void 0===M&&(M=this.getAlpha());const z=Mr.fromHSV(D).withAlpha(M),R=Mr.fromHSV(X).withAlpha(M);return R.getRgb()===v.getRgb()?z:z.getRgb()===v.getRgb()||R.visibilityCheck(v)>=z.visibilityCheck(v)?R:z}equals(v){return this._tbgr===v._tbgr}}Mr.black=new Mr(lo.black),Mr.white=new Mr(lo.white),Mr.red=new Mr(lo.red),Mr.green=new Mr(lo.green),Mr.blue=new Mr(lo.blue);class br{constructor(v,M,b){this.r=v,this.g=M,this.b=b,this.r=Math.max(0,Math.min(this.r,255)),this.g=Math.max(0,Math.min(this.g,255)),this.b=Math.max(0,Math.min(this.b,255))}static fromColorDef(v){const M=v.colors;return new br(M.r,M.g,M.b)}toColorDef(v=0){return Mr.from(this.r,this.g,this.b,v)}toJSON(){return{r:this.r,g:this.g,b:this.b}}static fromJSON(v){let M=255,b=255,E=255;return void 0!==v&&("number"==typeof v.r&&(M=v.r),"number"==typeof v.g&&(b=v.g),"number"==typeof v.b&&(E=v.b)),new br(M,b,E)}equals(v){return this.r===v.r&&this.g===v.g&&this.b===v.b}compareTo(v){return i(this.r,v.r)||i(this.g,v.g)||i(this.b,v.b)}toHexString(){return this.toColorDef().toHexString()}}class Er{constructor(v,M){this.value=v,this.index=M}}class Dr{constructor(v,M=Number.MAX_SAFE_INTEGER,b=Z){this._array=[],this._compareValues=v,this._clone=b,this._maximumSize=M}get length(){return this._array.length}get isFull(){return this.length>=this._maximumSize}get isEmpty(){return 0===this.length}clear(){this._array=[]}insert(v,M){const b=this.lowerBound(v);if(b.equal)return this._array[b.index].index;if(this.isFull)return-1;const E=new Er(this._clone(v),this._array.length);return void 0!==M&&M(E.value),this._array.splice(b.index,0,E),E.index}indexOf(v){const M=this.lowerBound(v);return M.equal?this._array[M.index].index:-1}lowerBound(v){return function q(v,M,b){return function(v,M){let b=0,E=v.length;for(;b<E;){const D=Math.floor((b+E)/2),X=M(v[D]);if(0===X)return{index:D,equal:!0};X<0?E=D:b=D+1}return{index:b,equal:!1}}(M,(M=>b(v,M)))}(v,this._array,((v,M)=>this._compareValues(v,M.value)))}toArray(){const v=[];for(const M of this._array)v[M.index]=M.value;return v}}var po,mo,xo,yo,_o,vo;!function(v){v[v.Never=0]="Never",v[v.ByView=1]="ByView",v[v.Always=2]="Always",v[v.Blanking=3]="Blanking"}(po||(po={})),function(v){v[v.None=0]="None",v[v.Solid=1]="Solid",v[v.Outline=2]="Outline"}(mo||(mo={})),function(v){v[v.Primary=0]="Primary",v[v.Construction=1]="Construction",v[v.Dimension=2]="Dimension",v[v.Pattern=3]="Pattern"}(xo||(xo={}));class Br{constructor(v=M.invalid,b=M.invalid,E=xo.Primary){this.elementId=v,this.subCategoryId=b,this.geometryClass=E}get isDefined(){return!M.isInvalid(this.elementId)||!M.isInvalid(this.subCategoryId)||this.geometryClass!==xo.Primary}get isUndefined(){return!this.isDefined}equals(v){return 0===this.compare(v)}compare(v){if(this===v)return 0;let M=i(this.geometryClass,v.geometryClass);return 0===M&&(M=n(this.elementId,v.elementId),0===M&&(M=n(this.subCategoryId,v.subCategoryId))),M}}!function(v){v.create=function(){return{modelId:M.invalid,elementId:M.invalid,subCategoryId:M.invalid,geometryClass:xo.Primary}},v.isDefined=function(v){return!M.isInvalid(v.modelId)||!M.isInvalid(v.elementId)||!M.isInvalid(v.subCategoryId)||v.geometryClass!==xo.Primary},v.unpack=function(v,b,E){return b.modelId=E??M.fromUint32PairObject(v.modelId),b.elementId=M.fromUint32PairObject(v.elementId),b.subCategoryId=M.fromUint32PairObject(v.subCategoryId),b.geometryClass=v.geometryClass,b}}(yo||(yo={})),function(v){function e(){const v={upper:0,lower:0};return{modelId:{...v},elementId:{...v},subCategoryId:{...v},geometryClass:xo.Primary,animationNodeId:0}}v.create=e,v.createWithIndex=function(){const v=e();return v.index=0,v}}(_o||(_o={})),function(v){v[v.Primary=0]="Primary",v[v.VolumeClassifier=1]="VolumeClassifier",v[v.PlanarClassifier=2]="PlanarClassifier"}(vo||(vo={}));class Vr extends Dr{constructor(v,b=M.invalid,E=vo.Primary){super(((v,M)=>v.compare(M)),v),this.modelId=b,this.type=E}get maxFeatures(){return this._maximumSize}get anyDefined(){return this.length>1||1===this.length&&this._array[0].value.isDefined}get isUniform(){return 1===this.length}get uniform(){return 1===this.length?this._array[0].value:void 0}get isVolumeClassifier(){return vo.VolumeClassifier===this.type}get isPlanarClassifier(){return vo.PlanarClassifier===this.type}findFeature(v){for(const M of this._array)if(M.index===v)return M.value}insertWithIndex(v,M){const b=this.lowerBound(v);e(!b.equal),e(!this.isFull);const E=new Er(v,M);this._array.splice(b.index,0,E)}getArray(){return this._array}pack(){return Zr.pack(this)}}const Po=_o.create();function Ur(v,M,b){let E;e(b>0);const D=_o.createWithIndex();for(const X of v.iterable(D)){const D=M(X);if(e(D<=b),0!==D){if(!E){const M=v.numFeatures;E=b<256?new Uint8Array(M):b<65536?new Uint16Array(M):new Uint32Array(M)}E[X.index]=D}}return E}class Zr{get byteLength(){return this._data.byteLength}constructor(v,b,E,D,X){switch(this._data=v,this.batchModelId=b,this.batchModelIdPair=M.getUint32Pair(b),this.numFeatures=E,this.type=D,this.animationNodeIds=X,this.numFeatures){case 0:this.anyDefined=!1;break;case 1:this.anyDefined=yo.isDefined(this.getFeature(0,yo.create()));break;default:this.anyDefined=!0}e(this._data.length>=this._subCategoriesOffset),e(void 0===this.animationNodeIds||this.animationNodeIds.length===this.numFeatures)}static pack(v){const b=new Map;for(const M of v.getArray())void 0===b.get(M.value.subCategoryId.toString())&&b.set(M.value.subCategoryId,b.size);const E=3*v.length,D=E+2*b.size,X=new Uint32Array(D);for(const z of v.getArray()){const v=z.value,E=3*z.index;let D=b.get(v.subCategoryId);e(void 0!==D),D|=v.geometryClass<<24,X[E+0]=M.getLowerUint32(v.elementId),X[E+1]=M.getUpperUint32(v.elementId),X[E+2]=D}return b.forEach(((v,b,D)=>{const z=E+2*v;X[z+0]=M.getLowerUint32(b),X[z+1]=M.getUpperUint32(b)})),new Zr(X,v.modelId,v.length,v.type)}getFeature(v,M){const b=this.getPackedFeature(v,Po);return yo.unpack(b,M,this.batchModelId)}findFeature(v,M){return v<this.numFeatures?this.getFeature(v,M):void 0}getElementIdPair(v,M){M=M??{lower:0,upper:0},e(v<this.numFeatures);const b=3*v;return M.lower=this._data[b],M.upper=this._data[b+1],M}getSubCategoryIdPair(v){const M=3*v;let b=this._data[M+2];return b=(16777215&b)>>>0,b=2*b+this._subCategoriesOffset,{lower:this._data[b],upper:this._data[b+1]}}getAnimationNodeId(v){return void 0!==this.animationNodeIds&&v<this.numFeatures?this.animationNodeIds[v]:0}getPackedFeature(v,M){e(v<this.numFeatures);const b=3*v;M.elementId.lower=this._data[b],M.elementId.upper=this._data[b+1];const E=this._data[b+2];M.geometryClass=E>>>24&255;let D=(16777215&E)>>>0;return D=2*D+this._subCategoriesOffset,M.subCategoryId.lower=this._data[D],M.subCategoryId.upper=this._data[D+1],M.animationNodeId=this.getAnimationNodeId(v),M.modelId.lower=this.batchModelIdPair.lower,M.modelId.upper=this.batchModelIdPair.upper,M}findElementId(v){return v>=this.numFeatures?void 0:this.readId(3*v)}get isUniform(){return 1===this.numFeatures}getUniform(v){return this.isUniform?this.getFeature(0,v):void 0}get isVolumeClassifier(){return vo.VolumeClassifier===this.type}get isPlanarClassifier(){return vo.VolumeClassifier===this.type}get isClassifier(){return this.isVolumeClassifier||this.isPlanarClassifier}unpack(){const v=new Vr(this.numFeatures,this.batchModelId),M=yo.create();for(let b=0;b<this.numFeatures;b++)this.getFeature(b,M),v.insertWithIndex(new Br(M.elementId,M.subCategoryId,M.geometryClass),b);return v}populateAnimationNodeIds(v,M){e(void 0===this.animationNodeIds),this.animationNodeIds=Ur(this,v,M)}*iterator(v){for(let M=0;M<this.numFeatures;M++)this.getPackedFeature(M,v),v.index=M,yield v}iterable(v){return{[Symbol.iterator]:()=>this.iterator(v)}}get _subCategoriesOffset(){return 3*this.numFeatures}readId(v){return M.fromUint32Pair(this._data[v],this._data[v+1])}}const Io={lastFeatureIndex:-1,idLower:-1,idUpper:-1};class Wr{constructor(v){this._data=v,e(this._data.length%3==0)}get length(){return this._data.length/3}get byteLength(){return this._data.byteLength}getLastFeatureIndex(v){return this._data[3*v]}getEntry(v,M){if(v>=this.length)return M.idLower=M.idUpper=0,M.lastFeatureIndex=Number.MAX_SAFE_INTEGER,M;const b=3*v;return M.lastFeatureIndex=this._data[b+0],M.idLower=this._data[b+1],M.idUpper=this._data[b+2],M}getModelIdPair(v,M){M?M.lower=M.upper=0:M={lower:0,upper:0};let b=0;const E=this.length;let D=E;for(;D>0;){const M=Math.floor(D/2),E=b+M;v>this.getLastFeatureIndex(E)?(b=E+1,D-=M+1):D=M}return b<E&&(M.lower=this._data[3*b+1],M.upper=this._data[3*b+2]),M}}class Gr{constructor(v,M){this._features=v,this._models=M}static create(v,M,b,E,D){const X=3*b+2*D,z=v.subarray(0,X),R=new Zr(z,M,b,E),O=v.subarray(X),Y=new Wr(O);return new Gr(R,Y)}get batchModelId(){return this._features.batchModelId}get batchModelIdPair(){return this._features.batchModelIdPair}get numFeatures(){return this._features.numFeatures}get type(){return this._features.type}get animationNodeIds(){return this._features.animationNodeIds}set animationNodeIds(v){this._features.animationNodeIds=v}get byteLength(){return this._features.byteLength+this._models.byteLength}getPackedFeature(v,M){return this._features.getPackedFeature(v,M),this._models.getModelIdPair(v,M.modelId),M}getFeature(v,M){const b=this.getPackedFeature(v,Po);return yo.unpack(b,M)}findFeature(v,M){return v<this.numFeatures?this.getFeature(v,M):void 0}getElementIdPair(v,M){return this._features.getElementIdPair(v,M)}findElementId(v){return this._features.findElementId(v)}*iterator(v){let M=0;const b=this._models.getEntry(M,Io);for(let E=0;E<this.numFeatures;E++)E>b.lastFeatureIndex&&this._models.getEntry(++M,b),this._features.getPackedFeature(E,v),v.modelId.lower=b.idLower,v.modelId.upper=b.idUpper,v.index=E,yield v}iterable(v){return{[Symbol.iterator]:()=>this.iterator(v)}}getAnimationNodeId(v){return this._features.getAnimationNodeId(v)}populateAnimationNodeIds(v,M){this._features.animationNodeIds=Ur(this,v,M)}}function Hr(v,M){if(v.clear(),"string"==typeof M)v.addId(M);else for(const b of M)v.addId(b)}class Jr{static fromJSON(v){return void 0!==v&&(void 0!==v.rgb||void 0!==v.weight||void 0!==v.transparency||void 0!==v.linePixels||v.ignoresMaterial||v.nonLocatable||v.emphasized)?new Jr(v):this.defaults}static fromRgb(v){return this.fromJSON({rgb:br.fromColorDef(v)})}static fromRgba(v,M=!1){return this.fromJSON({rgb:br.fromColorDef(v),transparency:v.colors.t/255,viewDependentTransparency:!!M||void 0})}static fromTransparency(v,M=!1){return this.fromJSON({transparency:v,viewDependentTransparency:!!M||void 0})}static fromSubCategoryOverride(v){const b=void 0!==v.color?br.fromColorDef(v.color):void 0,E=v.transparency,D=v.weight,X=!(void 0===v.material||!M.isValid(v.material))||void 0;return this.fromJSON({rgb:b,transparency:E,weight:D,ignoresMaterial:X,viewDependentTransparency:!0})}get matchesDefaults(){return this.equals(Jr.defaults)}get overridesRgb(){return void 0!==this.rgb}get overridesTransparency(){return void 0!==this.transparency}get overridesLinePixels(){return void 0!==this.linePixels}get overridesWeight(){return void 0!==this.weight}get overridesSymbology(){return this.overridesRgb||this.overridesTransparency||this.overridesWeight||this.overridesLinePixels||!!this.ignoresMaterial||this.emphasized||this.overridesNonLocatable}get overridesNonLocatable(){return void 0!==this.nonLocatable}get isFullyTransparent(){return void 0!==this.transparency&&this.transparency>=1}get anyOverridden(){return this.overridesSymbology||this.overridesNonLocatable}equals(v){return this===v||this.rgbIsEqual(v.rgb)&&this.weight===v.weight&&this.transparencyIsEqual(v.transparency)&&this.linePixels===v.linePixels&&this.ignoresMaterial===v.ignoresMaterial&&this.nonLocatable===v.nonLocatable&&this.emphasized===v.emphasized&&this.viewDependentTransparency===v.viewDependentTransparency}toJSON(){const v={};return this.rgb&&(v.rgb=this.rgb.toJSON()),void 0!==this.weight&&(v.weight=this.weight),void 0!==this.transparency&&(v.transparency=this.transparency,this.viewDependentTransparency&&(v.viewDependentTransparency=!0)),void 0!==this.linePixels&&(v.linePixels=this.linePixels),!0===this.ignoresMaterial&&(v.ignoresMaterial=!0),!0===this.nonLocatable&&(v.nonLocatable=!0),!0===this.emphasized&&(v.emphasized=!0),v}cloneProps(v){return{...this.toJSON(),...v}}clone(v){return Jr.fromJSON(this.cloneProps(v))}extendAppearance(v){if(!this.overridesSymbology)return v;const M=v.toJSON();return void 0===M.rgb&&(M.rgb=this.rgb),void 0===M.transparency&&(M.transparency=this.transparency),void 0===M.linePixels&&(M.linePixels=this.linePixels),void 0===M.weight&&(M.weight=this.weight),void 0===M.ignoresMaterial&&this.ignoresMaterial&&(M.ignoresMaterial=!0),void 0===M.nonLocatable&&this.nonLocatable&&(M.nonLocatable=!0),void 0===M.emphasized&&this.emphasized&&(M.emphasized=!0),void 0!==M.transparency&&this.viewDependentTransparency&&(M.viewDependentTransparency=!0),Jr.fromJSON(M)}constructor(v){if(this.rgb=void 0!==v.rgb?br.fromJSON(v.rgb):void 0,this.weight=v.weight,this.transparency=v.transparency,this.linePixels=v.linePixels,this.ignoresMaterial=v.ignoresMaterial,this.nonLocatable=v.nonLocatable,this.emphasized=v.emphasized,void 0!==this.weight&&(this.weight=Math.max(1,Math.min(this.weight,32))),void 0!==this.transparency){v.viewDependentTransparency&&(this.viewDependentTransparency=!0),this.transparency=Math.max(0,Math.min(this.transparency,1));const M=1e-4;1-this.transparency<M?this.transparency=1:this.transparency<M&&(this.transparency=0)}}rgbIsEqual(v){return void 0===this.rgb?void 0===v:void 0!==v&&this.rgb.equals(v)}transparencyIsEqual(v){return void 0===this.transparency?void 0===v:void 0!==v&&Math.floor(255*this.transparency)===Math.floor(255*v)}}Jr.defaults=new Jr({});const Ao={elementId:{lower:0,upper:0},animationNodeId:0};class jr{ignoreAnimationOverrides(v){this._ignoreAnimationOverrides.push(v)}get defaultOverrides(){return this._defaultOverrides}get lineWeights(){return this._lineWeights}get neverDrawn(){return this._neverDrawn}get alwaysDrawn(){return this._alwaysDrawn}isNeverDrawn(v,M,b){return!!this._neverDrawn.has(v,M)||this.neverDrawnAnimationNodes.has(b)}isAlwaysDrawn(v,M){return this._alwaysDrawn.has(v,M)}isSubCategoryVisible(v,M){return this._visibleSubCategories.has(v,M)}isSubCategoryVisibleInModel(v,M,b,E){if(this.ignoreSubCategory)return!0;let D=this.isSubCategoryVisible(v,M);const X=this._modelSubCategoryOverrides.get(b,E);return void 0!==X&&X.has(v,M)&&(D=!D),D}getModelOverrides(v,M){return this._modelOverrides.get(v,M)}getElementAnimationOverrides(v,M,b){if(0===this.animationNodeOverrides.size)return;const E=this.animationNodeOverrides.get(b);if(!E||0===b||0===this._ignoreAnimationOverrides.length)return E;const D=Ao;return D.elementId.lower=v,D.elementId.upper=M,D.animationNodeId=b,this._ignoreAnimationOverrides.some((v=>v(D)))?void 0:E}getElementOverrides(v,M,b){const E=this._elementOverrides.get(v,M),D=this.getElementAnimationOverrides(v,M,b);return E?D?D.extendAppearance(E):E:D}getSubCategoryOverrides(v,M){return this._subCategoryOverrides.get(v,M)}setVisibleSubCategory(v){this._visibleSubCategories.addId(v)}setNeverDrawn(v){this._neverDrawn.addId(v)}setAlwaysDrawn(v){this._alwaysDrawn.addId(v)}setAnimationNodeNeverDrawn(v){this.neverDrawnAnimationNodes.add(v)}setNeverDrawnSet(v){Hr(this._neverDrawn,v)}setAlwaysDrawnSet(v,M,b=!0){Hr(this._alwaysDrawn,v),this.isAlwaysDrawnExclusive=M,this.alwaysDrawnIgnoresSubCategory=b}getFeatureAppearance(v,b,E=vo.Primary,D=0){return this.getAppearance(M.getLowerUint32(v.elementId),M.getUpperUint32(v.elementId),M.getLowerUint32(v.subCategoryId),M.getUpperUint32(v.subCategoryId),v.geometryClass,M.getLowerUint32(b),M.getUpperUint32(b),E,D)}getAppearance(v,b,E,D,X,z,R,O,Y){if(vo.VolumeClassifier===O||vo.PlanarClassifier===O)return this.getClassifierAppearance(v,b,E,D,z,R,Y);let N=this._lineWeights?Jr.defaults:jr._weight1Appearance;const B=this.getModelOverrides(z,R);void 0!==B&&(N=B.extendAppearance(N));let V,L,U=!1;if(M.isValidUint32Pair(v,b)){if(this.isNeverDrawn(v,b,Y))return;if(U=this.isAlwaysDrawn(v,b),!U&&this.isAlwaysDrawnExclusive)return;V=this.getElementOverrides(v,b,Y),void 0!==V&&(N=void 0!==B?V.extendAppearance(N):V)}if(!this.ignoreSubCategory&&M.isValidUint32Pair(E,D)){if(!(U&&this.alwaysDrawnIgnoresSubCategory||this.isSubCategoryVisibleInModel(E,D,z,R)))return;L=this.getSubCategoryOverrides(E,D),void 0!==L&&(N=L.extendAppearance(N))}void 0===V&&void 0===B&&void 0===L&&(N=this._defaultOverrides.extendAppearance(N));let Sr=U||this.isClassVisible(X);return Sr&&N.isFullyTransparent&&(Sr=!1),Sr?N:void 0}getClassifierAppearance(v,b,E,D,X,z,R){let O=Jr.defaults;const Y=this.getModelOverrides(X,z);void 0!==Y&&(O=Y.extendAppearance(O));const N=this.getElementOverrides(v,b,R);if(void 0!==N&&(O=void 0!==Y?N.extendAppearance(O):N),!this.ignoreSubCategory&&M.isValidUint32Pair(E,D)){const v=this.getSubCategoryOverrides(E,D);void 0!==v&&(O=v.extendAppearance(O))}return void 0===N&&void 0===Y&&(O=this._defaultOverrides.extendAppearance(O)),O}isClassVisible(v){switch(v){case xo.Construction:return this._constructions;case xo.Dimension:return this._dimensions;case xo.Pattern:return this._patterns;default:return!0}}override(v){let b,E;void 0!==v.elementId?(b=v.elementId,E=this._elementOverrides):void 0!==v.modelId?(b=v.modelId,E=this._modelOverrides):(b=v.subCategoryId,E=this._subCategoryOverrides);let D=v.appearance;const X=M.getLowerUint32(b),z=M.getUpperUint32(b);if(void 0!==v.elementId&&this.isNeverDrawn(X,z,0))return;const R="replace"===v.onConflict?void 0:E.get(X,z);if(R)switch(e("replace"!==v.onConflict),v.onConflict){case"skip":return;case"extend":D=D.extendAppearance(R);break;default:D=R.extendAppearance(D)}E.set(X,z,D)}overrideModel(v,M,b=!0){this.override({modelId:v,appearance:M,onConflict:b?"replace":"skip"})}overrideSubCategory(v,M,b=!0){this.override({subCategoryId:v,appearance:M,onConflict:b?"replace":"skip"})}overrideElement(v,M,b=!0){this.override({elementId:v,appearance:M,onConflict:b?"replace":"skip"})}overrideAnimationNode(v,M){this.animationNodeOverrides.set(v,M)}setDefaultOverrides(v,M=!0){!M&&v.overridesSymbology||(this._defaultOverrides=v)}getSubCategoryPriority(v,M){return this._subCategoryPriorities.get(v,M)??0}constructor(){this._ignoreAnimationOverrides=[],this._neverDrawn=new M.Uint32Set,this._alwaysDrawn=new M.Uint32Set,this.isAlwaysDrawnExclusive=!1,this.alwaysDrawnIgnoresSubCategory=!0,this.ignoreSubCategory=!1,this._defaultOverrides=Jr.defaults,this._constructions=!1,this._dimensions=!1,this._patterns=!1,this._lineWeights=!0,this._modelOverrides=new M.Uint32Map,this._elementOverrides=new M.Uint32Map,this._subCategoryOverrides=new M.Uint32Map,this._visibleSubCategories=new M.Uint32Set,this._subCategoryPriorities=new M.Uint32Map,this._modelSubCategoryOverrides=new M.Uint32Map,this.neverDrawnAnimationNodes=new Set,this.animationNodeOverrides=new Map}isSubCategoryIdVisible(v){return this.isSubCategoryVisible(M.getLowerUint32(v),M.getUpperUint32(v))}getModelOverridesById(v){return this.getModelOverrides(M.getLowerUint32(v),M.getUpperUint32(v))}getElementOverridesById(v){return this.getElementOverrides(M.getLowerUint32(v),M.getUpperUint32(v),0)}getSubCategoryOverridesById(v){return this.getSubCategoryOverrides(M.getLowerUint32(v),M.getUpperUint32(v))}isFeatureVisible(v){const{elementId:b,subCategoryId:E,geometryClass:D}=v,X=M.isInvalid(b)?void 0:M.getUint32Pair(b);if(void 0!==X&&this.isNeverDrawn(X.lower,X.upper,0))return!1;const z=void 0!==X&&this.isAlwaysDrawn(X.lower,X.upper);return z||this.isAlwaysDrawnExclusive?z:!!this.isSubCategoryIdVisible(E)&&this.isClassVisible(D)}}var So;function $r(v,M,b){return v+b*(M-v)}function to(v,M){return i(v.x,M.x)||i(v.y,M.y)||i(v.z,M.z)}jr._weight1Appearance=Jr.fromJSON({weight:1}),function(v){v.supplement=function(v){return{getFeatureAppearance:(M,b,E,D,X,z,R,O,Y,N)=>{const B=M.getAppearance(b,E,D,X,z,R,O,Y,N);return B?v(B):B}}},v.chain=function(v,M){return v===M?v:{getFeatureAppearance:(b,E,D,X,z,R,O,Y,N,B)=>M.getFeatureAppearance(function(v,M){return{getAppearance:(b,E,D,X,z,R,O,Y,N)=>M.getFeatureAppearance(v,b,E,D,X,z,R,O,Y,N)}}(b,v),E,D,X,z,R,O,Y,N,B)}}}(So||(So={}));const wo=new $,Co=new $;function so(v,M){return i(v.low,M.low)||i(v.high,M.high)}var To,ko,Fo;function ao(v){const M=new Set,i=v=>{v&&M.add(v.buffer)};i(v.binaryData),i(v.featureTable.data),i(v.featureTable.animationNodeIds);const s=v=>{if("pattern"!==v.type)switch(i(v.params.vertices.data),"instances"===v.modifier?.type&&(i(v.modifier.transforms),i(v.modifier.featureIds),i(v.modifier.symbologyOverrides)),v.type){case"point":i(v.params.indices);break;case"polyline":i(v.params.polyline.indices),i(v.params.polyline.prevIndices),i(v.params.polyline.nextIndicesAndParams);break;case"mesh":i(v.params.surface.indices);const M=v.params.edges;M&&(i(M.segments?.indices),i(M.segments?.endPointAndQuadIndices),i(M.silhouettes?.indices),i(M.silhouettes?.endPointAndQuadIndices),i(M.silhouettes?.normalPairs),i(M.polylines?.indices),i(M.polylines?.prevIndices),i(M.polylines?.nextIndicesAndParams),i(M.indexed?.indices),i(M.indexed?.edges.data))}else i(v.params.xyOffsets)};for(const b of v.nodes)for(const v of b.primitives)s(v);for(const b of v.patterns.values())for(const v of b)s(v);return Array.from(M)}!function(v){let b;!function(v){v[v.Step=1]="Step",v[v.Linear=2]="Linear"}(b=v.Interpolation||(v.Interpolation={}));class c{constructor(v){this.time=v.time,this.interpolation=v.interpolation===b.Linear?v.interpolation:b.Step}toJSON(){const v={time:this.time};return this.interpolation===b.Linear&&(v.interpolation=this.interpolation),v}compareTo(v){return i(this.interpolation,v.interpolation)||i(this.time,v.time)}equals(v){return 0===this.compareTo(v)}}v.TimelineEntry=c;class h extends c{constructor(v){super(v),"number"!=typeof v.value?this.value=100:this.value=Math.max(0,Math.min(100,v.value))}toJSON(){const v=super.toJSON();return 100!==this.value&&(v.value=this.value),v}compareTo(v){return e(v instanceof h),super.compareTo(v)||i(this.value,v.value)}}v.VisibilityEntry=h;class d extends c{constructor(v){super(v),v.value&&(this.value=new br(v.value.red,v.value.green,v.value.blue))}toJSON(){const v=super.toJSON();return this.value&&(v.value={red:this.value.r,green:this.value.g,blue:this.value.b}),v}compareTo(v){return e(v instanceof d),super.compareTo(v)||r(((v,M)=>v.compareTo(M)),this.value,v.value)}}v.ColorEntry=d;class f{constructor(v,M,b){this.position=v,this.pivot=M,this.orientation=b}static fromJSON(v){return v.pivot&&v.position&&v.orientation?new f($.fromJSON(v.position),$.fromJSON(v.pivot),Dt.fromJSON(v.orientation)):void 0}toJSON(){return{position:[this.position.x,this.position.y,this.position.z],pivot:[this.pivot.x,this.pivot.y,this.pivot.z],orientation:[this.orientation.x,this.orientation.y,this.orientation.z,this.orientation.w]}}compareTo(v){return to(this.pivot,v.pivot)||to(this.position,v.position)||(M=this.orientation,b=v.orientation,i(M.x,b.x)||i(M.y,b.y)||i(M.z,b.z)||i(M.w,b.w));var M,b}equals(v){return this.pivot.isAlmostEqual(v.pivot)&&this.position.isAlmostEqual(v.position)&&this.orientation.isAlmostEqual(v.orientation)}}v.TransformComponents=f;class p extends c{constructor(v){super(v),this.value=v.value?pt.fromJSON(v.value.transform):pt.identity,v.value&&(this.components=f.fromJSON(v.value))}toJSON(){const v=super.toJSON();return this.components?(v.value=this.components.toJSON(),v.value.transform=this.value.toRows()):v.value={transform:this.value.toRows()},v}compareTo(v){e(v instanceof p);const M=super.compareTo(v);return 0!==M?M:this.components||v.components?this.components&&v.components?this.components.compareTo(v.components):this.components?1:-1:to(this.value.origin,v.value.origin)||(b=this.value.matrix,E=v.value.matrix,to(b.columnX(wo),E.columnX(Co))||to(b.columnY(wo),E.columnY(Co))||to(b.columnZ(wo),E.columnZ(Co)));var b,E}}v.TransformEntry=p;class m{constructor(v){this.position=Q.fromJSON(v.position),this.direction=Q.fromJSON(v.direction),this.hidden=!0===v.hidden,this.visible=!0===v.visible}toJSON(){const v={position:[this.position.x,this.position.y,this.position.z],direction:[this.direction.x,this.direction.y,this.direction.z]};return this.visible&&(v.visible=!0),this.hidden&&(v.hidden=!0),v}compareTo(v){return to(this.position,v.position)||to(this.direction,v.direction)||s(this.visible,v.visible)||s(this.hidden,v.hidden)}equals(v){return 0===this.compareTo(v)}}v.CuttingPlane=m;class x extends c{constructor(v){super(v),v.value&&(this.value=new m(v.value))}toJSON(){const v=super.toJSON();return this.value&&(v.value=this.value.toJSON()),v}compareTo(v){return e(v instanceof x),super.compareTo(v)||r(((v,M)=>v.compareTo(M)),this.value,v.value)}}v.CuttingPlaneEntry=x;class y{constructor(v=0,M=0,b=0){this.init(v,M,b)}init(v=0,M=0,b=0){this.lowerIndex=v,this.upperIndex=M,this.fraction=b}}v.Interval=y;class _{constructor(v,M){this.duration=ft.createNull(),this._entries=v.map((v=>{const b=new M(v);return this.duration.extendX(b.time),b}))}get length(){return this._entries.length}[Symbol.iterator](){return this._entries[Symbol.iterator]()}getEntry(v){return this._entries[v]}getValue(v){return this.getEntry(v)?.value}toJSON(){return this._entries.map((v=>v.toJSON()))}compareTo(v){let M=i(this._entries.length,v._entries.length)||so(this.duration,v.duration);if(0===M)for(let b=0;b<this.length&&0===(M=this._entries[b].compareTo(v._entries[b]));b++);return M}equals(v){return 0===this.compareTo(v)}findInterval(v,M){if(0===this.length)return;if(M=M??new y,v<this._entries[0].time)return M.init(0,0,0),M;const E=this.length-1;if(v>=this._entries[E].time)return M.init(E,E,0),M;for(let D=0;D<E;D++){const E=this._entries[D].time,X=this._entries[D+1].time;if(E<=v&&X>=v){let z;return z=b.Linear===this._entries[D].interpolation?(v-E)/(X-E):0,M.init(D,D+1,z),M}}}}v.TimelineEntryList=_;const D=new y;class P extends _{getValue(v){return super.getValue(v)??100}}v.VisibilityTimelineEntries=P;class I extends _{getValue(v){return super.getValue(v)??pt.identity}}v.TransformTimelineEntries=I;class A{constructor(v){this.duration=ft.createNull(),v.visibilityTimeline&&(this.visibility=new P(v.visibilityTimeline,h),this.duration.extendRange(this.visibility.duration)),v.colorTimeline&&(this.color=new _(v.colorTimeline,d),this.duration.extendRange(this.color.duration)),v.transformTimeline&&(this.transform=new I(v.transformTimeline,p),this.duration.extendRange(this.transform.duration)),v.cuttingPlaneTimeline&&(this.cuttingPlane=new _(v.cuttingPlaneTimeline,x),this.duration.extendRange(this.cuttingPlane.duration))}toJSON(){return{visibilityTimeline:this.visibility?.toJSON(),colorTimeline:this.color?.toJSON(),transformTimeline:this.transform?.toJSON(),cuttingPlaneTimeline:this.cuttingPlane?.toJSON()}}compareTo(v){const M=so(this.duration,v.duration);return 0!==M?M:!!this.visibility!=!!v.visibility?this.visibility?1:-1:!!this.color!=!!v.color?this.color?1:-1:!!this.transform!=!!v.transform?this.transform?1:-1:!!this.cuttingPlane!=!!v.cuttingPlane?this.cuttingPlane?1:-1:r(((v,M)=>v.compareTo(M)),this.visibility,v.visibility)||r(((v,M)=>v.compareTo(M)),this.color,v.color)||r(((v,M)=>v.compareTo(M)),this.transform,v.transform)||r(((v,M)=>v.compareTo(M)),this.cuttingPlane,v.cuttingPlane)}equals(v){return 0===this.compareTo(v)}getVisibility(v){let M;if(!this.visibility||!(M=this.visibility.findInterval(v,D)))return 100;let b=this.visibility.getValue(M.lowerIndex)??100;return M.fraction>0&&(b=$r(b,this.visibility.getValue(M.upperIndex)??100,M.fraction)),b}getColor(v){let M;if(!this.color||!(M=this.color.findInterval(v,D)))return;const b=this.color.getValue(M.lowerIndex);if(b&&M.fraction>0){const v=this.color.getValue(M.upperIndex);if(v)return function(v,M,b){return new br($r(v.r,M.r,b),$r(v.g,M.g,b),$r(v.b,M.b,b))}(b,v,M.fraction)}return b}getAnimationTransform(v){let M;if(!this.transform||!(M=this.transform.findInterval(v,D)))return pt.identity;let b=this.transform.getValue(M.lowerIndex);if(M.fraction>0){const v=this.transform.getEntry(M.lowerIndex)?.components,E=this.transform.getEntry(M.upperIndex)?.components;if(v&&E){const D=Dt.interpolateQuaternions(v.orientation,M.fraction,E.orientation),X=xt.createFromQuaternion(D),z=pt.createTranslation(v.pivot),R=pt.createTranslation(v.position.interpolate(M.fraction,E.position)).multiplyTransformMatrix3d(X);R.multiplyTransformTransform(z,R),b=R}else{const v=this.transform.getValue(M.upperIndex),E=b.matrix.inverse()?.toQuaternion(),D=v.matrix.inverse()?.toQuaternion();if(E&&D){const X=Dt.interpolateQuaternions(E,M.fraction,D),z=xt.createFromQuaternion(X),R=$.createFrom(b.origin),O=$.createFrom(v.origin);b=pt.createRefs(R.interpolate(M.fraction,O),z)}}}return b}getCuttingPlane(v){let M;if(!this.cuttingPlane||!(M=this.cuttingPlane.findInterval(v,D)))return;const b=this.cuttingPlane.getValue(M.lowerIndex);if(!b)return;const E=Q.createFrom(b.position),X=$.createFrom(b.direction),z=M.fraction>0?this.cuttingPlane.getValue(M.upperIndex):void 0;if(z)E.interpolate(M.fraction,z.position,E),X.interpolate(M.fraction,z.direction,X);else if(b.hidden||b.visible)return;return X.negate(X),X.normalizeInPlace(),yt.create(E,X)}getClipVector(v){const M=this.getCuttingPlane(v);if(!M)return;const b=Ar.createPlane(M),E=Qi.createConvexSets([an.createPlanes([b])]),D=ns.createCapture(E);return hs.createCapture([D])}getFeatureAppearance(v,M){const b=v<100?1-v/100:void 0,E=this.getColor(M);return void 0!==E||void 0!==b?Jr.fromJSON({rgb:E,transparency:b}):void 0}}v.Timeline=A;class S extends A{constructor(v){super(v),this.batchId=v.batchId,this._elementIds=v.elementIds}static fromJSON(v){return new S(v??{elementIds:[],batchId:0})}toJSON(){return{...super.toJSON(),batchId:this.batchId,elementIds:this._elementIds}}get containsElementIds(){return this._elementIds.length>0}compareElementIds(v){if(typeof this._elementIds==typeof v._elementIds){const M=i(this._elementIds.length,v._elementIds.length);if(0!==M)return M;if("string"==typeof this._elementIds)return e("string"==typeof v._elementIds),n(this._elementIds,v._elementIds)}const M=this.elementIds[Symbol.iterator](),b=v.elementIds[Symbol.iterator]();for(;;){const v=M.next(),E=b.next();if(v.done!==E.done)return s(!!v.done,!!E.done);if(v.done)return 0;const D=n(v.value,E.value);if(0!==D)return D}}compareTo(v){return e(v instanceof S),i(this.batchId,v.batchId)||this.compareElementIds(v)||super.compareTo(v)}static getElementIds(v){return"string"==typeof v?X.iterable(v):Array.isArray(v)?v:[]}get elementIds(){return S.getElementIds(this._elementIds)}get containsFeatureOverrides(){return void 0!==this.visibility||void 0!==this.color}get requiresBatching(){return!!this.cuttingPlane||0!==this.batchId&&(void 0!==this.color||void 0!==this.visibility)}get containsTransform(){return void 0!==this.transform}addSymbologyOverrides(v,M){e(0!==this.batchId);const b=this.getVisibility(M);if(b<=0)return void v.setAnimationNodeNeverDrawn(this.batchId);const E=this.getFeatureAppearance(b,M);E&&v.overrideAnimationNode(this.batchId,E)}}v.ElementTimeline=S;class w extends A{constructor(v){super(v),this._cachedComparisons=new WeakMap,this.modelId=v.modelId,this.realityModelUrl=v.realityModelUrl,this.containsModelClipping=void 0!==this.cuttingPlane;let M=void 0!==this.visibility||void 0!==this.color,b=!1,E=!1;const D=[],X=[];let z=!1;for(const R of v.elementTimelines){const v=S.fromJSON(R);X.push(v),this.duration.extendRange(v.duration),v.containsTransform&&(E=!0,v.batchId&&D.push(v.batchId)),M||=v.containsFeatureOverrides,b||=v.requiresBatching,z=z||v.containsElementIds}this.elementTimelines=X,this.transformBatchIds=D,this.omitsElementIds=X.length>0&&!z,this.containsFeatureOverrides=M,this.requiresBatching=b,this.containsTransform=E}static fromJSON(v){return new w(v??{elementTimelines:[],modelId:M.invalid})}toJSON(){return{...super.toJSON(),modelId:this.modelId,realityModelUrl:this.realityModelUrl,elementTimelines:this.elementTimelines.map((v=>v.toJSON()))}}compareTo(v){if(this===v)return 0;const M=this._cachedComparisons.get(v);if(void 0!==M)return M;e(v instanceof w);let b=n(this.modelId,v.modelId)||o(this.realityModelUrl,v.realityModelUrl)||i(this.elementTimelines.length,v.elementTimelines.length)||s(this.containsFeatureOverrides,v.containsFeatureOverrides)||s(this.containsModelClipping,v.containsModelClipping)||s(this.containsTransform,v.containsTransform)||super.compareTo(v);if(0===b)for(let E=0;E<this.elementTimelines.length&&0===(b=this.elementTimelines[E].compareTo(v.elementTimelines[E]));E++);return this._cachedComparisons.set(v,b),v._cachedComparisons.set(this,-b),b}findByBatchId(v){return this.elementTimelines.find((M=>M.batchId===v))}addSymbologyOverrides(v,M){const b=this.getFeatureAppearance(this.getVisibility(M),M);b&&v.override({modelId:this.modelId,appearance:b});for(const E of this.elementTimelines)E.addSymbologyOverrides(v,M)}getTransform(v,M){return this.findByBatchId(v)?.getAnimationTransform(M)}get maxBatchId(){if(void 0===this._maxBatchId){this._maxBatchId=0;for(const v of this.elementTimelines)this._maxBatchId=Math.max(this._maxBatchId,v.batchId)}return this._maxBatchId}getTimelineForElement(v,b){if(!this._idPairToElementTimeline){this._idPairToElementTimeline=new M.Uint32Map;for(const v of this.elementTimelines)for(const M of v.elementIds)this._idPairToElementTimeline.setById(M,v)}return this._idPairToElementTimeline.get(v,b)}get discreteBatchIds(){if(!this._discreteBatchIds){this._discreteBatchIds=new Set(this.transformBatchIds);for(const v of this.elementTimelines)v.containsTransform||void 0===v.cuttingPlane||this._discreteBatchIds.add(v.batchId)}return this._discreteBatchIds}getBatchIdForFeature(v){e(M.fromUint32PairObject(v.modelId)===this.modelId);const b=this.getTimelineForElement(v.elementId.lower,v.elementId.upper);return b?.batchId??0}}v.ModelTimeline=w;class C{compareTo(v){if(this===v)return 0;const M=this._cachedComparisons.get(v);if(void 0!==M)return M;let b=i(this.modelTimelines.length,v.modelTimelines.length)||s(this.containsModelClipping,v.containsModelClipping)||s(this.requiresBatching,v.requiresBatching)||s(this.containsTransform,v.containsTransform)||s(this.containsFeatureOverrides,v.containsFeatureOverrides)||so(this.duration,v.duration);if(0===b)for(let E=0;E<this.modelTimelines.length&&0===(b=this.modelTimelines[E].compareTo(v.modelTimelines[E]));E++);return this._cachedComparisons.set(v,b),v._cachedComparisons.set(this,-b),b}equals(v){return 0===this.compareTo(v)}constructor(v){this._cachedComparisons=new WeakMap,this.duration=ft.createNull();const M=new Set,b=[];let E=!1,D=!1,X=!1,z=!1;for(const R of v){const v=w.fromJSON(R);b.push(v),this.duration.extendRange(v.duration),E||=v.containsModelClipping,D||=v.requiresBatching,X||=v.containsTransform,z||=v.containsFeatureOverrides;for(const b of v.transformBatchIds)M.add(b)}this.modelTimelines=b,this.containsModelClipping=E,this.containsTransform=X,this.requiresBatching=D||this.containsTransform,this.containsFeatureOverrides=z,this.transformBatchIds=M}static fromJSON(v){if(Array.isArray(v)&&0!==v.length)return new C(v)}toJSON(){return this.modelTimelines.map((v=>v.toJSON()))}find(v){return this.modelTimelines.find((M=>M.modelId===v))}getTransformBatchIds(v){return this.find(v)?.transformBatchIds}getTransform(v,M,b){return this.find(v)?.getTransform(M,b)}addSymbologyOverrides(v,M){for(const b of this.modelTimelines)b.addSymbologyOverrides(v,M)}discloseIds(v){for(const M of this.modelTimelines){v.addModel(M.modelId);for(const b of M.elementTimelines)for(const M of b.elementIds)v.addElement(M)}}modelRequiresBatching(v){return this.requiresBatching&&this.modelTimelines.some((M=>M.modelId===v&&M.requiresBatching))}get discreteBatchIds(){if(this._discreteBatchIds)return this._discreteBatchIds;this._discreteBatchIds=new Set;for(const v of this.modelTimelines)for(const M of v.discreteBatchIds)this._discreteBatchIds.add(M);return this._discreteBatchIds}getBatchIdForFeature(v){let b;const E=this._lastFeatureModelTimeline;if(E&&E.idLower===v.modelId.lower&&E.idUpper===v.modelId.upper)b=E.timeline;else{const E=M.fromUint32PairObject(v.modelId);b=this.find(E),this._lastFeatureModelTimeline={timeline:b,idLower:v.modelId.lower,idUpper:v.modelId.upper}}return b?.getBatchIdForFeature(v)??0}get maxBatchId(){return this._maxBatchId??(this._maxBatchId=this.modelTimelines.reduce(((v,M)=>Math.max(v,M.maxBatchId)),0))}}v.Script=C,v.ScriptReference=class{constructor(v,b){"string"==typeof v?(e(b instanceof C),this.sourceId=v,this.script=b):(e(void 0===b),this.script=v,this.sourceId=M.invalid)}};class T{addVisibility(v,M,E=b.Linear){this.visibility||(this.visibility=[]),this.visibility.push({time:v,value:M,interpolation:E})}addColor(v,M,E=b.Linear){this.color||(this.color=[]);const D=M instanceof br?{red:M.r,green:M.g,blue:M.b}:M;this.color.push({time:v,value:D,interpolation:E})}addCuttingPlane(v,M,E=b.Linear){let D;this.cuttingPlane||(this.cuttingPlane=[]),M&&(D={position:[M.position.x,M.position.y,M.position.z],direction:[M.direction.x,M.direction.y,M.direction.z]},M.visible&&(D.visible=!0),M.hidden&&(D.hidden=!0)),this.cuttingPlane.push({time:v,value:D,interpolation:E})}addTransform(v,M,E,D=b.Linear){this.transform||(this.transform=[]);const X={transform:M?.toRows()};E&&(X.pivot=[E.pivot.x,E.pivot.y,E.pivot.z],X.orientation=E.orientation.toJSON(),X.position=[E.position.x,E.position.y,E.position.z]),this.transform.push({time:v,value:X,interpolation:D})}finish(){const v={};return this.visibility?.length&&(v.visibilityTimeline=this.visibility),this.color?.length&&(v.colorTimeline=this.color),this.transform?.length&&(v.transformTimeline=this.transform),this.cuttingPlane?.length&&(v.cuttingPlaneTimeline=this.cuttingPlane),v}}v.TimelineBuilder=T;class F extends T{constructor(v,M){super(),this.batchId=v,this.elementIds=M}finish(){const v=super.finish();return v.batchId=this.batchId,v.elementIds=this.elementIds,v}}v.ElementTimelineBuilder=F;class k extends T{constructor(v,M){super(),this._elements=[],this.modelId=v,this._obtainNextBatchId=M}addElementTimeline(v){const b=this._obtainNextBatchId();let D;if("string"==typeof v&&M.isValidId64(v)&&(v=[v]),"string"==typeof v)D=v;else{const M=Array.from(v);E.sortArray(M),D=X.compressIds(M)}const z=new F(b,D);return this._elements.push(z),z}finish(){const v=super.finish();return v.modelId=this.modelId,void 0!==this.realityModelUrl&&(v.realityModelUrl=this.realityModelUrl),v.elementTimelines=this._elements.map((v=>v.finish())),v}}v.ModelTimelineBuilder=k,v.ScriptBuilder=class{constructor(){this._nextBatchId=1,this._models=[]}addModelTimeline(v){const M=new k(v,(()=>this._nextBatchId++));return this._models.push(M),M}finish(){return this._models.map((v=>v.finish()))}}}(To||(To={})),function(v){function e(v){return"object"==typeof v&&0===Object.keys(v).length}function i(v){return void 0===v||e(v)}function s(v){return null==v}v.asBool=function(v,M=!1){return s(v)?M:!!v},v.asInt=function(v,M=0){return"number"==typeof v?Math.trunc(v):M},v.asDouble=function(v,M=0){return"number"==typeof v?v:M},v.asString=function(v,M=""){return s(v)?M:v.toString()},v.asArray=function(v){return Array.isArray(v)?v:void 0},v.asObject=function(v){return"object"==typeof v?v:void 0},v.setOrRemoveNumber=function(v,M,b,E){b===E?delete v[M]:v[M]=b},v.setOrRemoveBoolean=function(v,M,b,E){b===E?delete v[M]:v[M]=b},v.isEmptyObject=e,v.isEmptyObjectOrUndefined=i,v.isNonEmptyObject=function(v){return!i(v)},v.toObject=function t(v){if("boolean"==typeof v||"number"==typeof v||"string"==typeof v)return v;if("object"!=typeof v)return;if(void 0!==v.toJSON)return t(v.toJSON());if(Array.isArray(v)){const M=new Array(v.length);return v.forEach(((v,b)=>M[b]=t(v))),M}const M={};return Object.getOwnPropertyNames(v).forEach((b=>{const E=t(v[b]);void 0!==E&&(M[b]=E)})),M}}(ko||(ko={}));class co{constructor(v,M){this._curPos=0,void 0!==M?(this._view=new DataView(v,M.byteOffset,M.byteLength),this._byteOffset=M.byteOffset):(this._view=new DataView(v),this._byteOffset=0)}static fromUint8Array(v){const{byteOffset:M,byteLength:b}=v;return new co(v.buffer,{byteOffset:M,byteLength:b})}static fromArrayBuffer(v,M){return new co(v,M)}get length(){return this._view.byteLength}get remainingLength(){return this.length-this.curPos}get isPastTheEnd(){return this.curPos>this.length}get isAtTheEnd(){return this.curPos===this.length}get curPos(){return this._curPos}set curPos(v){this._curPos=v,e(!this.isPastTheEnd)}advance(v){return this.curPos=this.curPos+v,!this.isPastTheEnd}rewind(v){return!(this.curPos-v<0||(this.curPos=this.curPos-v,0))}reset(){this.curPos=0}readUint8(){return this.read(1,(v=>v.getUint8(this.curPos)))}readUint16(){return this.read(2,(v=>v.getUint16(this.curPos,!0)))}readUint32(){return this.read(4,(v=>v.getUint32(this.curPos,!0)))}readInt32(){return this.read(4,(v=>v.getInt32(this.curPos,!0)))}readFloat32(){return this.read(4,(v=>v.getFloat32(this.curPos,!0)))}readFloat64(){return this.read(8,(v=>v.getFloat64(this.curPos,!0)))}readId64(){return M.fromUint32Pair(this.readUint32(),this.readUint32())}readUint24(){return this.readUint8()|this.readUint8()<<8|this.readUint8()<<16}get nextUint8(){return this.readUint8()}get nextUint16(){return this.readUint16()}get nextUint32(){return this.readUint32()}get nextInt32(){return this.readInt32()}get nextFloat32(){return this.readFloat32()}get nextFloat64(){return this.readFloat64()}get nextId64(){return this.readId64()}get nextUint24(){return this.readUint24()}nextBytes(v){const M=new Uint8Array(this.arrayBuffer,this.curPos+this._byteOffset,v);return this.advance(v),M}readBytes(v,M){return new Uint8Array(this.arrayBuffer,v+this._byteOffset,M)}nextUint32s(v){const M=4*v,b=new Uint32Array(this.arrayBuffer,this.curPos+this._byteOffset,v);return this.advance(M),b}get arrayBuffer(){return this._view.buffer}read(v,M){const b=M(this._view);return this.advance(v),b}}!function(v){function e(v,M,b){return M<=v&&v<=b}v.decodeWithFromCharCode=function(v){let M="";const b=function(v){let M=0,b=0,E=0,D=128,X=191;const z=[],R=v.length;for(let O=0;O<R;O++){const R=v[O];if(0===E){if(e(R,0,127)){z.push(R);continue}if(e(R,194,223)){E=1,M=31&R;continue}if(e(R,224,239)){224===R?D=160:237===R&&(X=159),E=2,M=15&R;continue}if(e(R,240,244)){240===R?D=144:244===R&&(X=143),E=3,M=7&R;continue}return}e(R,D,X)?(D=128,X=191,M=M<<6|63&R,++b,b===E&&(z.push(M),M=E=b=0)):(M=E=b=0,D=128,X=191,--O)}return z}(v);if(void 0!==b){for(let v of b)v<=65535?M+=String.fromCharCode(v):(v-=65536,M+=String.fromCharCode(55296+(v>>10),56320+(1023&v)));return M}}}(Fo||(Fo={}));let Mo=!0;var bo,Eo,Do,Xo,Jo,wa,Ca,ka,Oa,Ba,Va,La,Ua,Ka,Za,Wa,qa,Qa,Ga,Ha,Ja,$a,ja,tc;(Do=bo||(bo={}))[Do.Unknown=0]="Unknown",Do[Do.B3dm=1835283298]="B3dm",Do[Do.Gltf=1179937895]="Gltf",Do[Do.Pnts=1937010288]="Pnts",Do[Do.IModel=1818512745]="IModel",Do[Do.Cmpt=1953525091]="Cmpt",Do[Do.I3dm=1835283305]="I3dm",Do[Do.A3x=5780289]="A3x",function(v){v[v.Success=0]="Success",v[v.InvalidTileData=1]="InvalidTileData",v[v.InvalidHeader=2]="InvalidHeader",v[v.InvalidBatchTable=3]="InvalidBatchTable",v[v.InvalidScene=4]="InvalidScene",v[v.InvalidFeatureTable=5]="InvalidFeatureTable",v[v.NewerMajorVersion=6]="NewerMajorVersion",v[v.Canceled=7]="Canceled"}(Eo||(Eo={}));class Ro{constructor(v){this._format=function(v){const M=v;return function(v){switch(v){case bo.Unknown:case bo.B3dm:case bo.Gltf:case bo.IModel:case bo.Pnts:case bo.Cmpt:case bo.I3dm:case bo.A3x:return!0;default:return!1}}(M)?M:bo.Unknown}(v.readUint32()),this.version=v.readUint32()}get format(){return this._format}invalidate(){this._format=bo.Unknown}}function zo(v,M){const b=v.readFloat64(),E=v.readFloat64(),D=v.readFloat64();return void 0===M?new Q(b,E,D):(M.set(b,E,D),M)}!function(v){v[v.Version1=1]="Version1",v[v.Version2=2]="Version2",v[v.CurrentVersion=1]="CurrentVersion",v[v.Gltf1SceneFormat=0]="Gltf1SceneFormat"}(Xo||(Xo={})),function(v){v[v.JSON=1313821514]="JSON",v[v.Binary=5130562]="Binary"}(Jo||(Jo={}));class No{get isTileSection(){return No.Type.TileSection===this.type}get isGlyph(){return No.Type.Glyph===this.type}get isSkyBox(){return No.Type.SkyBox===this.type}constructor(v){this.type=v}}!function(v){let M;!function(v){v[v.Normal=0]="Normal",v[v.Glyph=1]="Glyph",v[v.TileSection=2]="TileSection",v[v.SkyBox=3]="SkyBox",v[v.FilteredTileSection=4]="FilteredTileSection",v[v.ThematicGradient=5]="ThematicGradient"}(M=v.Type||(v.Type={})),v.Params=class{constructor(M,b=v.Type.Normal,E=!1){this.key=M,this.type=b,this.isOwned=E}get isTileSection(){return v.Type.TileSection===this.type}get isGlyph(){return v.Type.Glyph===this.type}get isSkyBox(){return v.Type.SkyBox===this.type}}}(No||(No={}));class Yo{constructor(v){this.key=v.key,this.textureMapping=v.textureMapping}get hasTexture(){return void 0!==this.textureMapping?.texture}}!function(v){class e{constructor(v){this.diffuse=.6,this.specular=.4,this.specularExponent=13.5,this.reflect=0,this.refract=1,this.ambient=.3,this.shadows=!0,this.key=v}get alpha(){return this._alpha}set alpha(v){var M;this._alpha=void 0!==v?(M=v,Math.max(0,Math.min(1,M))):void 0}static fromColors(v,M,b,E,D,X){const z=new e;return z.key=v,z.diffuseColor=M,z.specularColor=b,z.emissiveColor=E,z.reflectColor=D,z.textureMapping=X,z}}e.defaults=new e,v.Params=e}(Yo||(Yo={})),Object.freeze(Yo.Params.defaults),function(v){function e(M,b=v.rangeScale16){return M>=0&&M<b+1}function i(M,b,E,D=v.rangeScale16){return Math.floor(Math.max(0,Math.min(D,.5+(M-b)*E)))}v.rangeScale16=65535,v.rangeScale8=255,v.computeScale=function(M,b=v.rangeScale16){return 0===M?M:b/M},v.isInRange=e,v.quantize=i,v.isQuantizable=function(M,b,E,D=v.rangeScale16){return e(i(M,b,E,D))},v.unquantize=function(v,M,b){return 0===b?M:M+v/b},v.isQuantized=function(v){return e(v)&&v===Math.floor(v)}}(wa||(wa={}));class Oo{constructor(v=0,M=0,b=0,E=0){this.origin=new H,this.scale=new H,this.setFrom(v,M,b,E)}setFrom(v,M,b,E){this.origin.x=v,this.origin.y=M,this.scale.x=b,this.scale.y=E}copyFrom(v){this.setFrom(v.origin.x,v.origin.y,v.scale.x,v.scale.y)}clone(v){const M=void 0!==v?v:new Oo;return M.copyFrom(this),M}setFromRange(v,M=wa.rangeScale16){v.isNull?this.origin.x=this.origin.y=this.scale.x=this.scale.y=0:this.setFrom(v.low.x,v.low.y,wa.computeScale(v.high.x-v.low.x,M),wa.computeScale(v.high.y-v.low.y,M))}static fromRange(v,M,b=wa.rangeScale16){const E=void 0!==M?M:new Oo;return E.setFromRange(v,b),E}unquantize(v,M,b){return(b=b??new H).x=wa.unquantize(v,this.origin.x,this.scale.x),b.y=wa.unquantize(M,this.origin.y,this.scale.y),b}static fromNormalizedRange(v=wa.rangeScale16){return Oo.fromRange(gt.createArray([H.create(-1,-1),H.create(1,1)]),void 0,v)}static fromZeroToOne(v=wa.rangeScale16){return Oo.fromRange(gt.createArray([H.create(0,0),H.create(1,1)]),void 0,v)}static fromOriginAndScale(v,M,b,E){return new Oo(v,M,b,E)}get rangeDiagonal(){return J.createFrom({x:0===this.scale.x?0:wa.rangeScale16/this.scale.x,y:0===this.scale.y?0:wa.rangeScale16/this.scale.y})}isQuantizable(v){return wa.isQuantizable(v.x,this.origin.x,this.scale.x)&&wa.isQuantizable(v.y,this.origin.y,this.scale.y)}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y},scale:{x:this.scale.x,y:this.scale.y}}}static fromJSON(v){return this.fromOriginAndScale(v.origin.x,v.origin.y,v.scale.x,v.scale.y)}}class Bo{get x(){return this._x}set x(v){e(wa.isQuantized(v)),this._x=v}get y(){return this._y}set y(v){e(wa.isQuantized(v)),this._y=v}constructor(){this._x=0,this._y=0}init(v,M){this.x=wa.quantize(v.x,M.origin.x,M.scale.x),this.y=wa.quantize(v.y,M.origin.y,M.scale.y)}static create(v,M){const b=new Bo;return b.init(v,M),b}copyFrom(v){this.x=v.x,this.y=v.y}clone(v){const M=void 0!==v?v:new Bo;return M.copyFrom(this),M}setFromScalars(v,M){this.x=v,this.y=M}static fromScalars(v,M){const b=new Bo;return b.setFromScalars(v,M),b}unquantize(v,M){const b=void 0!==M?M:new H;return b.x=wa.unquantize(this.x,v.origin.x,v.scale.x),b.y=wa.unquantize(this.y,v.origin.y,v.scale.y),b}}!function(v){const M=new Bo;function i(v,M,b){const E=2*M,D=v[E+0],X=v[E+1];if(void 0===D||void 0===X)throw new Error("Index out of range");return(b=b??new Bo).setFromScalars(D,X),b}v.getQPoint=i,v.unquantizePoint=function(v,b,E){return i(v.points,b,M).unquantize(v.params,E)}}(Ca||(Ca={}));class Vo{constructor(v=0,M=0,b=0,E=0,D=0,X=0){this.origin=new Q,this.scale=new Q,this.setFrom(v,M,b,E,D,X)}setFrom(v,M,b,E,D,X){this.origin.x=v,this.origin.y=M,this.origin.z=b,this.scale.x=E,this.scale.y=D,this.scale.z=X}copyFrom(v){this.setFrom(v.origin.x,v.origin.y,v.origin.z,v.scale.x,v.scale.y,v.scale.z)}clone(v){const M=void 0!==v?v:new Vo;return M.copyFrom(this),M}setFromOriginAndScale(v,M){this.setFrom(v.x,v.y,v.z,M.x,M.y,M.z)}setFromRange(v,M=wa.rangeScale16){v.isNull?(this.origin.x=this.origin.y=this.origin.z=0,this.scale.x=this.scale.y=this.scale.z=0):this.setFrom(v.low.x,v.low.y,v.low.z,wa.computeScale(v.high.x-v.low.x,M),wa.computeScale(v.high.y-v.low.y,M),wa.computeScale(v.high.z-v.low.z,M))}unquantize(v,M,b,E){const D=void 0!==E?E:new Q;return D.x=wa.unquantize(v,this.origin.x,this.scale.x),D.y=wa.unquantize(M,this.origin.y,this.scale.y),D.z=wa.unquantize(b,this.origin.z,this.scale.z),D}static fromRange(v,M,b=wa.rangeScale16){const E=void 0!==M?M:new Vo;return E.setFromRange(v,b),E}static fromOriginAndScale(v,M,b){const E=void 0!==b?b:new Vo;return E.setFromOriginAndScale(v,M),E}static fromNormalizedRange(v=wa.rangeScale16){return Vo.fromRange(ut.createArray([Q.create(-1,-1,-1),Q.create(1,1,1)]),void 0,v)}static fromZeroToOne(v=wa.rangeScale16){return Vo.fromRange(ut.createArray([Q.create(0,0,0),Q.create(1,1,1)]),void 0,v)}get rangeDiagonal(){return $.createFrom({x:0===this.scale.x?0:wa.rangeScale16/this.scale.x,y:0===this.scale.y?0:wa.rangeScale16/this.scale.y,z:0===this.scale.z?0:wa.rangeScale16/this.scale.z})}isQuantizable(v){return wa.isQuantizable(v.x,this.origin.x,this.scale.x)&&wa.isQuantizable(v.y,this.origin.y,this.scale.y)&&wa.isQuantizable(v.z,this.origin.z,this.scale.z)}computeRange(v){const M=ut.createNull(v);return M.extendPoint(this.origin),M.extendPoint(this.origin.plus(this.rangeDiagonal)),M}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y,z:this.origin.z},scale:{x:this.scale.x,y:this.scale.y,z:this.scale.z}}}static fromJSON(v,M){return this.fromOriginAndScale(Q.fromJSON(v.origin),Q.fromJSON(v.scale),M)}}class Lo{get x(){return this._x}set x(v){e(wa.isQuantized(v)),this._x=v}get y(){return this._y}set y(v){e(wa.isQuantized(v)),this._y=v}get z(){return this._z}set z(v){e(wa.isQuantized(v)),this._z=v}constructor(){this._x=0,this._y=0,this._z=0}init(v,M){this.x=wa.quantize(v.x,M.origin.x,M.scale.x),this.y=wa.quantize(v.y,M.origin.y,M.scale.y),this.z=wa.quantize(v.z,M.origin.z,M.scale.z)}static create(v,M){const b=new Lo;return b.init(v,M),b}copyFrom(v){this.x=v.x,this.y=v.y,this.z=v.z}clone(v){const M=void 0!==v?v:new Lo;return M.copyFrom(this),M}setFromScalars(v,M,b){this.x=v,this.y=M,this.z=b}static fromScalars(v,M,b,E){const D=void 0===E?new Lo:E;return D.setFromScalars(v,M,b),D}unquantize(v,M){const b=void 0!==M?M:new Q;return b.x=wa.unquantize(this.x,v.origin.x,v.scale.x),b.y=wa.unquantize(this.y,v.origin.y,v.scale.y),b.z=wa.unquantize(this.z,v.origin.z,v.scale.z),b}equals(v){return this.x===v.x&&this.y===v.y&&this.z===v.z}compare(v){let M=this.x-v.x;return 0===M&&(M=this.y-v.y,0===M&&(M=this.z-v.z)),M}}!function(v){const M=new Lo;function i(v,M,b){const E=3*M,D=v[E+0],X=v[E+1],z=v[E+2];if(void 0===D||void 0===X||void 0===z)throw new Error("Index out of range");return(b=b??new Lo).setFromScalars(D,X,z),b}v.getQPoint=i,v.unquantizePoint=function(v,b,E){return i(v.points,b,M).unquantize(v.params,E)}}(ka||(ka={})),Symbol.iterator,function(v){v[v.None=0]="None",v[v.ContainsCurves=1]="ContainsCurves",v[v.Incomplete=4]="Incomplete",v[v.DisallowMagnification=8]="DisallowMagnification",v[v.MultiModelFeatureTable=16]="MultiModelFeatureTable"}(Oa||(Oa={})),function(v){v[v.Major=32]="Major",v[v.Minor=0]="Minor",v[v.Combined=2097152]="Combined"}(Ba||(Ba={}));class Uo extends Ro{get versionMajor(){return this.version>>>16}get versionMinor(){return(65535&this.version)>>>0}get isValid(){return bo.IModel===this.format}get isReadableVersion(){return this.versionMajor<=Ba.Major}constructor(v){super(v),this.headerLength=v.readUint32(),this.flags=v.readUint32(),this.contentRange=new ut,zo(v,this.contentRange.low),zo(v,this.contentRange.high),this.tolerance=v.readFloat64(),this.numElementsIncluded=v.readUint32(),this.numElementsExcluded=v.readUint32(),this.tileLength=v.readUint32(),this.emptySubRanges=this.versionMajor>=2?v.readUint32():0;const M=this.headerLength-v.curPos;e(M>=0),v.advance(M),v.isPastTheEnd&&this.invalidate()}}class Zo{static readFrom(v){const M=v.readUint32(),b=v.readUint32(),E=v.readUint32();return v.isPastTheEnd?void 0:new Zo(M,b,E)}constructor(v,M,b){this.length=v,this.numSubCategories=M,this.count=b}}Zo.sizeInBytes=12,function(v){v[v.Normal=0]="Normal",v[v.Edge=1]="Edge",v[v.Outline=2]="Outline"}(Va||(Va={}));class qo{constructor(v,M){this.texture=v,this.params=M}computeUVParams(v,M){return this.params.computeUVParams(v,M)}}!function(v){let M;!function(v){v[v.None=-1]="None",v[v.Parametric=0]="Parametric",v[v.ElevationDrape=1]="ElevationDrape",v[v.Planar=2]="Planar",v[v.DirectionalDrape=3]="DirectionalDrape",v[v.Cubic=4]="Cubic",v[v.Spherical=5]="Spherical",v[v.Cylindrical=6]="Cylindrical",v[v.Solid=7]="Solid",v[v.FrontProject=8]="FrontProject"}(M=v.Mode||(v.Mode={}));class i{constructor(v=1,M=0,b=0,E=0,D=1,X=0){const z=new Q(b,X,0),R=xt.createRowValues(v,M,0,E,D,0,0,0,1);this.transform=pt.createRefs(z,R)}}i.identity=new i,v.Trans2x3=i,v.Params=class{constructor(v){this.textureMatrix=v?.textureMat2x3??i.identity,this.weight=v?.textureWeight??1,this.mode=v?.mapMode??M.Parametric,this.worldMapping=v?.worldMapping??!1,this.useConstantLod=v?.useConstantLod??!1,this.constantLodParams={repetitions:v?.constantLodProps?.repetitions??1,offset:v?.constantLodProps?.offset??{x:0,y:0},minDistClamp:v?.constantLodProps?.minDistClamp??1,maxDistClamp:v?.constantLodProps?.maxDistClamp??4294967296}}computeUVParams(M,b){switch(this.mode){default:case v.Mode.Parametric:return this.computeParametricUVParams(M,this.textureMatrix.transform,!this.worldMapping);case v.Mode.Planar:{const v=M.normalIndex;if(!v)return;return this.worldMapping&&(void 0===M.normalIndex||v[0]===v[1]&&v[0]===v[2])?this.computePlanarUVParams(M,this.textureMatrix.transform):this.computeParametricUVParams(M,this.textureMatrix.transform,!this.worldMapping)}case v.Mode.ElevationDrape:return this.computeElevationDrapeUVParams(M,this.textureMatrix.transform,b)}}computeParametricUVParams(v,M,b){const E=[];for(let D=0;D<v.numEdgesThisFacet;D++){let X=H.create();!b&&v.tryGetDistanceParameter(D,X)||v.tryGetNormalizedParameter(D,X)||(X=v.getParam(D)),E.push(M.multiplyPoint2d(X))}return E}computePlanarUVParams(v,M){const b=[],E=v.point;let D;if(D=void 0===v.normal?E.getPoint3dAtUncheckedPointIndex(0).crossProductToPoints(E.getPoint3dAtUncheckedPointIndex(1),E.getPoint3dAtUncheckedPointIndex(2)):v.normal.getVector3dAtCheckedVectorIndex(0),!D.normalize(D))return;D.scale(-1,D);const X=$.create(D.y,-D.x,0),z=X.magnitude();X.normalize(X),z<.001&&(D.set(0,0,-1),X.set(1,0,0));const R=X.crossProduct(D).normalize();if(!R)return;const O=v.numEdgesThisFacet;for(let Y=0;Y<O;Y++){const v=$.createFrom(E.getPoint3dAtUncheckedPointIndex(Y));b.push(H.create(v.dotProduct(X),v.dotProduct(R))),M.multiplyPoint2d(b[Y],b[Y])}return b}computeElevationDrapeUVParams(v,M,b){const E=[],D=v.numEdgesThisFacet;for(let X=0;X<D;X++){const D=v.point.getPoint3dAtUncheckedPointIndex(X);void 0!==b&&b.multiplyPoint3d(D,D),E.push(H.createFrom(D)),M.multiplyPoint2d(E[X],E[X])}return E}}}(qo||(qo={})),Object.freeze(qo.Trans2x3.identity),(tc=La||(La={}))[tc.Solid=0]="Solid",tc[tc.Code0=0]="Code0",tc[tc.Code1=2155905152]="Code1",tc[tc.Code2=4177066232]="Code2",tc[tc.Code3=4292935648]="Code3",tc[tc.Code4=4262526480]="Code4",tc[tc.Code5=3772834016]="Code5",tc[tc.Code6=4169726088]="Code6",tc[tc.Code7=4279828248]="Code7",tc[tc.HiddenLine=3435973836]="HiddenLine",tc[tc.Invisible=1]="Invisible",tc[tc.Invalid=-1]="Invalid",function(v){v[v.None=0]="None",v[v.ByView=1]="ByView",v[v.Always=2]="Always",v[v.Behind=4]="Behind",v[v.Blanking=6]="Blanking",v[v.Background=8]="Background"}(Ua||(Ua={})),function(v){v[v.Rgba=0]="Rgba",v[v.Rgb=2]="Rgb",v[v.Alpha=5]="Alpha"}(Ka||(Ka={}));class Wo{get numBytesPerPixel(){return Wo.getNumBytesPerPixel(this.format)}static getNumBytesPerPixel(v){switch(v){case Ka.Alpha:return 1;case Ka.Rgb:return 3;default:return 4}}get height(){return Wo.computeHeight(this.data,this.format,this.width)}static create(v,M,b){if(!this.isValidData(v,M,b))throw new Error("The number of bytes supplied for ImageBuffer do not match its width and format.");return new Wo(v,M,b)}static isValidData(v,M,b){const E=this.computeHeight(v,M,b);return b>0&&E>0&&Math.floor(b)===b&&Math.floor(E)===E}static computeHeight(v,M,b){return v.length/(b*this.getNumBytesPerPixel(M))}constructor(v,M,b){this.data=v,this.format=M,this.width=b}}!function(v){v[v.Jpeg=0]="Jpeg",v[v.Png=2]="Png",v[v.Svg=3]="Svg"}(Za||(Za={})),function(v){v[v.Opaque=0]="Opaque",v[v.Translucent=1]="Translucent",v[v.Mixed=2]="Mixed"}(Wa||(Wa={})),function(v){v[v.Smooth=0]="Smooth",v[v.Stepped=1]="Stepped",v[v.SteppedWithDelimiter=2]="SteppedWithDelimiter",v[v.IsoLines=3]="IsoLines"}(qa||(qa={})),function(v){v[v.SurfaceOnly=0]="SurfaceOnly",v[v.MultiplySurfaceAndGradient=1]="MultiplySurfaceAndGradient"}(Qa||(Qa={})),function(v){v[v.BlueRed=0]="BlueRed",v[v.RedBlue=1]="RedBlue",v[v.Monochrome=2]="Monochrome",v[v.Topographic=3]="Topographic",v[v.SeaMountain=4]="SeaMountain",v[v.Custom=5]="Custom"}(Ga||(Ga={}));class Go{static get margin(){return.001}static get contentRange(){return 1-2*Go.margin}static get contentMax(){return 1-Go.margin}get textureTransparency(){let v=Wa.Opaque;if(Ga.Custom===this.colorScheme){let M=!1,b=!1;for(const v of this.customKeys){const E=v.color.isOpaque;M=M||E,b=b||!E}b&&(v=M?Wa.Mixed:Wa.Translucent)}return v!==Wa.Mixed&&this.marginColor.isOpaque!==(v===Wa.Opaque)&&(v=Wa.Mixed),v}equals(v){return!(this.mode!==v.mode||this.stepCount!==v.stepCount||!this.marginColor.equals(v.marginColor)||this.colorScheme!==v.colorScheme||this.customKeys.length!==v.customKeys.length||this.colorMix!==v.colorMix||this.transparencyMode!==v.transparencyMode)&&this.customKeys.every(((M,b)=>Ja.keyColorEquals(M,v.customKeys[b])))}static compare(v,M){let b=0;if(0!==(b=i(v.mode,M.mode)))return b;if(0!==(b=i(v.stepCount,M.stepCount)))return b;if(0!==(b=i(v.marginColor.tbgr,M.marginColor.tbgr)))return b;if(0!==(b=i(v.colorScheme,M.colorScheme)))return b;if(0!==(b=i(v.colorMix,M.colorMix)))return b;if(0!==(b=i(v.customKeys.length,M.customKeys.length)))return b;if(0!==(b=i(v.transparencyMode,M.transparencyMode)))return b;for(let E=0;E<v.customKeys.length;E++)if(0!==(b=i(v.customKeys[E].color.tbgr,M.customKeys[E].color.tbgr)))return b;return b}constructor(v){if(this.customKeys=[],void 0===v)this.mode=qa.Smooth,this.stepCount=10,this.marginColor=Mr.fromJSON(),this.colorScheme=Ga.BlueRed,this.colorMix=0,this.transparencyMode=Qa.SurfaceOnly;else{if(this.mode=void 0!==v.mode&&null!==v.mode?v.mode:qa.Smooth,(this.mode<qa.Smooth||this.mode>qa.IsoLines)&&(this.mode=qa.Smooth),this.stepCount="number"==typeof v.stepCount?v.stepCount:10,this.stepCount<2&&(this.stepCount=2),this.marginColor=Mr.fromJSON(v.marginColor),this.colorScheme=void 0!==v.colorScheme&&null!==v.colorScheme?v.colorScheme:Ga.BlueRed,(this.colorScheme<Ga.BlueRed||this.colorScheme>Ga.Custom)&&(this.colorScheme=Ga.BlueRed),void 0!==v.customKeys&&null!==v.customKeys&&v.customKeys.forEach((v=>this.customKeys.push(new Ja.KeyColor(v)))),this.colorScheme===Ga.Custom&&this.customKeys.length<2){this.customKeys=[];for(const v of Go._defaultCustomKeys)this.customKeys.push(new Ja.KeyColor({value:v[0],color:Mr.computeTbgrFromComponents(v[1],v[3],v[2])}))}this.colorMix=v.colorMix??0,this.transparencyMode=v.transparencyMode??Qa.SurfaceOnly}}static fromJSON(v){return v?new Go(v):this.defaults}toJSON(){const v={};qa.Smooth!==this.mode&&(v.mode=this.mode),10!==this.stepCount&&(v.stepCount=this.stepCount);const M=this.marginColor.toJSON();return 0!==M&&(v.marginColor=M),Ga.BlueRed!==this.colorScheme&&(v.colorScheme=this.colorScheme),0!==this.colorMix&&(v.colorMix=this.colorMix),Qa.SurfaceOnly!==this.transparencyMode&&(v.transparencyMode=this.transparencyMode),this.customKeys.length>0&&(v.customKeys=this.customKeys.map((v=>({value:v.value,color:v.color.toJSON()})))),v}clone(v){if(void 0===v)return Go.fromJSON(this.toJSON());const M={mode:void 0!==v.mode?v.mode:this.mode,stepCount:void 0!==v.stepCount?v.stepCount:this.stepCount,marginColor:void 0!==v.marginColor?v.marginColor:this.marginColor.tbgr,colorScheme:void 0!==v.colorScheme?v.colorScheme:this.colorScheme,customKeys:void 0!==v.customKeys?v.customKeys:this.customKeys.map((v=>({value:v.value,color:v.color.tbgr}))),colorMix:void 0!==v.colorMix?v.colorMix:this.colorMix,transparencyMode:v.transparencyMode??this.transparencyMode};return Go.fromJSON(M)}}Go.defaults=new Go({}),Go._defaultCustomKeys=[[0,255,255,255],[1,0,0,0]],function(v){v[v.Height=0]="Height",v[v.InverseDistanceWeightedSensors=1]="InverseDistanceWeightedSensors",v[v.Slope=2]="Slope",v[v.HillShade=3]="HillShade"}(Ha||(Ha={})),function(v){let M,b;!function(v){v[v.None=0]="None",v[v.Invert=1]="Invert",v[v.Outline=2]="Outline"}(M=v.Flags||(v.Flags={})),function(v){v[v.None=0]="None",v[v.Linear=1]="Linear",v[v.Curved=2]="Curved",v[v.Cylindrical=3]="Cylindrical",v[v.Spherical=4]="Spherical",v[v.Hemispherical=5]="Hemispherical",v[v.Thematic=6]="Thematic"}(b=v.Mode||(v.Mode={}));class n{constructor(v){this.value=v.value,this.color=Mr.fromJSON(v.color)}}v.KeyColor=n,v.keyColorEquals=function(v,M){return v.value===M.value&&v.color.equals(M.color)};class r{constructor(){this.mode=b.None,this.flags=M.None,this.shift=0,this.keys=[]}static fromJSON(v){const b=new r;return v?(b.mode=v.mode,b.flags=void 0===v.flags?M.None:v.flags,b.angle=v.angle?W.fromJSON(v.angle):void 0,b.tint=v.tint,b.shift=v.shift?v.shift:0,v.keys.forEach((v=>b.keys.push(new n(v)))),b.thematicSettings=void 0===v.thematicSettings?void 0:Go.fromJSON(v.thematicSettings),b):b}static createThematic(M){const E=new r;if(E.mode=b.Thematic,E.thematicSettings=M,M.colorScheme<Ga.Custom)for(const b of v.Symb._fixedSchemeKeys[M.colorScheme])E.keys.push(new n({value:b[0],color:Mr.computeTbgrFromComponents(b[1],b[3],b[2])}));else if(e(M.customKeys.length>1,"Custom thematic mode requires at least two keys to be defined"),M.customKeys.length>1)M.customKeys.forEach((v=>E.keys.push(v)));else for(const b of v.Symb._fixedCustomKeys)E.keys.push(new n({value:b[0],color:Mr.from(b[1],b[3],b[2]).toJSON()}));return E}toJSON(){return{...this,thematicSettings:this.thematicSettings?.toJSON(),keys:this.keys.map((v=>({value:v.value,color:v.color.toJSON()})))}}clone(){return r.fromJSON(this.toJSON())}equals(v){return 0===r.compareSymb(this,v)}static compareSymb(v,M){if(v===M)return 0;if(v.mode!==M.mode)return v.mode-M.mode;if(v.flags!==M.flags)return void 0===v.flags?-1:void 0===M.flags?1:v.flags-M.flags;if(v.tint!==M.tint)return void 0===v.tint?-1:void 0===M.tint?1:v.tint-M.tint;if(v.shift!==M.shift)return void 0===v.shift?-1:void 0===M.shift?1:v.shift-M.shift;if(void 0===v.angle!=(void 0===M.angle))return void 0===v.angle?-1:1;if(v.angle&&!v.angle.isAlmostEqualNoPeriodShift(M.angle))return v.angle.radians-M.angle.radians;if(v.keys.length!==M.keys.length)return v.keys.length-M.keys.length;for(let b=0;b<v.keys.length;b++){if(v.keys[b].value!==M.keys[b].value)return v.keys[b].value-M.keys[b].value;if(!v.keys[b].color.equals(M.keys[b].color))return v.keys[b].color.tbgr-M.keys[b].color.tbgr}if(v.thematicSettings!==M.thematicSettings){if(void 0===v.thematicSettings)return-1;if(void 0===M.thematicSettings)return 1;{const b=Go.compare(v.thematicSettings,M.thematicSettings);if(0!==b)return b}}return 0}compare(M){return v.Symb.compareSymb(this,M)}roundToByte(v){return 255&Math.min(v+.5,255)}mapColor(v){v<0?v=0:v>1&&(v=1),0!=(this.flags&M.Invert)&&(v=1-v);let b,E,D,X=0;if(this.keys.length<=2)E=1-v,D=v;else{for(;X<this.keys.length-2&&v>this.keys[X+1].value;)X++;b=this.keys[X+1].value-this.keys[X].value,D=b<1e-4?0:(v-this.keys[X].value)/b,E=1-D}const z=this.keys[X].color,R=this.keys[X+1].color,O=z.colors,Y=R.colors,N=E*O.r+D*Y.r,B=E*O.g+D*Y.g,V=E*O.b+D*Y.b,L=E*O.t+D*Y.t;return Mr.from(this.roundToByte(N),this.roundToByte(B),this.roundToByte(V),this.roundToByte(L))}get hasTranslucency(){for(const v of this.keys)if(!v.color.isOpaque)return!0;return!1}get isOutlined(){return 0!=(this.flags&M.Outline)}getThematicImageForRenderer(v){e(b.Thematic===this.mode,"getThematicImageForRenderer only is used for thematic display.");let M=this.thematicSettings;void 0===M&&(M=Go.defaults);const E=Math.min(M.stepCount,v),D=qa.Smooth===M.mode?v:E,X=new Uint8Array(1*D*4);let z=X.length-1;function c(v){X[z--]=v.getAlpha(),X[z--]=v.colors.b,X[z--]=v.colors.g,X[z--]=v.colors.r}switch(M.mode){case qa.Smooth:for(let v=0;v<D;v++){const M=1-v/D;c(this.mapColor(M))}break;case qa.SteppedWithDelimiter:case qa.IsoLines:case qa.Stepped:e(M.stepCount>1,"Step count must be at least two to generate renderer gradient for thematic display");for(let v=0;v<D;v++){const M=1-v/(D-1);c(this.mapColor(M))}}e(-1===z);const R=Wo.create(X,Ka.Rgba,1);return e(void 0!==R),R}getImage(v,M){return this.mode===b.Thematic&&(v=1),this.produceImage({width:v,height:M,includeThematicMargin:!0})}produceImage(v){const{width:M,height:E,includeThematicMargin:D}={...v},X=void 0===this.angle?0:this.angle.radians,z=Math.cos(X),R=Math.sin(X),O=new Uint8Array(M*E*4);let Y=O.length-1;const N=Math.min(1,Math.abs(this.shift));switch(this.mode){case b.Linear:case b.Cylindrical:{const v=.5-.25*N*z,D=.5-.25*N*R;let X,B,V=X=0;for(let M=0;M<2;M++)for(let b=0;b<2;b++)B=(b-v)*z+(M-D)*R,B<V&&(V=B),B>X&&(X=B);for(let N=0;N<E;N++){const L=N/E-D;for(let E=0;E<M;E++){let D;B=(E/M-v)*z+L*R,D=this.mode===b.Linear?B>0?.5+.5*B/X:.5-.5*B/V:B>0?Math.sin(Math.PI/2*(1-B/X)):Math.sin(Math.PI/2*(1-B/V));const N=this.mapColor(D);O[Y--]=N.getAlpha(),O[Y--]=N.colors.b,O[Y--]=N.colors.g,O[Y--]=N.colors.r}}break}case b.Curved:{const v=.5+.5*R-.25*N*z,b=.5-.5*z-.25*N*R;for(let D=0;D<E;D++){const X=D/E-b;for(let b=0;b<M;b++){const E=b/M-v,D=.8*(E*z+X*R),N=X*z-E*R,B=Math.sin(Math.PI/2*(1-Math.sqrt(D*D+N*N))),V=this.mapColor(B);O[Y--]=V.getAlpha(),O[Y--]=V.colors.b,O[Y--]=V.colors.g,O[Y--]=V.colors.r}}break}case b.Spherical:{const v=.5+.125*Math.sin(2*X),b=.5*N*(z+R)*v,D=.5*N*(R-z)*v;for(let X=0;X<E;X++){const z=D+X/E-.5;for(let E=0;E<M;E++){const D=b+E/M-.5,X=Math.sin(Math.PI/2*(1-Math.sqrt(D*D+z*z)/v)),R=this.mapColor(X);O[Y--]=R.getAlpha(),O[Y--]=R.colors.b,O[Y--]=R.colors.g,O[Y--]=R.colors.r}}break}case b.Hemispherical:{const v=.5+.5*R-.5*N*z,b=.5-.5*z-.5*N*R;for(let D=0;D<E;D++){const X=D/E-b;for(let b=0;b<M;b++){const E=b/M-v,D=Math.sin(Math.PI/2*(1-Math.sqrt(E*E+X*X))),z=this.mapColor(D);O[Y--]=z.getAlpha(),O[Y--]=z.colors.b,O[Y--]=z.colors.g,O[Y--]=z.colors.r}}break}case b.Thematic:{const v=this.thematicSettings??Go.defaults;for(let b=0;b<E;b++){let X,z=1-b/E;if(D&&(z<Go.margin||z>Go.contentMax))X=v.marginColor;else switch(z=(z-Go.margin)/Go.contentRange,v.mode){case qa.SteppedWithDelimiter:case qa.IsoLines:case qa.Stepped:if(v.stepCount>1){const M=Math.floor(z*v.stepCount-1e-5)/(v.stepCount-1);X=this.mapColor(M)}break;case qa.Smooth:X=this.mapColor(z)}for(let v=0;v<M;v++)O[Y--]=X.getAlpha(),O[Y--]=X.colors.b,O[Y--]=X.colors.g,O[Y--]=X.colors.r}}}e(-1===Y);const B=Wo.create(O,Ka.Rgba,M);return e(void 0!==B),B}}r._fixedSchemeKeys=[[[0,0,255,0],[.25,0,255,255],[.5,0,0,255],[.75,255,0,255],[1,255,0,0]],[[0,255,0,0],[.25,255,0,255],[.5,0,0,255],[.75,0,255,255],[1,0,255,0]],[[0,0,0,0],[1,255,255,255]],[[0,152,148,188],[.5,204,160,204],[1,152,72,128]],[[0,0,255,0],[.2,72,96,160],[.4,152,96,160],[.6,128,32,104],[.7,148,180,128],[1,240,240,240]]],r._fixedCustomKeys=[[0,255,0,0],[1,0,255,0]],v.Symb=r}(Ja||(Ja={})),function(v){v[v.Mesh=0]="Mesh",v[v.Polyline=1]="Polyline",v[v.Point=2]="Point"}($a||($a={})),function(v){v[v.Unlit=0]="Unlit",v[v.Lit=1]="Lit",v[v.Textured=2]="Textured",v[v.TexturedLit=3]="TexturedLit",v[v.VolumeClassifier=4]="VolumeClassifier"}(ja||(ja={}));class Ho{constructor(v,M,b,E=0,D=La.Solid,X=Ua.None,z,R,O=!1,Y){this.type=Ho.Type.Mesh,this.type=v,this.material=z,this.gradient=R,this.lineColor=Ho.adjustTransparency(M),this.fillColor=Ho.adjustTransparency(b),this.width=E,this.linePixels=D,this.fillFlags=X,this.ignoreLighting=O,this._textureMapping=Y,e(void 0===z||void 0===Y)}static createForType(v,M,b,E=!1){const D=Ho.adjustTransparency(M.lineColor);switch(v){case Ho.Type.Mesh:{let X;if(void 0!==M.gradient&&void 0!==b){const v=b(M.gradient);void 0!==v&&(X=new qo(v,new qo.Params))}return new Ho(v,D,Ho.adjustTransparency(M.fillColor),M.rasterWidth,M.linePixels,M.fillFlags,M.material,M.gradient,E,X)}case Ho.Type.Linear:return new Ho(v,D,D,M.rasterWidth,M.linePixels);default:return new Ho(v,D,D,0,La.Solid,Ua.Always,void 0,void 0,!0)}}static createForMesh(v,M,b){return Ho.createForType(Ho.Type.Mesh,v,b,M)}static createForLinear(v){return Ho.createForType(Ho.Type.Linear,v)}static createForText(v){return Ho.createForType(Ho.Type.Text,v)}get regionEdgeType(){return this.hasBlankingFill?Ho.RegionEdgeType.None:void 0!==this.gradient&&void 0!==this.gradient.flags?0!=(this.gradient.flags&Ja.Flags.Outline)||Ua.None===(this.fillFlags&Ua.Always)?Ho.RegionEdgeType.Outline:Ho.RegionEdgeType.None:this.fillColor.equals(this.lineColor)?Ho.RegionEdgeType.Default:Ho.RegionEdgeType.Outline}get wantRegionOutline(){return Ho.RegionEdgeType.Outline===this.regionEdgeType}get hasBlankingFill(){return Ua.Blanking===(this.fillFlags&Ua.Blanking)}get hasFillTransparency(){return 255!==this.fillColor.getAlpha()}get hasLineTransparency(){return 255!==this.lineColor.getAlpha()}get textureMapping(){return void 0!==this.material?this.material.textureMapping:this._textureMapping}get isTextured(){return void 0!==this.textureMapping}equals(v,M=Ho.ComparePurpose.Strict){return Ho.ComparePurpose.Merge===M?0===this.compareForMerge(v):v===this||this.type===v.type&&this.ignoreLighting===v.ignoreLighting&&this.width===v.width&&this.linePixels===v.linePixels&&this.fillFlags===v.fillFlags&&this.wantRegionOutline===v.wantRegionOutline&&this.material===v.material&&this.textureMapping===v.textureMapping&&!!this.fillColor.equals(v.fillColor)&&!!this.lineColor.equals(v.lineColor)}compareForMerge(v){if(v===this)return 0;let M=i(this.type,v.type);return 0===M&&(M=s(this.ignoreLighting,v.ignoreLighting),0===M&&(M=i(this.width,v.width),0===M&&(M=i(this.linePixels,v.linePixels),0===M&&(M=i(this.fillFlags,v.fillFlags),0===M&&(M=s(this.wantRegionOutline,v.wantRegionOutline),0===M&&(M=s(this.hasFillTransparency,v.hasFillTransparency),0===M&&(M=s(this.hasLineTransparency,v.hasLineTransparency),0===M&&(M=function(v,M){return r(((v,M)=>v===M?0:o(v.key,M.key)),v,M)}(this.material,v.material),0===M&&void 0===this.material&&this.isTextured&&(this.textureMapping,v.textureMapping,M=0))))))))),M}static adjustTransparency(v){return v.colors.t<Ho.minTransparency?v.withTransparency(0):v}}Ho.minTransparency=15,function(v){let M,b,E;!function(v){v[v.Mesh=0]="Mesh",v[v.Linear=1]="Linear",v[v.Text=2]="Text"}(M=v.Type||(v.Type={})),function(v){v[v.None=0]="None",v[v.Default=1]="Default",v[v.Outline=2]="Outline"}(b=v.RegionEdgeType||(v.RegionEdgeType={})),function(v){v[v.Merge=0]="Merge",v[v.Strict=1]="Strict"}(E=v.ComparePurpose||(v.ComparePurpose={}))}(Ho||(Ho={}));const ec=new Uint16Array(1);function Ko(v){return jo(.5+255*(.5*function(v,M,b){return v<-1?-1:v>1?1:v}(v)+.5))}function jo(v){return ec[0]=v,ec[0]}function Qo(v){return v<0?-1:1}class $o{constructor(v){this.value=jo(v)}static encode(v){return this.encodeXYZ(v.x,v.y,v.z)}static encodeXYZ(v,M,b){const E=Math.abs(v)+Math.abs(M)+Math.abs(b);let D=v/E,X=M/E;if(b<0){const v=D,M=X;D=(1-Math.abs(M))*Qo(v),X=(1-Math.abs(v))*Qo(M)}return Ko(X)<<8|Ko(D)}static fromVector(v){return new $o(this.encode(v))}decode(){return $o.decodeValue(this.value)}static decodeValue(v,M){let b=255&v,E=v>>8;b=b/255*2-1,E=E/255*2-1;const D=1-(Math.abs(b)+Math.abs(E));let X;if(void 0===M?X=new $(b,E,D):(X=M,X.x=b,X.y=E,X.z=D),X.z<0){const v=X.x,M=X.y;X.x=(1-Math.abs(M))*Qo(v),X.y=(1-Math.abs(v))*Qo(M)}return X.normalizeInPlace(),X}}function ta(v,M,b,E){const D=v*M+b;if(D<E)return{width:D,height:1};let X=Math.ceil(Math.sqrt(D));const z=X%M;0!==z&&(X+=M-z);let R=Math.ceil(D/X);return X*R<D&&++R,e(R<=E),e(X<=E),e(X*R>=D),e(Math.floor(R)===R),e(Math.floor(X)===X),e(0==X%M),{width:X,height:R}}class ea{constructor(v){this.name=v.name,this.inputs=v.inputs,this.indices=v.indices}toJSON(){return{name:this.name,inputs:this.inputs,indices:this.indices}}}class ia extends ea{constructor(v){super(v),this.qOrigin=Float32Array.from(v.qOrigin),this.qScale=Float32Array.from(v.qScale)}toJSON(){return{...super.toJSON(),qOrigin:Array.from(this.qOrigin),qScale:Array.from(this.qScale)}}}class sa extends ea{constructor(v){super(v),this.qOrigin=v.qOrigin[0],this.qScale=v.qScale[0]}toJSON(){return{...super.toJSON(),qOrigin:[this.qOrigin],qScale:[this.qScale]}}}class na{constructor(v,M,b,E){this.data=v.data,this.width=v.width,this.height=v.height,this.numVertices=v.count,this.numBytesPerVertex=v.numBytesPerVertex,this.displacements=M,this.normals=b,this.params=E}static fromJSON(v){let M,b,E;if(void 0!==v.displacements&&0<v.displacements.length){M=[];for(const b of v.displacements)M.push(new ia(b))}if(void 0!==v.normals&&0<v.normals.length){b=[];for(const M of v.normals)b.push(new ea(M))}if(void 0!==v.params&&0<v.params.length){E=[];for(const M of v.params)E.push(new sa(M))}return void 0!==M||void 0!==b||void 0!==E?new na(v,M,b,E):void 0}toJSON(){return{data:this.data,width:this.width,height:this.height,count:this.numVertices,numBytesPerVertex:this.numBytesPerVertex,displacements:this.displacements?.map((v=>v.toJSON())),normals:this.normals?.map((v=>v.toJSON())),params:this.params?.map((v=>v.toJSON()))}}static fromChannels(v,M,b){return oa.buildAuxChannelTable(v,M,b)}}function ra(v){return 0!==v&&(v=1/v),v}class oa{constructor(v,M){this._props=v,this._numBytesPerVertex=M,this._view=new DataView(v.data.buffer)}static buildAuxChannelTable(v,M,b){const E=v.reduce(((v,M)=>v+aa(M)),0);if(!E)return;const D=Math.floor((E+3)/4),X=4*D-E;let z;e(0===X||2===X),z=0!==X?ta(Math.floor((M+1)/2),E/2,0,b):ta(M,D,0,b);const R={data:new Uint8Array(z.width*z.height*4),width:z.width,height:z.height,count:M,numBytesPerVertex:E};return new oa(R,E).build(v),na.fromJSON(R)}build(v){let M=0;for(const b of v)Fr.Normal===b.dataType?this.addNormals(b,M):Fr.Vector===b.dataType?this.addDisplacements(b,M):this.addParams(b,M),M+=aa(b)}addNormals(v,M){const b=[],E=[],D=new $;for(let X=0;X<v.data.length;X++){let z=M+2*X;E.push(z/2);const R=v.data[X];b.push(R.input);for(let v=0;v<R.values.length;v+=3){D.x=R.values[v],D.y=R.values[v+1],D.z=R.values[v+2],D.normalizeInPlace();const M=$o.encode(D);this._view.setUint16(z,M,!0),z+=this._numBytesPerVertex}}(this._props.normals??(this._props.normals=[])).push({name:v.name??"",inputs:b,indices:E})}addParams(v,M){const b=[],E=[],D=ft.createNull();for(const z of v.data)b.push(z.input),D.extendArray(z.values);const X=wa.computeScale(D.high-D.low);for(let z=0;z<v.data.length;z++){let b=M+2*z;E.push(b/2);for(const M of v.data[z].values){const v=wa.quantize(M,D.low,X);this._view.setUint16(b,v,!0),b+=this._numBytesPerVertex}}(this._props.params??(this._props.params=[])).push({inputs:b,indices:E,name:v.name??"",qOrigin:[D.low],qScale:[ra(X)]})}addDisplacements(v,M){const b=[],E=[],D=new Q,X=ut.createNull();for(const O of v.data){b.push(O.input);for(let v=0;v<O.values.length;v+=3)D.set(O.values[v],O.values[v+1],O.values[v+2]),X.extend(D)}const z=Vo.fromRange(X),R=new Lo;for(let O=0;O<v.data.length;O++){let b=M+6*O;E.push(b/2);const X=v.data[O];for(let v=0;v<X.values.length;v+=3)D.set(X.values[v],X.values[v+1],X.values[v+2]),R.init(D,z),this._view.setUint16(b+0,R.x,!0),this._view.setUint16(b+2,R.y,!0),this._view.setUint16(b+4,R.z,!0),b+=this._numBytesPerVertex}(this._props.displacements??(this._props.displacements=[])).push({inputs:b,indices:E,name:v.name??"",qOrigin:z.origin.toArray(),qScale:z.scale.toArray().map((v=>ra(v)))})}}function aa(v){const M=v.data.length;switch(v.dataType){case Fr.Vector:return 6*M;case Fr.Normal:case Fr.Distance:case Fr.Scalar:return 2*M}}class ca{constructor(v,M){this._constructor=v,this._data=new v(M?.initialCapacity??0),this.growthFactor=Math.max(1,M?.growthFactor??1.5),this._length=0}get length(){return this._length}get capacity(){return this._data.length}at(v){v<0&&(v=this.length-v);const M=this._data[v];return e(void 0!==M,"index out of bounds"),M}ensureCapacity(v){if(this.capacity>=v)return this.capacity;e(this.growthFactor>=1),v=Math.ceil(v*this.growthFactor);const M=this._data;return this._data=new this._constructor(v),this._data.set(M,0),e(this.capacity===v),this.capacity}push(v){this.ensureCapacity(this.length+1),this._data[this.length]=v,++this._length}append(v){const M=this.length+v.length;this.ensureCapacity(M),this._data.set(v,this.length),this._length=M}toTypedArray(v=!1){if(v)return this._data;const M=this._data.subarray(0,this.length);return e(M instanceof this._constructor),e(M.buffer===this._data.buffer),M}}class ha extends ca{constructor(v){super(Uint8Array,v)}}class la extends ca{constructor(v){super(Uint32Array,v)}toUint8Array(v=!1){return v?new Uint8Array(this._data.buffer):new Uint8Array(this._data.buffer,0,4*this.length)}}function da(v,M,b){let E=Math.ceil(1.5*v+2.5*M);const D=6*v;let X=0,z=E,R=1;if(E>=b){z=Math.ceil(Math.sqrt(E));const b=z%15;0!==b&&(z+=15-b),M>0&&v>0&&(X=(60-D%60)%10,E+=Math.ceil(X/4)),R=Math.ceil(E/z),z*R<E&&R++}return{width:z,height:R,silhouettePadding:X,silhouetteStartByteIndex:D}}class ua{constructor(v){this.data=v,e(0==this.data.length%3)}get length(){return this.data.length/3}static fromArray(v){const M=new Uint8Array(3*v.length);for(let b=0;b<v.length;b++)this.encodeIndex(v[b],M,3*b);return new ua(M)}static encodeIndex(v,M,b){e(b+2<M.length),M[b+0]=255&v,M[b+1]=(65280&v)>>8,M[b+2]=(16711680&v)>>16}setNthIndex(v,M){ua.encodeIndex(M,this.data,3*v)}decodeIndex(v){e(v<this.length);const M=3*v;return this.data[M]|this.data[M+1]<<8|this.data[M+2]<<16}decodeIndices(){const v=[];for(let M=0;M<this.length;M++)v.push(this.decodeIndex(M));return v}[Symbol.iterator](){return function*(v){for(let M=0;M<v.length;M++)yield v.decodeIndex(M)}(this)}}class fa{constructor(v=3){this._index32=new Uint32Array(1),this._index8=new Uint8Array(this._index32.buffer,0,3),this._builder=new ha({initialCapacity:3*v})}get numIndices(){return e(this._builder.length%3==0),this._builder.length/3}push(v){this._index32[0]=v,this._builder.append(this._index8)}toVertexIndices(){return new ua(this._builder.toTypedArray())}}class ga{constructor(v){this._source=v,this._builder=new la({initialCapacity:3*v.numRgbaPerVertex})}get length(){return e(this._builder.length%this.vertexSize==0),this._builder.length/this.vertexSize}get vertexSize(){return this._source.numRgbaPerVertex}push(v){e(v.length===this.vertexSize),this._builder.append(v)}buildVertexTable(v,M,b){const E=this._source;e(void 0!==(M=M??E.uniformColor));const D=M instanceof Uint32Array?M.length:0,X=b instanceof Uint32Array?b.length:0,z=ta(this.length,this.vertexSize,D+X,v);let R=this._builder.toTypedArray();if(z.width*z.height>R.length){const v=R;R=new Uint32Array(z.width*z.height),R.set(v,0)}let O=this.vertexSize*this.length;return M instanceof Uint32Array&&(R.set(M,O),O+=M.length),b instanceof Uint32Array&&R.set(b,O),{data:new Uint8Array(R.buffer,R.byteOffset,R.byteLength),usesUnquantizedPositions:E.usesUnquantizedPositions,qparams:E.qparams,width:z.width,height:z.height,hasTranslucency:E.hasTranslucency,uniformColor:M instanceof Mr?M:void 0,featureIndexType:E.featureIndexType,uniformFeatureID:E.uniformFeatureID,numVertices:this.length,numRgbaPerVertex:E.numRgbaPerVertex,uvParams:E.uvParams}}}class pa{constructor(v){this._remappedIndices=new Map,this.colors=[],this._32=new Uint32Array(1),this._16=new Uint16Array(this._32.buffer),this._colorTable=v}remap(v,M){const b=M?4:1,E=M?0:1;this._32[0]=v[b];const D=this._16[E];let X=this._remappedIndices.get(D);if(void 0===X){X=this.colors.length,this._remappedIndices.set(D,X);const v=this._colorTable[D];this.colors.push(v)}this._16[E]=X,v[b]=this._32[0]}buildColorTable(){return e(this.colors.length>0),this.colors.length>1?new Uint32Array(this.colors):Mr.fromAbgr(this.colors[0])}}class ma{constructor(v,M){this._remappedIndices=new Map,this.materials=[],this._32=new Uint32Array(1),this._8=new Uint8Array(this._32.buffer),this._atlasTable=v,this._createMaterial=M}remap(v,M){const b=M?3:2;this._32[0]=v[b];const E=this._8[3];let D=this._remappedIndices.get(E);if(void 0===D){D=this.materials.length/4,this._remappedIndices.set(E,D);let v=4*E;this.materials.push(this._atlasTable[v++]),this.materials.push(this._atlasTable[v++]),this.materials.push(this._atlasTable[v++]),this.materials.push(this._atlasTable[v])}this._8[3]=D,v[b]=this._32[0]}unpackFloat(v){this._32[0]=v;const M=this._32[0],b=(M>>>24)/2;let E=Math.floor(b),D=2*(b-E);return D=-(2*D-1),E-=38,D*(16777215&M)/16777216*Math.pow(10,E)}materialFromAtlasEntry(v){const M=0!=(16777216&v[1]),b={alpha:0!=(33554432&v[1])?(v[0]>>>24)/255:void 0,diffuse:{color:M?Mr.fromTbgr(16777215&v[0]):void 0,weight:(v[1]>>>8)/255},specular:{color:Mr.fromTbgr(v[2]),weight:(v[1]>>>16&255)/255,exponent:this.unpackFloat(v[3])}};return void 0===(E=this._createMaterial(b))?void 0:{isAtlas:!1,material:E};var E}buildAtlasTable(){e(this.materials.length>0);const v=new Uint32Array(this.materials);return this.materials.length>4?v:this.materialFromAtlasEntry(v)}}class xa{constructor(v,M){if(this.remappedIndices=new Map,this.indices=new fa,this.vertices=new ga(v),void 0===v.uniformColor&&(this.colors=new pa(new Uint32Array(v.data.buffer,v.data.byteOffset+4*v.numVertices*v.numRgbaPerVertex))),M){const b=4*(v.numVertices*v.numRgbaPerVertex+M.offset);this.atlas=new ma(new Uint32Array(v.data.buffer,v.data.byteOffset+b),M.createMaterial)}this.usesUnquantizedPositions=v.usesUnquantizedPositions}addVertex(v,M){let b=this.remappedIndices.get(v);void 0===b&&(b=this.vertices.length,this.remappedIndices.set(v,b),this.colors?.remap(M,this.usesUnquantizedPositions),this.atlas?.remap(M,this.usesUnquantizedPositions),this.vertices.push(M)),this.indices.push(b)}buildOutput(v){const M=this.atlas?.buildAtlasTable(),b=M instanceof Uint32Array?void 0:M;return{indices:this.indices.toVertexIndices(),vertices:this.vertices.buildVertexTable(v,this.colors?.buildColorTable(),M),material:b}}}class ya{constructor(v,M){this._nodes=new Map,this._input=v,this._computeNodeId=M}static split(v,M){const b=new ya(v,M);return b.split(),b._nodes}split(){const v={featureIndex:-1,node:void 0},M=this._input.vertices.numRgbaPerVertex,b=new Uint32Array(M),E=new Uint32Array(this._input.vertices.data.buffer,this._input.vertices.data.byteOffset,this._input.vertices.numVertices*M);let D;if(this._input.vertices.usesUnquantizedPositions){const v=new Uint8Array(b.buffer);D=()=>v[3]|v[7]<<8|v[11]<<16}else D=()=>16777215&b[2];for(const X of this._input.indices){const z=X*M;for(let v=0;v<b.length;v++)b[v]=E[z+v];const R=D();if(v.featureIndex!==R){v.featureIndex=R;const M=this._computeNodeId(R);let b=this._nodes.get(M);void 0===b&&this._nodes.set(M,b=new xa(this._input.vertices,this._input.atlasInfo)),v.node=b}v.node.addVertex(X,b)}}}function _a(v){const M=ya.split({indices:v.params.indices,vertices:v.params.vertices,featureTable:v.featureTable},v.computeNodeId),b=new Map;for(const[E,D]of M){const{vertices:M,indices:X}=D.buildOutput(v.maxDimension);b.set(E,{vertices:M,indices:X,weight:v.params.weight})}return b}class va{constructor(){this.indices=new fa,this.prevIndices=new fa,this.nextIndicesAndParams=new la}}function Pa(v,M,b){for(const[E,D]of b){const b=D.remappedIndices.get(M);if(void 0!==b)return v.index=b,v.node=D,v.id=E,!0}return e(!1),!1}function Ia(v,M,b,E){const D=M[v];if(!D)return;const X=new Uint32Array(D.endPointAndQuadIndices.buffer,D.endPointAndQuadIndices.byteOffset,D.endPointAndQuadIndices.length/4);let z;"silhouettes"===v&&(e(void 0!==M.silhouettes),z=new Uint32Array(M.silhouettes.normalPairs.buffer,M.silhouettes.normalPairs.byteOffset,M.silhouettes.normalPairs.length/4));let R=0;const O={};for(const Y of D.indices){if(Pa(O,Y,b)){let M=X[R];const b=(16777215&M)>>>0,D=O.node.remappedIndices.get(b);e(void 0!==D),M=4278190080&M|D;let Y=E.get(O.id);Y||E.set(O.id,Y={}),z?(Y.silhouettes||(Y.silhouettes={indices:new fa,endPointAndQuadIndices:new la,normalPairs:new la}),Y.silhouettes.normalPairs.push(z[R])):Y.segments||(Y.segments={indices:new fa,endPointAndQuadIndices:new la});const N=Y[v];e(void 0!==N),N.indices.push(O.index),N.endPointAndQuadIndices.push(M)}++R}}function Aa(v){const M=new Map,b=v.params.surface.material,E=void 0!==b&&b.isAtlas?b.vertexTableOffset:void 0,D=void 0!==E?{offset:E,createMaterial:v.createMaterial}:void 0,X=ya.split({indices:v.params.surface.indices,vertices:v.params.vertices,featureTable:v.featureTable,atlasInfo:D},v.computeNodeId),z=v.params.edges?function(v,M,b){const E=new Map;Ia("segments",v,M,E),Ia("silhouettes",v,M,E),v.polylines&&function(v,M,b){const E=new Uint32Array(v.nextIndicesAndParams.buffer,v.nextIndicesAndParams.byteOffset,v.nextIndicesAndParams.length/4),D=v.prevIndices[Symbol.iterator]();let X=0;const z={};for(const R of v.indices){if(Pa(z,R,M)){const v=D.next().value;e(void 0!==v);const M=z.node.remappedIndices.get(v);e(void 0!==M);let R=E[X];const O=(16777215&R)>>>0,Y=z.node.remappedIndices.get(O);e(void 0!==Y),R=4278190080&R|Y;let N=b.get(z.id);N||b.set(z.id,N={}),N.polylines||(N.polylines=new va),N.polylines.indices.push(z.index),N.polylines.prevIndices.push(M),N.polylines.nextIndicesAndParams.push(R)}++X}}(v.polylines,M,E),v.indexed&&function(v,M,b){const E=v.edges.data,D=v.edges.numSegments,X=6*D+v.edges.silhouettePadding;function a(v){return[E[v+0]|E[v+1]<<8|E[v+2]<<16,E[v+3]|E[v+4]<<8|E[v+5]<<16]}function c(v){return[E[v+0]|E[v+1]<<8|E[v+2]<<16,E[v+3]|E[v+4]<<8|E[v+5]<<16,E[v+6]|E[v+7]<<8,E[v+8]|E[v+9]<<8]}function h(v,M,b,E,D){v.silhouettes.push(255&M),v.silhouettes.push((65280&M)>>>8),v.silhouettes.push((16711680&M)>>>16),v.silhouettes.push(255&b),v.silhouettes.push((65280&b)>>>8),v.silhouettes.push((16711680&b)>>>16),v.silhouettes.push(255&E),v.silhouettes.push((65280&E)>>>8),v.silhouettes.push(255&D),v.silhouettes.push((65280&D)>>>8)}let z=0;for(const Sr of v.indices)z=Math.max(Sr,z);const R={};let O=0,Y=0,N=0,B=0;for(let Sr=0,Cr=0;Sr<=z;++Sr)if(Sr<D?([O,Y]=a(Cr),Cr+=6):(Cr=X+10*(Sr-D),[O,Y,N,B]=c(Cr)),Pa(R,O,M)){let v=b.get(R.id);if(v||b.set(R.id,v={}),v.indexed||(v.indexed={edges:new ha,silhouettes:new ha}),Sr<D){const M=R.node.remappedIndices.get(O);e(void 0!==M);const b=R.node.remappedIndices.get(Y);e(void 0!==b),L=M,U=b,(V=v.indexed).edges.push(255&L),V.edges.push((65280&L)>>>8),V.edges.push((16711680&L)>>>16),V.edges.push(255&U),V.edges.push((65280&U)>>>8),V.edges.push((16711680&U)>>>16)}else{const M=R.node.remappedIndices.get(O);e(void 0!==M);const b=R.node.remappedIndices.get(Y);e(void 0!==b),h(v.indexed,M,b,N,B)}}var V,L,U}(v.indexed,M,E);const D=new Map;for(const[X,z]of E){if(!z.segments&&!z.silhouettes&&!z.indexed)continue;let M={},E={};if(z.indexed){const v=z.indexed.edges.length/6,D=z.indexed.silhouettes.length/10,{width:X,height:R,silhouettePadding:O,silhouetteStartByteIndex:Y}=da(v,D,b),N=new Uint8Array(X*R*4);N.set(z.indexed.edges.toTypedArray(),0),D>0&&N.set(z.indexed.silhouettes.toTypedArray(),Y+O);const B=v+D;E=new ua(new Uint8Array(6*B*3));for(let M=0;M<B;M++)for(let v=0;v<6;v++)E.setNthIndex(6*M+v,M);M={data:N,width:X,height:R,numSegments:v,silhouettePadding:O}}D.set(X,{weight:v.weight,linePixels:v.linePixels,segments:z.segments?{indices:z.segments.indices.toVertexIndices(),endPointAndQuadIndices:z.segments.endPointAndQuadIndices.toUint8Array()}:void 0,silhouettes:z.silhouettes?{indices:z.silhouettes.indices.toVertexIndices(),endPointAndQuadIndices:z.silhouettes.endPointAndQuadIndices.toUint8Array(),normalPairs:z.silhouettes.normalPairs.toUint8Array()}:void 0,polylines:z.polylines?{indices:z.polylines.indices.toVertexIndices(),prevIndices:z.polylines.prevIndices.toVertexIndices(),nextIndicesAndParams:z.polylines.nextIndicesAndParams.toUint8Array()}:void 0,indexed:z.indexed?{indices:E,edges:M}:void 0})}return D}(v.params.edges,X,v.maxDimension):void 0;for(const[R,O]of X){const{vertices:b,indices:E,material:D}=O.buildOutput(v.maxDimension),X={vertices:b,surface:{type:v.params.surface.type,indices:E,fillFlags:v.params.surface.fillFlags,hasBakedLighting:v.params.surface.hasBakedLighting,textureMapping:v.params.surface.textureMapping,material:void 0!==D?D:v.params.surface.material},edges:z?.get(R),isPlanar:v.params.isPlanar,auxChannels:v.params.auxChannels};M.set(R,X)}return M}function Sa(v){const M=ya.split({indices:v.params.polyline.indices,vertices:v.params.vertices,featureTable:v.featureTable},v.computeNodeId),b=v.params.polyline,E=new Uint32Array(b.nextIndicesAndParams.buffer,b.nextIndicesAndParams.byteOffset,b.nextIndicesAndParams.length/4);let D=0;const X={};for(const R of b.prevIndices){if(Pa(X,R,M)){const v=X.node;v.prevIndices?e(void 0!==v.nextIndicesAndParams):(e(void 0===v.nextIndicesAndParams),v.prevIndices=new fa(v.indices.numIndices),v.nextIndicesAndParams=new la({initialCapacity:v.indices.numIndices})),v.prevIndices.push(X.index);let M=E[D];const b=(16777215&M)>>>0,z=X.node.remappedIndices.get(b);e(void 0!==z),M=4278190080&M|z,v.nextIndicesAndParams.push(M)}++D}const z=new Map;for(const[R,O]of M){e(void 0!==O.prevIndices&&void 0!==O.nextIndicesAndParams);const{vertices:M,indices:b}=O.buildOutput(v.maxDimension),E={...v.params,vertices:M,polyline:{indices:b,prevIndices:O.prevIndices.toVertexIndices(),nextIndicesAndParams:O.nextIndicesAndParams.toUint8Array()}};z.set(R,E)}return z}var ic,sc;function Ta(v,M,b){v[M+0]=255&b,v[M+1]=(65280&b)>>>8,v[M+2]=(16711680&b)>>>16}!function(v){v[v.Untransformed=4294967295]="Untransformed"}(ic||(ic={})),function(v){v[v.Hidden=0]="Hidden",v[v.Silhouette=1]="Silhouette",v[v.Visible=2]="Visible"}(sc||(sc={}));class Fa extends Ro{get isValid(){return bo.Gltf===this.format}constructor(v){super(v),this.scenePosition=0,this.sceneStrLength=0,this.binaryPosition=0,this.gltfLength=v.readUint32(),this.sceneStrLength=v.readUint32();const M=v.readUint32();if(this.version===Xo.Version2&&M===Xo.Gltf1SceneFormat&&(this.version=Xo.Version1),this.version===Xo.Version1){const b=M;if(Xo.Gltf1SceneFormat!==b)return void this.invalidate();this.scenePosition=v.curPos,this.binaryPosition=v.curPos+this.sceneStrLength}else if(this.version===Xo.Version2){const b=M;this.scenePosition=v.curPos,v.curPos=v.curPos+this.sceneStrLength;const E=v.readUint32(),D=v.readUint32();if(Jo.JSON!==b||Jo.Binary!==D||0===E)return void this.invalidate();this.binaryPosition=v.curPos}else this.invalidate()}}const nc=/Node_(.*)/;function Ma(v){const M=v.match(nc);if(e(!!M&&2===M.length),!M||2!==M.length)return 0;const b=Number.parseInt(M[1],10);return e(!Number.isNaN(b)),Number.isNaN(b)?0:b}class ba extends No{constructor(v){super(v)}dispose(){}get bytesUsed(){return 0}}class Ea extends ba{constructor(v,M){super(M),this._name=v}toImdl(){return this._name}}class Da extends ba{constructor(v){super(No.Type.Normal),this._gradient=v}toImdl(){return this._gradient}}class Xa extends Yo{toImdl(){return{isAtlas:!1,material:this.key??this.materialParams}}constructor(v,M){super(v),this.materialParams=M??{alpha:v.alpha,diffuse:{color:v.diffuseColor?.toJSON(),weight:v.diffuse},specular:{color:v.specularColor?.toJSON(),weight:v.specular,exponent:v.specularExponent}}}static create(v){const M=new Yo.Params;return M.alpha=v.alpha,v.diffuse&&(void 0!==v.diffuse.weight&&(M.diffuse=v.diffuse?.weight),v.diffuse?.color&&(M.diffuseColor=v.diffuse.color instanceof Mr?v.diffuse.color:br.fromJSON(v.diffuse.color).toColorDef())),v.specular&&(void 0!==v.specular.weight&&(M.specular=v.specular.weight),void 0!==v.specular.exponent&&(M.specularExponent=v.specular.exponent),v.specular.color&&(M.specularColor=v.specular.color instanceof Mr?v.specular.color:br.fromJSON(v.specular.color).toColorDef())),new Xa(M)}}function Ra(v){return{...v,uniformColor:void 0!==v.uniformColor?Mr.fromJSON(v.uniformColor):void 0,qparams:Vo.fromJSON(v.qparams),uvParams:v.uvParams?Oo.fromJSON(v.uvParams):void 0}}function za(v){return{...v,uniformColor:v.uniformColor?.toJSON(),qparams:v.qparams.toJSON(),uvParams:v.uvParams?.toJSON()}}function Na(v){return{...v,segments:v.segments?{...v.segments,indices:v.segments.indices.data}:void 0,silhouettes:v.silhouettes?{...v.silhouettes,indices:v.silhouettes.indices.data}:void 0,polylines:v.polylines?{...v.polylines,indices:v.polylines.indices.data,prevIndices:v.polylines.prevIndices.data}:void 0,indexed:v.indexed?{indices:v.indexed.indices.data,edges:v.indexed.edges}:void 0}}class Ya{constructor(v,M,b,E,D){this._patterns=new Map,this._document=v,this._binaryData=M,this._options=b,this._featureTableInfo=E,this._stream=D,this._timeline=b.timeline}parse(){const v=this.parseFeatureTable();if(!v)return Eo.InvalidFeatureTable;const M=this._document.rtcCenter?{x:this._document.rtcCenter[0]??0,y:this._document.rtcCenter[1]??0,z:this._document.rtcCenter[2]??0}:void 0;return{featureTable:v,nodes:this.parseNodes(v),rtcCenter:M,binaryData:this._binaryData,json:this._document,patterns:this._patterns}}parseFeatureTable(){this._stream.curPos=this._featureTableInfo.startPos;const v=Zo.readFrom(this._stream);if(!v||0!=v.length%4)return;const M=(v.length-Zo.sizeInBytes)/4,b=new Uint32Array(this._stream.nextUint32s(M));if(this._stream.isPastTheEnd)return;let E;if(this._featureTableInfo.multiModel)E={multiModel:!0,data:b,numFeatures:v.count,numSubCategories:v.numSubCategories};else{let M;const D=this._document.animationNodes;if(void 0!==D){const v=ko.asInt(D.bytesPerId),b=ko.asString(D.bufferView),E=this._document.bufferViews[b];if(void 0!==E){const b=ko.asInt(E.byteOffset),D=ko.asInt(E.byteLength),X=this._binaryData.subarray(b,b+D);switch(v){case 1:M=new Uint8Array(X);break;case 2:M=Uint16Array.from(new Uint16Array(X.buffer,X.byteOffset,X.byteLength/2));break;case 4:M=Uint32Array.from(new Uint32Array(X.buffer,X.byteOffset,X.byteLength/4))}}}E={multiModel:!1,data:b,numFeatures:v.count,animationNodeIds:M}}return this._stream.curPos=this._featureTableInfo.startPos+v.length,E}parseNodes(v){const M=[],b=this._document.nodes,E=this._document.meshes;if(void 0===b.Node_Root)return M;for(const D of Object.keys(b)){const b=this._document.nodes[D];e(void 0!==b);const X=E[b],z=X?.primitives;if(!z)continue;const R=X.layer;"Node_Root"===D?this._timeline?this.parseAnimationBranches(M,X,v,this._timeline):this._options.createUntransformedRootNode?M.push({animationNodeId:ic.Untransformed,primitives:this.parseNodePrimitives(z)}):M.push({primitives:this.parseNodePrimitives(z)}):void 0===R?M.push({animationNodeId:Ma(D),animationId:`${this._options.batchModelId}_${D}`,primitives:this.parseNodePrimitives(z)}):M.push({layerId:R,primitives:this.parseNodePrimitives(z)})}return M}parseAnimationBranches(v,M,b,E){const D=M.primitives;if(!D)return;const X=new Map,a=M=>{let b=X.get(M);return b||(b={animationNodeId:M,animationId:`${this._options.batchModelId}_Node_${M}`,primitives:[]},X.set(M,b),v.push(b)),b};e(void 0===b.animationNodeIds);const z=function(v,M){const b=v.multiModel?Gr.create(v.data,M,v.numFeatures,vo.Primary,v.numSubCategories):new Zr(v.data,M,v.numFeatures,vo.Primary);return b.animationNodeIds=v.animationNodeIds,b}(b,this._options.batchModelId);z.populateAnimationNodeIds((v=>E.getBatchIdForFeature(v)),E.maxBatchId),b.animationNodeIds=z.animationNodeIds;const R=E.discreteBatchIds,O={maxDimension:this._options.maxVertexTableSize,computeNodeId:v=>{const M=z.getAnimationNodeId(v);return 0!==M&&R.has(M)?M:0},featureTable:z},d=v=>{if(!v)return;if(v.isAtlas)return v;const M="string"==typeof v.material?this.materialFromJson(v.material):Xa.create(function(v){const M={alpha:v.alpha};return v.diffuse&&(M.diffuse={weight:v.diffuse.weight,color:void 0!==v.diffuse.color?Mr.fromJSON(v.diffuse.color):void 0}),v.specular&&(M.specular={weight:v.specular.weight,exponent:v.specular.exponent,color:void 0!==v.specular.color?Mr.fromJSON(v.specular.color):void 0}),M}(v.material));return M?{isAtlas:!1,material:M}:void 0};for(const N of D){const v=this.parseNodePrimitive(N);if(v)switch(v.type){case"pattern":a(ic.Untransformed).primitives.push(v);break;case"mesh":{const M=v.params,b=M.surface.textureMapping,E={vertices:Ra(v.params.vertices),surface:{...v.params.surface,indices:new ua(v.params.surface.indices),material:d(M.surface.material),textureMapping:b?{alwaysDisplayed:b.alwaysDisplayed,texture:"string"==typeof b.texture?new Ea(b.texture,No.Type.Normal):new Da(b.texture)}:void 0},edges:v.params.edges?(Y=v.params.edges,{...Y,segments:Y.segments?{...Y.segments,indices:new ua(Y.segments.indices)}:void 0,silhouettes:Y.silhouettes?{...Y.silhouettes,indices:new ua(Y.silhouettes.indices)}:void 0,polylines:Y.polylines?{...Y.polylines,indices:new ua(Y.polylines.indices),prevIndices:new ua(Y.polylines.prevIndices)}:void 0,indexed:Y.indexed?{indices:new ua(Y.indexed.indices),edges:Y.indexed.edges}:void 0}):void 0,isPlanar:v.params.isPlanar,auxChannels:v.params.auxChannels?na.fromJSON(v.params.auxChannels):void 0},D=Aa({...O,params:E,createMaterial:v=>Xa.create(v)});for(const[v,X]of D){let M;X.surface.material&&(X.surface.material.isAtlas?M=X.surface.material:(e(X.surface.material.material instanceof Xa),M=X.surface.material.material.toImdl())),e(void 0===X.surface.textureMapping||X.surface.textureMapping.texture instanceof ba),a(v).primitives.push({type:"mesh",params:{vertices:za(X.vertices),surface:{...X.surface,indices:X.surface.indices.data,material:M,textureMapping:X.surface.textureMapping?.texture instanceof ba?{texture:X.surface.textureMapping.texture.toImdl(),alwaysDisplayed:X.surface.textureMapping.alwaysDisplayed}:void 0},edges:X.edges?Na(X.edges):void 0,isPlanar:X.isPlanar,auxChannels:X.auxChannels?.toJSON()}})}break}case"point":{const M={vertices:Ra(v.params.vertices),indices:new ua(v.params.indices),weight:v.params.weight},b=_a({...O,params:M});for(const[v,E]of b)a(v).primitives.push({type:"point",params:{vertices:za(E.vertices),indices:E.indices.data,weight:E.weight}});break}case"polyline":{const M={...v.params,vertices:Ra(v.params.vertices),polyline:{indices:new ua(v.params.polyline.indices),prevIndices:new ua(v.params.polyline.prevIndices),nextIndicesAndParams:v.params.polyline.nextIndicesAndParams}},b=Sa({...O,params:M});for(const[v,E]of b)a(v).primitives.push({type:"polyline",params:{...E,vertices:za(E.vertices),polyline:{indices:E.polyline.indices.data,prevIndices:E.polyline.prevIndices.data,nextIndicesAndParams:E.polyline.nextIndicesAndParams}}});break}}}var Y}parseTesselatedPolyline(v){const M=this.findBuffer(v.indices),b=this.findBuffer(v.prevIndices),E=this.findBuffer(v.nextIndicesAndParams);return M&&b&&E?{indices:M,prevIndices:b,nextIndicesAndParams:E}:void 0}parseSegmentEdges(v){const M=this.findBuffer(v.indices),b=this.findBuffer(v.endPointAndQuadIndices);return M&&b?{indices:M,endPointAndQuadIndices:b}:void 0}parseSilhouetteEdges(v){const M=this.parseSegmentEdges(v),b=this.findBuffer(v.normalPairs);return M&&b?{...M,normalPairs:b}:void 0}parseIndexedEdges(v){const M=this.findBuffer(v.indices),b=this.findBuffer(v.edges);if(M&&b)return{indices:M,edges:{data:b,width:v.width,height:v.height,silhouettePadding:v.silhouettePadding,numSegments:v.numSegments}}}parseCompactEdges(v,M){const b=this.findBuffer(v.visibility);if(!b)return;const E=void 0!==v.normalPairs?this.findBuffer(v.normalPairs):void 0;return function(v){const M=v.normalPairs?.length??0,b=v.numVisibleEdges+M;if(b<=0)return;const E=new ua(new Uint8Array(6*b*3));for(let B=0;B<b;B++)for(let v=0;v<6;v++)E.setNthIndex(6*B+v,B);const{width:D,height:X,silhouettePadding:z,silhouetteStartByteIndex:R}=da(v.numVisibleEdges,M,v.maxEdgeTableDimension),O=new Uint8Array(D*X*4);let Y=0,N=0;for(const B of function*(v,M,b){let E=0,D=0,X=0;const z={index0:0,index1:1};for(let R=0;R<M.length;R++){const O=v[D]>>E&3;E+=2,8===E&&(E=0,D++),sc.Hidden!==O&&(z.index0=M.decodeIndex(R),z.index1=M.decodeIndex(R%3==2?R-2:R+1),sc.Silhouette===O?(e(void 0!==b),z.normals=b[X++]):z.normals=void 0,yield z)}}(v.visibility,v.vertexIndices,v.normalPairs))if(void 0===B.normals){const v=6*Y++;Ta(O,v,B.index0),Ta(O,v+3,B.index1)}else{const v=R+z+10*N++;Ta(O,v,B.index0),Ta(O,v+3,B.index1),O[v+6]=255&B.normals,O[v+7]=(65280&B.normals)>>>8,O[v+8]=(16711680&B.normals)>>>16,O[v+9]=(4278190080&B.normals)>>>24}return{indices:E.data,edges:{data:O,width:D,height:X,numSegments:v.numVisibleEdges,silhouettePadding:z}}}({numVisibleEdges:v.numVisible,visibility:b,vertexIndices:M,normalPairs:E?new Uint32Array(E.buffer,E.byteOffset,E.byteLength/4):void 0,maxEdgeTableDimension:this._options.maxVertexTableSize})}parseEdges(v,M,b){if(!v)return;const E=v.segments?this.parseSegmentEdges(v.segments):void 0,D=v.silhouettes?this.parseSilhouetteEdges(v.silhouettes):void 0,X=v.polylines?this.parseTesselatedPolyline(v.polylines):void 0;let z=v.indexed?this.parseIndexedEdges(v.indexed):void 0;return!z&&v.compact&&(z=this.parseCompactEdges(v.compact,new ua(b))),E||D||z||X?{segments:E,silhouettes:D,polylines:X,indexed:z,weight:M.width,linePixels:M.linePixels}:void 0}getPattern(v){let M=this._patterns.get(v);if(!M){const b=this._document.patternSymbols[v];M=b?this.parsePrimitives(b.primitives):[],this._patterns.set(v,M)}return M.length>0?M:void 0}parseAreaPattern(v){const M=this.getPattern(v.symbolName);if(!M||0===M.length)return;const b=this.findBuffer(v.xyOffsets);return b?{type:"pattern",params:{...v,xyOffsets:new Float32Array(b.buffer,b.byteOffset,b.byteLength/4)}}:void 0}parseNodePrimitives(v){const M=[];for(const b of v){const v=this.parseNodePrimitive(b);v&&M.push(v)}return M}parseNodePrimitive(v){return"areaPattern"===v.type?this.parseAreaPattern(v):this.parsePrimitive(v)}parsePrimitives(v){const M=[];for(const b of v){const v=this.parsePrimitive(b);v&&M.push(v)}return M}parsePrimitive(v){let M=this.parseInstances(v);if(!M&&v.viewIndependentOrigin){const b=Q.fromJSON(v.viewIndependentOrigin);M={type:"viewIndependentOrigin",origin:{x:b.x,y:b.y,z:b.z}}}const b=v.material??"",E=b.length?ko.asObject(this._document.materials[b]):void 0,D=E?this.parseDisplayParams(E):void 0;if(!D)return;const X=this.parseVertexTable(v);if(!X)return;let z;const R=!this._options.is3d||ko.asBool(v.isPlanar);switch(v.type){case $a.Mesh:{const M=this.parseSurface(v,D);M&&(z={type:"mesh",params:{vertices:X,surface:M,isPlanar:R,auxChannels:this.parseAuxChannelTable(v),edges:this.parseEdges(v.edges,D,M.indices)}});break}case $a.Polyline:{const M=this.parseTesselatedPolyline(v);if(M){let v=Va.Normal;Ho.RegionEdgeType.Outline===D.regionEdgeType&&(v=!D.gradient||D.gradient.isOutlined?Va.Edge:Va.Outline),z={type:"polyline",params:{vertices:X,polyline:M,isPlanar:R,type:v,weight:D.width,linePixels:D.linePixels}}}break}case $a.Point:{const M=this.findBuffer(v.indices),b=D.width;M&&(z={type:"point",params:{vertices:X,indices:M,weight:b}});break}}return z&&(z.modifier=M),z}parseSurface(v,M){const b=v.surface;if(!b)return;const E=this.findBuffer(b.indices);if(!E)return;const D=b.type;if(!function(v){switch(v){case ja.Unlit:case ja.Lit:case ja.Textured:case ja.TexturedLit:case ja.VolumeClassifier:return!0;default:return!1}}(D))return;const X=M.textureMapping?.texture;let z;const R=v.vertices.materialAtlas,O=v.vertices.numColors;let Y;return R&&void 0!==O?z={isAtlas:!0,hasTranslucency:ko.asBool(R.hasTranslucency),overridesAlpha:ko.asBool(R.overridesAlpha,!1),vertexTableOffset:ko.asInt(O),numMaterials:ko.asInt(R.numMaterials)}:M.material&&(e(M.material instanceof Xa),z=M.material.toImdl()),X&&(e(X instanceof ba),Y={texture:X.toImdl(),alwaysDisplayed:ko.asBool(b.alwaysDisplayTexture)}),{type:D,indices:E,fillFlags:M.fillFlags,hasBakedLighting:!1,material:z,textureMapping:Y}}parseAuxChannelTable(v){const M=v.auxChannels;if(void 0===M)return;const b=this.findBuffer(ko.asString(M.bufferView));return void 0!==b?{data:b,width:M.width,height:M.height,count:M.count,numBytesPerVertex:M.numBytesPerVertex,displacements:M.displacements,normals:M.normals,params:M.params}:void 0}parseVertexTable(v){const M=v.vertices;if(!M)return;const b=this.findBuffer(ko.asString(M.bufferView));if(!b)return;const E=void 0!==M.featureID?ko.asInt(M.featureID):void 0,D=ko.asArray(M.params.decodedMin),X=ko.asArray(M.params.decodedMax);if(void 0===D||void 0===X)return;const z=Vo.fromRange(ut.create(Q.create(D[0],D[1],D[2]),Q.create(X[0],X[1],X[2]))),R=void 0!==M.uniformColor?Mr.fromJSON(M.uniformColor):void 0;let O;if($a.Mesh===v.type&&v.surface&&v.surface.uvParams){const M=v.surface.uvParams.decodedMin,b=v.surface.uvParams.decodedMax,E=new gt(M[0],M[1],b[0],b[1]);O=Oo.fromRange(E)}return{data:b,usesUnquantizedPositions:!0===M.usesUnquantizedPositions,qparams:z.toJSON(),width:M.width,height:M.height,hasTranslucency:M.hasTranslucency,uniformColor:R?.toJSON(),featureIndexType:M.featureIndexType,uniformFeatureID:E,numVertices:M.count,numRgbaPerVertex:M.numRgbaPerVertex,uvParams:O?.toJSON()}}parseInstances(v){const M=v.instances;if(!M)return;const b=ko.asInt(M.count,0);if(b<=0)return;const E=ko.asArray(M.transformCenter);if(void 0===E||3!==E.length)return;const D=Q.create(E[0],E[1],E[2]),X=this.findBuffer(ko.asString(M.featureIds));if(void 0===X)return;const z=this.findBuffer(ko.asString(M.transforms));if(void 0===z)return;const R=z.byteLength/4;e(Math.floor(R)===R),e(0==R%12);const O=new Float32Array(z.buffer,z.byteOffset,R);let Y;return void 0!==M.symbologyOverrides&&(Y=this.findBuffer(ko.asString(M.symbologyOverrides))),{type:"instances",count:b,transforms:O,transformCenter:D,featureIds:X,symbologyOverrides:Y}}findBuffer(v){if("string"!=typeof v||0===v.length)return;const M=this._document.bufferViews[v];if(void 0===M)return;const b=ko.asInt(M.byteOffset),E=ko.asInt(M.byteLength);return 0!==E?this._binaryData.subarray(b,b+E):void 0}colorDefFromMaterialJson(v){return void 0!==v?Mr.from(255*v[0]+.5,255*v[1]+.5,255*v[2]+.5):void 0}materialFromJson(v){const M=this._document.renderMaterials[v];if(!M)return;const b=new Yo.Params(v);return b.diffuseColor=this.colorDefFromMaterialJson(M.diffuseColor),void 0!==M.diffuse&&(b.diffuse=ko.asDouble(M.diffuse)),b.specularColor=this.colorDefFromMaterialJson(M.specularColor),void 0!==M.specular&&(b.specular=ko.asDouble(M.specular)),b.reflectColor=this.colorDefFromMaterialJson(M.reflectColor),void 0!==M.reflect&&(b.reflect=ko.asDouble(M.reflect)),void 0!==M.specularExponent&&(b.specularExponent=M.specularExponent),void 0!==M.transparency&&(b.alpha=1-M.transparency),b.refract=ko.asDouble(M.refract),b.shadows=ko.asBool(M.shadows),b.ambient=ko.asDouble(M.ambient),void 0!==M.textureMapping&&(b.textureMapping=this.textureMappingFromJson(M.textureMapping.texture)),new Xa(b)}parseNamedTexture(v,M){const b=ko.asBool(v.isGlyph)?No.Type.Glyph:ko.asBool(v.isTileSection)?No.Type.TileSection:No.Type.Normal;return new Ea(M,b)}parseConstantLodProps(v){if(void 0!==v)return{repetitions:ko.asDouble(v.repetitions,1),offset:{x:v.offset?ko.asDouble(v.offset[0]):0,y:v.offset?ko.asDouble(v.offset[1]):0},minDistClamp:ko.asDouble(v.minDistClamp,1),maxDistClamp:ko.asDouble(v.maxDistClamp,4294967296)}}textureMappingFromJson(v){if(!v)return;const M=ko.asString(v.name),b=0!==M.length?this._document.namedTextures[M]:void 0,E=b?this.parseNamedTexture(b,M):void 0;if(!E)return;const D=v.params,X=D.transform,z={textureMat2x3:new qo.Trans2x3(X[0][0],X[0][1],X[0][2],X[1][0],X[1][1],X[1][2]),textureWeight:ko.asDouble(D.weight,1),mapMode:ko.asInt(D.mode),worldMapping:ko.asBool(D.worldMapping),useConstantLod:ko.asBool(D.useConstantLod),constantLodProps:this.parseConstantLodProps(D.constantLodParams)},R=new qo(E,new qo.Params(z)),O=v.normalMapParams;if(O){const v=ko.asString(O.textureName),M=v.length>0?this._document.namedTextures[v]:void 0,b=M?this.parseNamedTexture(M,v):void 0;b&&(R.normalMapParams={normalMap:b,greenUp:ko.asBool(O.greenUp),scale:ko.asDouble(O.scale,1),useConstantLod:ko.asBool(O.useConstantLod)})}return R}parseDisplayParams(v){const M=ko.asInt(v.type,Ho.Type.Mesh),b=Mr.create(ko.asInt(v.lineColor)),E=Mr.create(ko.asInt(v.fillColor)),D=ko.asInt(v.lineWidth),X=ko.asInt(v.linePixels,La.Solid),z=ko.asInt(v.fillFlags,Ua.None),R=ko.asBool(v.ignoreLighting),O=v.materialId,Y=void 0!==O?this.materialFromJson(O):void 0;let N,B;if(!Y){const M=v.texture;if(N=void 0!==M?this.textureMappingFromJson(M):void 0,void 0===N){const M=v.gradient;if(B=void 0!==M?Ja.Symb.fromJSON(M):void 0,B){e(void 0!==M);const v=new Da(M);N=new qo(v,new qo.Params({textureMat2x3:new qo.Trans2x3(0,1,0,1,0,0)}))}}}return new Ho(M,b,E,D,X,z,Y,B,R,N)}}let rc;var oc;oc={parse:v=>{const M=function(v){const M=co.fromUint8Array(v.data),b=new Uo(M);if(!b.isValid)return Eo.InvalidHeader;if(!b.isReadableVersion)return Eo.NewerMajorVersion;const E=M.curPos,D=Zo.readFrom(M);if(!D)return Eo.InvalidFeatureTable;M.curPos=E+D.length;const X=new Fa(M);if(!X.isValid)return Eo.InvalidTileData;M.curPos=X.scenePosition;const z=function(v){let M;if(Mo)try{M=new TextDecoder("utf-8")}catch(v){Mo=!1}return void 0!==M?M.decode(v):function(v){return Fo.decodeWithFromCharCode(v)}(v)}(M.nextBytes(X.sceneStrLength));if(!z)return Eo.InvalidScene;try{const D=JSON.parse(z),R={scene:ko.asString(D.scene),scenes:ko.asArray(D.scenes),animationNodes:ko.asObject(D.animationNodes),bufferViews:ko.asObject(D.bufferViews)??{},meshes:ko.asObject(D.meshes),nodes:ko.asObject(D.nodes)??{},materials:ko.asObject(D.materials)??{},renderMaterials:ko.asObject(D.renderMaterials)??{},namedTextures:ko.asObject(D.namedTextures)??{},patternSymbols:ko.asObject(D.patternSymbols)??{},rtcCenter:ko.asArray(D.rtcCenter)};if(!R.meshes)return Eo.InvalidTileData;const O=new Uint8Array(M.arrayBuffer,X.binaryPosition),Y={startPos:E,multiModel:0!=(b.flags&Oa.MultiModelFeatureTable)};return new Ya(R,O,v,Y,M).parse()}catch(v){return Eo.InvalidTileData}}({...v,data:v.data,timeline:rc});return"number"==typeof M?M:{result:M,transfer:ao(M)}},setTimeline:v=>{e(void 0===rc,"setTimeline must be called only once"),rc=Array.isArray(v)?To.Script.fromJSON(v):To.ModelTimeline.fromJSON(v)}},onmessage=v=>{const M=v.data,b=M.msgId;try{e("object"==typeof M&&"operation"in M&&"payload"in M&&"msgId"in M);const v=oc[M.operation];e("function"==typeof v);const E=v(M.payload);"object"==typeof E&&"transfer"in E?postMessage({result:E.result,msgId:b},{transfer:E.transfer}):postMessage({result:E,msgId:b})}catch(v){const M=v instanceof Error?v:new Error("Unknown worker error");postMessage({error:M,msgId:b})}}})();